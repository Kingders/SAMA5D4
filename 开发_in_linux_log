20161207
linux上使用EDBG:
	开发板 EDGB_USB 接到linux dmesg:	
[308172.946989] usb 2-1.2: new high-speed USB device number 4 using ehci-pci
[308173.039761] usb 2-1.2: config 1 interface 2 altsetting 0 bulk endpoint 0x84 has invalid maxpacket 64
[308173.039771] usb 2-1.2: config 1 interface 2 altsetting 0 bulk endpoint 0x5 has invalid maxpacket 64
[308173.040772] usb 2-1.2: New USB device found, idVendor=03eb, idProduct=2111
[308173.040780] usb 2-1.2: New USB device strings: Mfr=1, Product=2, SerialNumber=3
[308173.040785] usb 2-1.2: Product: EDBG CMSIS-DAP
[308173.040790] usb 2-1.2: Manufacturer: Atmel Corp.
[308173.040793] usb 2-1.2: SerialNumber: ATML0000004141319438
[308173.044631] hid-generic 0003:03EB:2111.000E: hiddev0,hidraw1: USB HID v1.11 Device [Atmel Corp. EDBG CMSIS-DAP] on usb-0000:00:1d.0-1.2/input0
[308173.185664] cdc_acm 2-1.2:1.1: ttyACM0: USB ACM device
[308173.186015] usbcore: registered new interface driver cdc_acm
[308173.186019] cdc_acm: USB Abstract Control Model driver for USB modems and ISDN adapters
	直接就连上了,不用手动去装驱动文件	
	用SecureCRT连接ttyACM0:115200,8,N,1可观察输出	
linux上使用sam-ba烧录:
	开发板 A5-USB-A 接到linux dmsg:
[310103.548967] usb 1-1.2: new high-speed USB device number 17 using ehci-pci
[310103.642544] usb 1-1.2: New USB device found, idVendor=0525, idProduct=a4a7
[310103.642554] usb 1-1.2: New USB device strings: Mfr=1, Product=2, SerialNumber=0
[310103.642560] usb 1-1.2: Product: Gadget Serial v2.4
[310103.642564] usb 1-1.2: Manufacturer: Linux 4.1.0-linux4sam_5.3 with atmel_usba_udc
[310103.649274] cdc_acm 1-1.2:2.0: ttyACM1: USB ACM device
	安装sam-ba到linux,直接atmel下载sam-ba_3.1.4-linux_x86_64.tar.gz,解压即用(cd到samba目录,./sam-ba)
	提示/usr/lib/x86_64-linux-gnu/libstdc++.so.6: version `CXXABI_1.3.9' not found, 相当麻烦,暂时放弃linux烧录
	









20161208	
尝试编译:
	make ARCH=arm sama5_defconfig
	make ARCH=arm menuconfig	//只选 sama5d4 的板子
	make ARCH=arm CROSS_COMPILE=arm-linux-
	error:
	/tmp/ccnZ9dmH.s: Assembler messages:
	/tmp/ccybbHfr.s:176: Error: garbage following instruction -- `dsb nshst'
	/tmp/ccybbHfr.s:184: Error: garbage following instruction -- `dsb nsh'
	编译器版本不对:










20161220
重新安装 sam-ba_3.1.4到ubuntu
	sudo tar -zxvf sam-ba_3.1.4-linux_x86_64.tar.gz -C /opt		//解压到/opt
	到 /opt/sam-ba_3.1.4 目录下
	sudo gedit ~/.bashrc 修改 常用户的.bashrc,末尾添加,搜索库路径:
		LD_LIBRARY_PATH=/usr/local/lib64/:$LD_LIBRARY_PATH
		export LD_LIBRARY_PATH
	source ~/.bashrc 更新用户bashrc配置 
		(如果不添加搜索库路径会出现,
		sam-ba: symbol lookup error: sam-ba: undefined symbol: _ZN7QString18toLocal8Bit_helperEPK5QChari
		等没有找到相关lib参数的错误)
	sudo cp sam-ba /bin/sam-ba	拷贝执行文件到执行文件目录下,然后就可以使用sam-ba命令了
	sam-ba 输入命令,从输出中验证是否正确安装.
	提示/usr/lib/x86_64-linux-gnu/libstdc++.so.6: version `CXXABI_1.3.9' not found, 
		安装更新的gcc工具,从而更新 C++ 库文件
		sudo add-apt-repository ppa:ubuntu-toolchain-r/test
		sudo apt-get update
		sudo apt-get install gcc-4.9 g++-4.9
然后测试:
	sam-ba -p serial:ttyACM1:115200 -b sama5d4-xplained -a lowlevel	//测试是否链接到开发板!!
	一直提示 unknown port:	
	发现原来:sam-ba_3.1.4 /sam-ba 本身也只是一个软连接,并不是真正的执行bin文件,这不是重点
	上述安装思路:拷贝lib到系统搜索库,把执行bin拷到环境变量下,但是由于sam-ba 本身也只是一个软连接,所以最后运行功能并不完全
	比如正确的sam-ba指令,却出现各种错误,如段错误,uknown port...开始怀疑是由于搜不到其他关键配置文件或者lib文件有关!!
最后选择另外一条安装思路:
	直接把这个 /opt/sam-ba_3.1.4 路径加入到环境变量里去!!!
	sudo gedit ~/.bashrc 修改 常用户的.bashrc,末尾添加
		export PATH=$PATH:/opt/sam-ba_3.1.4
	source ~/.bashrc 更新用户bashrc配置
	这样,sam-ba需要搜索什么文件都可以直接在自身路径找到!!
	再次测试,一直提示:无权访问 serial ttyACM1,加sudo,表示找不到sam-ba命令
	把/opt/sam-ba_3.1.4 路径也加入到root用户的环境变量里去
	sudo gedit /root/.bashrc 修改 root用户的.bashrc,末尾添加:
		export PATH=$PATH:/opt/sam-ba_3.1.4
	sudo source /.bashrc 更新root用户bashrc配置
	su 到root用户
	再次测试,成功!
	然而,回到常用户,加sudo,依然表示找不到sam-ba命令!!
于是发现了 root用户 不等于 加sudo的常用户 !!
	加sudo, root用户, 常用户区别:
		root用户 和 常用户 都有自己的环境变量!!
		root用户一直以最高权限执行命令,都能执行
		常用户以常规权限执行命令,不一定能执行
		常用户加sudo,并没有转变当前用户,但是可以提高到最高权限执行命令
		但是加sudo时,常用户不再使用自己的环境变量,而是转到使用secure_path的环境变量上来,
		即不使用.bashrc里修改过的环境变量
	然而,secure_path的环境变量上没有我们的sam-ba命令,所以常用户加sudo后,并没有找到命令
	解决办法是:
		要求在常用户加sudo时,不自动转变到secure_path的环境变量上去
		sudo gedit ~/.bashrc 修改 常用户的.bashrc,末尾添加
			alias sudo='sudo env PATH=$PATH'
		source ~/.bashrc 更新常用户bashrc配置
最后,通过测试,sudo sam-ba -p serial:ttyACM1:115200 -b sama5d4-xplained -a lowlevel
至此,sam-ba实现所用功能!!
烧录sama5d4步骤：(测试使用的demo来自许工的linux4sam_5.3,非自己下载的更新版本的5.3)
	套上 BOOT_DIS 帽,转到SAMS5D4芯片固化程序的位置
	插上 A5-USB-A 供电，usb成功连接为AT91 USB to Serial Converter （COMx）
	取出 BOOT_DIS 帽,转到 NANDFlash 位置
	检查连接：
	sudo sam-ba -p serial:ttyACM1:115200 -b sama5d4-xplained -a lowlevel //然后会检测连接到usb串口的连接情况
	擦除nandflash：
	sudo sam-ba -p serial:ttyACM1:115200 -b sama5d4-xplained -a nandflash -c erase	
注意,先 cd 到 烧录文件所在目录!!
	烧写 bootloader_1：
	sudo sam-ba -p serial:ttyACM1:115200 -b sama5d4-xplained -a nandflash -c writeboot:at91bootstrap-sama5d4_xplained.bin
	烧写 bootloader_2：
	sudo sam-ba -p serial:ttyACM1:115200 -b sama5d4-xplained -a nandflash -c write:u-boot-sama5d4-xplained.bin:0x40000
	烧写 env (包含commandline/bootargs)：
	sudo sam-ba -p serial:ttyACM1:115200 -b sama5d4-xplained -a nandflash -c write:u-boot-env-sama5d4-xplained.bin:0xC0000
	烧写 device tree block 表：
	sudo sam-ba -p serial:ttyACM1:115200 -b sama5d4-xplained -a nandflash -c write:at91-sama5d4_xplained.dtb:0x180000
	烧写 kernel：
	sudo sam-ba -p serial:ttyACM1:115200 -b sama5d4-xplained -a nandflash -c write:zImage-sama5d4-xplained.bin:0x200000
	烧写 rootfs：
	sudo sam-ba -p serial:ttyACM1:115200 -b sama5d4-xplained -a nandflash -c write:atmel-xplained-demo-image-sama5d4-xplained.ubi:0x800000
镜像组合烧写命令:(注意,先 cd 到 烧录文件所在目录!!)
sudo sam-ba -p serial:ttyACM1:115200 -b sama5d4-xplained -a nandflash -c erase -c writeboot:at91bootstrap-sama5d4_xplained.bin -c write:u-boot-sama5d4-xplained.bin:0x40000 -c write:u-boot-env-sama5d4-xplained.bin:0xC0000 -c write:at91-sama5d4_xplained.dtb:0x180000 -c write:zImage-sama5d4-xplained.bin:0x200000 -c write:atmel-xplained-demo-image-sama5d4-xplained.ubi:0x800000

开pr_debug
例子:打开 i2c模块的 pr_debug:
1,查看:
	drivers/i2c/Makefile:有 ccflags-$(CONFIG_I2C_DEBUG_CORE) := -DDEBUG
	drivers/i2c/busses/Makefile:有 ccflags-$(CONFIG_I2C_DEBUG_CORE) := -DDEBUG
	表示支持 debug
	(注意:ccflags-y  := -DDEBUG	//相当于给mfd目录下的所有文件都加上了 (#define DEBUG))
2,打开.config观察:
	# CONFIG_I2C_DEBUG_BUS is not set
	# CONFIG_I2C_DEBUG_BUS is not set
	表示之前编译的没有打开!!
3,make ARCH=arm menuconfig
	Device Drivers -> I2C support ->
		(*)I2C Core debugging message
		(*)I2C Bus debugging message
	打开重新生成的.config观察
		# CONFIG_I2C_DEBUG_BUS=y
		# CONFIG_I2C_DEBUG_BUS=y
	表示打开了!!
4,include/linux/printk.h中:修改:
	//#define CONSOLE_LOGLEVEL_DEFAULT 7 
	#define CONSOLE_LOGLEVEL_DEFAULT 8 
	由于这样设置的 pr_debug 使用printk(KERN_DEBUG...)
	而printk(KERN_DEBUG...)的级别是7,#define CONSOLE_LOGLEVEL_DEFAULT 7 表示,只打印 小于级别7的消息
	所以改为: #define CONSOLE_LOGLEVEL_DEFAULT 8
5,重新编译(烧录并测试成功!!)
6,补充:
	pr_debug()在include/linux/printk.h 定义,按道理驱动文件中加入(#incude <linux/kernel.h>)就可以使用
	pr_debug()其实可以设置为两种模式,上述只是设置成静态模式(kernel初始化时可以输出消息)










20161221
备份烧写命令:
组合烧写：(不烧写env ，这样可以使用默认的uboot命令，自编译 zImage + dtb + ubifs + uboot + at91bootstrap)
sudo sam-ba -p serial:ttyACM1:115200 -b sama5d4-xplained -a nandflash -c erase -c writeboot:at91bootstrap-sama5d4_xplained.bin -c write:u-boot-sama5d4-xplained.bin:0x40000 -c write:at91-sama5d4_xplained.dtb:0x180000 -c write:zImage:0x200000 -c write:atmel-xplained-demo-image-sama5d4-xplained.ubi:0x800000
只刷新 zImage + dtb
sudo sam-ba -p serial:ttyACM1:115200 -b sama5d4-xplained -a nandflash -c erase:0x200000:0x600000 -c erase:0x180000:0x80000 -c write:at91-sama5d4_xplained.dtb:0x180000 -c write:zImage:0x200000
只刷新 zImage
sudo sam-ba -p serial:ttyACM1:115200 -b sama5d4-xplained -a nandflash -c erase:0x200000:0x600000 -c write:zImage:0x200000

编译完自动拷贝zImage到/demo
arch/arm/boot/Makefile:
$(obj)/zImage:	$(obj)/compressed/vmlinux FORCE
	$(call if_changed,uimage)
	@$(kecho) '  Image $@ is ready'
	cp $(obj)/uImage /home/infortech-ubuntu-1404/SAMA5D4/demo/		//编译完自动拷贝文件到demo

给 atmel_hlcdc 加入 pr_debug
1,先改 platform_driver_的注册
	原来:!!module_platform_driver(atmel_hlcdc_driver);
	先观察:
	printk.h
	/* If you are writing a driver, please use dev_dbg instead */
	#if defined(CONFIG_DYNAMIC_DEBUG)
	/* dynamic_pr_debug() uses pr_fmt() internally so we don't need it here */
	#define pr_debug(fmt, ...) \
		dynamic_pr_debug(fmt, ##__VA_ARGS__)
	#elif defined(DEBUG)
	#define pr_debug(fmt, ...) \
		printk(KERN_DEBUG pr_fmt(fmt), ##__VA_ARGS__)	//静态模式的pr_debug
	#else
	#define pr_debug(fmt, ...) \
		no_printk(KERN_DEBUG pr_fmt(fmt), ##__VA_ARGS__)
	#endif
	
	Platform_device.h
	#define module_platform_driver(__platform_driver) \
		module_driver(__platform_driver, platform_driver_register, \
				platform_driver_unregister)
	#define platform_driver_register(drv) \
		__platform_driver_register(drv, THIS_MODULE)
	void platform_driver_unregister(struct platform_driver *drv)
	{
		driver_unregister(&drv->driver);
	}
	
	device.h
	#define module_driver(__driver, __register, __unregister, ...) \
	static int __init __driver##_init(void) \
	{ \
		return __register(&(__driver) , ##__VA_ARGS__); \	//注意platform_driver_register只有一个参数,__VA_ARGS__不用管
	} \
	module_init(__driver##_init); \
	static void __exit __driver##_exit(void) \
	{ \
		__unregister(&(__driver) , ##__VA_ARGS__); \		//注意platform_driver_unregister只有一个参数,__VA_ARGS__不用管
	} \
	module_exit(__driver##_exit);
然后修改:!!
	atmel-hlcdc.c 加
	#include <linux/kernel.h>	//包含 printk.h
	static int __init atmel_hlcdc_driver_init(void) 
	{
		pr_debug("atmel-hlcd platform-driver registered !!")	//添加打印项!!
		return platform_driver_register(&atmel_hlcdc_driver);	
	}
	module_init(atmel_hlcdc_driver_init);
	static void __exit atmel_hlcdc_driver_exit(void)
	{
		platform_driver_unregister(&atmel_hlcdc_driver);
	}
	module_exit(atmel_hlcdc_driver_exit);
	
	drivers/mfd/Ｍakefile加入:
	ccflags-y  := -DDEBUG		//相当于给mfd目录下的所有文件都加上了 (#define DEBUG)
	经测试成功启动打印!!

然后开启 hlcd 的 dts !!!
	atmel-hlcdc.c 添加
	static int atmel_hlcdc_probe(struct platform_device *pdev)
	{	
	....
		//by william
		pr_debug("atmel-hlcdc probe start !!\n ")	//添加probe打印项!!
		....
	at91-sama5d4_xplained.dts添加:
		...
		ahb {
			apb {
				hlcdc: hlcdc@f0000000 {
					status = "okay";
				};
			.....
	编译dtb!! (直接使用make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- -j8 编译内核命令就可以自动更新stb了!!)
	只刷新 zImage + dtb 成功打印,即成功添加 hlcdc 的 platform_device!!

再给 atmel_hlcdc_dc 加入 pr_debug
	atmel-hlcdc_dc.c 加
	#include <linux/kernel.h>	//包含 printk.h
	static int atmel_hlcdc_dc_drm_probe(struct platform_device *pdev)
	{
		//by william
		pr_debug("atmel-hlcdc-dc probe start !!\n");
		.......
	drivers/gpu/Makefile加入:	//失败操作
	ccflags-y  := -DDEBUG		//相当于给gpu目录下(不包括多级子目录下的文件)的所有文件都加上了 (#define DEBUG) 
					//所以这样并没有成功添加 pr_debug()
	drivers/gpu/drm/atmel-hlcdc/Makefile加入:	//正确操作
	ccflags-y  := -DDEBUG				//相当于给atmel-hlcdc目录下的所有文件都加上了 (#define DEBUG) 
	经测试成功启动打印!!	
				
分析 atmel-hlcdc_probe!!
	atmel_hlcdc 是一个mfd设备(复合设备),包含atmel-hlcdc-dc设备, 和pwm-atmel-hlcdc设备!!
	重点结构体:
	static const struct mfd_cell atmel_hlcdc_cells[] = {
		{
			.name = "atmel-hlcdc-pwm",
			.of_compatible = "atmel,hlcdc-pwm",
		},
		{
			.name = "atmel-hlcdc-dc",
			.of_compatible = "atmel,hlcdc-display-controller",
		},
	};
	struct atmel_hlcdc_regmap {
		void __iomem *regs;
	};
	struct atmel_hlcdc {
		struct regmap *regmap;
		struct clk *periph_clk;
		struct clk *sys_clk;
		struct clk *slow_clk;
		int irq;
	};
atmel-hlcdc_probe 流程:
	分配一个 struct atmel_hlcdc_regmap 空间内存 *hregmap	//devm_kzalloc
	分配一个 struct atmel_hlcdc 空间内存 *hlcdc
	初始化 atmel_hlcdc:
		获取resource,然后把得到指针给 hregmap->regs
			(补充:platform_get_resource(pdev, IORESOURCE_MEM, 0); IORESOURCE_MEM表示获取的就是dt节点node 的reg内容)
		获取中断号
		在操作clock前,先获取对应的 struct clk 指针:	//devm_clk_get
			periph_clk,
			sys_clk,
			slow_clk,
		初始化 atmel-hlcdc_regmap,返回指针		//devm_regmap_init
	把 atmel_hlcdc 这个数据的指针 挂入 dev->driver_data	//dev_set_drvdata, 
								//注意旧版kernel是挂入private_data的,4.1 kernel 的 struct device 变化了.
	hlcdc是一个复合设备,所以,接下来初始化子设备:		//mfd_add_devices -> mfd_add_device
		就是根据当前 struct mfd_cell 即atmel_hlcdc_cells[] 初始化 子设备的platform_device结构,
		然后通过 platform_device_add 注册到 platform_bus !!

注册了子设备atmel-hlcd-dc(display-control)的platform_device到platform_bus,自然就要执行对应的probe!!,分析:
	知识补充:	
	drm 是一个 GPU 显示框架!!,在内核级别提供内存管理，中断处理， DMA控; 为应用程序提供统一的操作接口
	重点结构体:
	static struct drm_driver atmel_hlcdc_dc_driver = {
		.driver_features = DRIVER_HAVE_IRQ | DRIVER_GEM |
				   DRIVER_MODESET | DRIVER_PRIME |
				   DRIVER_ATOMIC,
		.preclose = atmel_hlcdc_dc_preclose,
		.lastclose = atmel_hlcdc_dc_lastclose,
		.irq_handler = atmel_hlcdc_dc_irq_handler,
		.irq_preinstall = atmel_hlcdc_dc_irq_uninstall,
		.irq_postinstall = atmel_hlcdc_dc_irq_postinstall,
		.irq_uninstall = atmel_hlcdc_dc_irq_uninstall,
		.get_vblank_counter = drm_vblank_count,
		.enable_vblank = atmel_hlcdc_dc_enable_vblank,
		.disable_vblank = atmel_hlcdc_dc_disable_vblank,
		.gem_free_object = drm_gem_cma_free_object,
		.gem_vm_ops = &drm_gem_cma_vm_ops,
		.prime_handle_to_fd = drm_gem_prime_handle_to_fd,
		.prime_fd_to_handle = drm_gem_prime_fd_to_handle,
		.gem_prime_import = drm_gem_prime_import,
		.gem_prime_export = drm_gem_prime_export,
		.gem_prime_get_sg_table = drm_gem_cma_prime_get_sg_table,
		.gem_prime_import_sg_table = drm_gem_cma_prime_import_sg_table,
		.gem_prime_vmap = drm_gem_cma_prime_vmap,
		.gem_prime_vunmap = drm_gem_cma_prime_vunmap,
		.gem_prime_mmap = drm_gem_cma_prime_mmap,
		.dumb_create = drm_gem_cma_dumb_create,
		.dumb_map_offset = drm_gem_cma_dumb_map_offset,
		.dumb_destroy = drm_gem_dumb_destroy,
		.ioctls	= atmel_ioctls,
		.num_ioctls= ARRAY_SIZE(atmel_ioctls),
		.fops = &fops,
		.name = "atmel-hlcdc",
		.desc = "Atmel HLCD Controller DRM",
		.date = "20141504",
		.major = 1,
		.minor = 0,
	};
	struct drm_device {
		....
		struct device *dev;
		char *unique;				/**< unique name of the device */
		/*
		 * At load time, disabling the vblank interrupt won't be allowed since
		 * old clients may not call the modeset ioctl and therefore misbehave.
		 * Once the modeset ioctl *has* been called though, we can safely
		 * disable them when unused.
		 */
		bool vblank_disable_allowed;
		/*
		 * If true, vblank interrupt will be disabled immediately when the
		 * refcount drops to zero, as opposed to via the vblank disable
		 * timer.
		 * This can be set to true it the hardware has a working vblank
		 * counter and the driver uses drm_vblank_on() and drm_vblank_off()
		 * appropriately.
		 */
		bool vblank_disable_immediate;
		/* array of size num_crtcs */
		struct drm_vblank_crtc *vblank;
		spinlock_t vblank_time_lock;    /**< Protects vblank count and time updates during vblank enable/disable */
		spinlock_t vbl_lock;
		u32 max_vblank_count;           /**< size of vblank counter register */
		/**
		 * List of events
		 */
		struct list_head vblank_event_list;
		spinlock_t event_lock;
		struct platform_device *platformdev; /**< Platform device struture */
		......
	};
	static const struct of_device_id atmel_hlcdc_of_match[] = {
		.........
		{
			.compatible = "atmel,sama5d4-hlcdc",
			.data = &atmel_hlcdc_dc_sama5d4,
		},
		{ /* sentinel */ },
	};
	static const struct atmel_hlcdc_dc_desc atmel_hlcdc_dc_sama5d4 = {
		.min_width = 0,
		.max_width = 2048,
		...//详细见 atmel_hlcdc_dc.c
	};
	struct device {
		struct device *parent;
		struct device_private *p;
		struct device_node of_node;	//解压 dtb 后,存储device tree 节点的数据结构!!!
		.....
	};
	struct device_node {			//解压 dtb 后,存储device tree 节点的数据结构!!!
		const char *name;
		const char *type;
		phandle phandle;
		const char *full_name;
		struct fwnode_handle fwnode;
		struct	property *properties;
		struct	property *deadprops;	/* removed properties */
		struct	device_node *parent;
		struct	device_node *child;
		struct	device_node *sibling;
		struct	kobject kobj;
		unsigned long _flags;
		void	*data;
	#if defined(CONFIG_SPARC)
		const char *path_component_name;
		unsigned int unique_id;
		struct of_irq_controller *irq_trans;
	#endif
	};
	struct atmel_hlcdc_dc {
		const struct atmel_hlcdc_dc_desc *desc;
		struct atmel_hlcdc *hlcdc;
		struct drm_fbdev_cma *fbdev;
		struct drm_crtc *crtc;
		struct atmel_hlcdc_planes *planes;
		struct atmel_hlcdc_layer *layers[ATMEL_HLCDC_MAX_LAYERS];
		struct workqueue_struct *wq;
		struct {
			wait_queue_head_t wait;
			bool pending;
		} commit;
	};
atmel-hlcdc-dc_probe 流程:			//atmel_hlcdc_dc_drm_probe
	分配一个 drm_device 空间内存 *ddev	//drm_dev_alloc
	初始化 ddev
		设置这个drm设备的唯一设备名		//drm_dev_set_unique
		加载初始化 atmel-hlcdc-dc 到ddev	//atmel_hlcd_dc_load (包括了atmel-hlcdc-dc的platform_device注册?)
		注册ddev到 drm框架?		//drm_dev_register
		注册对应的用户空间接口到drm框架?	//atmel_hlcdc_dc_connector_plug_all -> drm_connector_register
atmel_hlcd_dc_load 分析!!!
	匹配 hlcdc 的 compatible (注意不是 hlcd_dc 的 compatible)!!
	分配一个 atmel_hlcd_dc 空间内存 *dc	//devm_kzalloc
	初始化 dc
		建立一个工作队列名为atmel-hlcdc-dc	//dc->wq = alloc_ordered_workqueue(...)
		初始化等待队列				//init_waitqueue_head()
		dc->desc = match->data;
		dc->hlcdc = dev_get_drvdata(dev->dev->parent);
		ddev->dev_private = dc;			//源码是dev->dev_private = dc;实际上dev对应上述分析的 ddev
		启动periph_clk				//clk_prepare-enable -> clk_enable( 奇怪是在不到clk_enable源码!!)
							//clk_enable 没个厂家都有自己的clk_enable,找不到at91架构的!!!
	启动 atmel_hlcd_dc 电源管理(PM)		//pm_runtime_enable
	drm_vblank初始化			//drm_vblank_init	vblank显示完前帧图案与开始显示下一帧团之间的中间过程!!
	设置 atmel_hlcd_dc			//atmel_hlcdc_dc_modeset_init (关于芯片硬件模块寄存器的初始化了???)
	重置 drm 模式 ???			//drm_mode_config_reset
	初始化 drm_irq ???			//drm_irq_install
	把驱动数据挂入ddev			//platform_set_drvdata
	初始化,使能 output polling???		//drm_kms_helper_poll_init	窗口显示激活
	检测 是否发现热插拔设备???			//drm_helper_hpd_irq_event		
	(未完待续,下一天的开发log讨论!!>>>) 	










20161223
先补充 linux drm(direct rending manager) 设备的框架知识!!
	过去.用户程旭,直接操显卡设备来显示图像,这样,用户程序含大量针对特定显卡的接口程序,不利于移植,
	现在,linux建议使用自身提供的 抽象出的 drm设备驱动 来做访问操作显卡的工作,而drm面向用户程序则提供统一的ioctl接口, 
		这样,就更方便用户程序的移植,也对各种厂商的显卡操作有统一的管理
	DRM提供两类 ioctl 行为:GEM(Graphics Execution Manager),KMS(Kernel Mode-Setting)
	GEM针对 Framebuffer(显存)管理,
		如显存的申请释放 (Framebuffer managing)，显存共享机制 (Memory sharing objects)，及显存同步机制 (Memory synchronization)
	KMS 主要是完成显卡配置 (Display mode setting)
	atmel-hlcdc文件中,哪些对应KMS, 哪些对应GEM?
		atmel_hlcdc_crtc.c atmel_hlcdc_dc.c atmel_hlcdc_layer.c atmel_hlcdc_output.c atmel_hlcdc_plane.c
	显卡主要是由三类设备组成：
		Processing logic 指的是神秘的 GPU 模块，
		Display controller 指的是 LCDC 控制器，
		Hardware video acceleration 指的就是具体的显示接口 HDMI / eDP / … 
	DRM KMS 对于显卡设备驱动有三个概念 CRTC / Encoder / Connector,
		CRTC 就是指 Display Controller,CRTC 的常用行为如下：
      			DPMS (Display Power Manage System) 电源状态管理 (crtc_funcs->dpms)
			将 Framebuffer 转换成标准的 LCDC Timing ，其实就是一帧图像刷新的过程（crtc_funs->mode_set）
			帧切换，即在 VBlank 消影期间，切换 Framebuffer（crtc_funcs->page_flip）
			Gamma 校正值调整（crtc_funcs->gamma_set）
		Encoder 就是指具体接口驱动 eDP / HDMI,Encoder 的常用行为如下：
			DPMS (Display Power Manage System) 电源状态管理 (encoder_funcs->dpms)
			将 VOP 输出的 lcdc Timing 打包转化为对应接口时序 HDMI TMDS / … (encoder_funcs->mode_set)
		Connector 指的是具体外接的屏幕 Monitor / Panel。Connector 的常用行为如下：
			获取上报 热拔插 Hotplug 状态
			读取并解析屏 (Panel) 的 EDID 信息
	drm 其他概念:
		pagefilp:帧刷屏
		plane:	(drm 的plane相当与,芯片上的图层,plane是drm软件架构上的图层,具有广泛意义!!,overlay是芯片硬件上的图层,)
			(由于实现的功能类似,所以这里的 plane 一般直接映射 硬件的overlay )
			(所以可以说,plane 是 芯片layer 与 linux-drm模块 的接口)
			A plane represents an image source that can be blended with 
			or overlayed on top of a CRTC during the scanout process
		CRTC:	A CRTC is an abstraction representing a part of the chip that contains a pointer to a scanout buffer
	简单以 HDMI Monitor 显示的过程为例，实例解析下 CRTC / Encoder / Connector 的行为：
		1. 首先 HDMI 驱动检测到电视 Plugin 信号，读出电视的 EDID 信号，获取电视的分辨率信息 (DRM Connector)。
		2. Userspace 将需要显示的数据填充在 framebuffer 里面，然后通过 libdrm 接口通知 VOP 设备开始显示。
		3. 接着 VOP 驱动将 framebuffer 里面的数据转换成标准的 LCDC Timing 时序 (DRM CRTC)。
		4. 同时 HDMI 驱动将 HDMI 硬件模块的 LCDC 时序配置与 VOP 输出时序一致，
		   准备将输入的 LCDC Timing 转化为电视识别的 HDMI TMDS 信号 (DRM Encoder)。
补充 linux runtime PM 框架知识!!
	(未完)
补充 sama5d4 lcdc 框架知识!!
	datasheet:page668 寄存器列表
	datasheet:page633表示:
		图像数据通过 DEAG: DMA Engine Address Generation 流入 各layer图层
		各layer图层再经过 GAB: Global Alpha Blender 混合成图片,
		然后通过硬件时序模块输出如rgb信号到lcd屏从而成像!!!
	The LCD module integrates the following digital blocks:(基本重点模块简介)
		DMA Engine Address Generation (DEAG)—This block performs data prefetch and requests access to the AHB interface.
		Input Overlay FIFO—Stores the stream of pixels
		Color Lookup Table (CLUT)—These 256 RAM-based lookup table entries are selected 
		 	when the color depth is set to 1, 2, 4 or 8 bpp.
		Chroma Upsampling Engine (CUE)—This block is selected when the input image sampling format is YUV (Y’CbCr) 4:2:0 
			and converts it to higher quality 4:4:4 image.
		Color Space Conversion (CSC)—changes the color space from YUV to RGB
		Two Dimension Scaler (2DSC)—Resizes the image
		Global Alpha Blender (GAB)—Performs programmable 256-level alpha blending
		Output FIFO—Stores the blended pixel prior to display
		LCD Timing Engine—Provides a fully programmable HSYNC-VSYNC interface
	The DMA controller reads the image through the AHB master interface. The LCD controller engine formats the
		display data, then the GAB performs alpha blending if required, and writes the final pixel into the output FIFO. The
		programmable timing engine drives a valid pixel onto the LCD_DAT[23:0] display bus.
	Input FIFO:	the LCD module includes one input FIFO per overlay. These input FIFOs are used to buffer the AHB burst and
		serialize the stream of pixels.
	Output FIFO:	The LCD module includes one output FIFO that stores the blended pixel.
	
	layer(图层),有如下几层: 
		overlay1(覆盖层1,即图层1)
		overlay2(覆盖层2,即图层2)
		base layer(基础层)
		high end Overlay(高端图层)
		每个图层都可以选择存放color lookup table 或者 RGB 编码的像素点pix图像
		而高端图层更可以选择 yuv 编码的像素点的图像
	GAB: Global Alpha Blender(alpha搅拌器,即图层混合器)
紧接之前分析:atmel_hlcd_dc_load 里对硬件的初始化应该集中在 atmel_hlcdc_dc_modeset_init:
	设置 drm 相关参数?		//drm_mode_config_init
		INIT_LIST_HEAD(&dev->mode_config.fb_list);
		INIT_LIST_HEAD(&dev->mode_config.crtc_list);
		INIT_LIST_HEAD(&dev->mode_config.connector_list);
		INIT_LIST_HEAD(&dev->mode_config.encoder_list);
		INIT_LIST_HEAD(&dev->mode_config.property_list);
		INIT_LIST_HEAD(&dev->mode_config.property_blob_list);
		INIT_LIST_HEAD(&dev->mode_config.plane_list);
		idr_init(&dev->mode_config.crtc_idr);
		idr_init(&dev->mode_config.tile_idr);
	建立 outputs 设备??		//atmel_hlcdc_create_outputs(其实就是发现hlcd-display-controler的子设备节点 port 接口,并初始化!!)
	建立 planes ??			//atmel_hlcdc_create_planes
		设置layer
	建立 crtc ??			//atmel_hlcdc_crtc_create
	设置 mode_config_funcs		//ddev->mode_config.funcs = &mode_config_funcs;
		static const struct drm_mode_config_funcs mode_config_funcs = {
			.fb_create = atmel_hlcdc_fb_create,
			.output_poll_changed = atmel_hlcdc_fb_output_poll_changed,
			.atomic_check = drm_atomic_helper_check,
			.atomic_commit = atmel_hlcdc_dc_atomic_commit,
		};
快速查找出错处!! 对比输出错误码ret 与 errno.h里的数据
怀疑 hdmi 与 drm 有关系,于是查看了资料,发现:
	sama5d4并没有hdmi模块,而是通过外接 sil9022 芯片 把 rgb777 信号转为 hdmi信号输出,而sil9022也是通过i2c与sama5d4通讯
	也就是说,hdmi不是芯片自己实现的,还是需要类型\cd信号输出然后通过转换芯片转换
所以参考hdmi的dts,试写lcd信号的设备树信息
	出现错误!! failed to create HLCDC outputs: -517
	加 pr_debug 和对比 hdmi_dts发现是hdmi_dts的 of_drm_find_bridge 正确输出!! 











20161226
补充:裸屏参数!!
	800 X 480 pixel
	108(H) X 64.8(V) mm
	each pixel: 0.135(H) x 0.135(V) mm
	DotCLK: 33.36MHZ
	FRAME frequency: 60 hz
	lcd_power: 3.3V	  110mA   363mW
	backlight: 23.1V  40ma	  924mW 
继续挖掘 DRM 有用信息!!!

继承试写 lcd dts节点 ,
	发现,之前atmel_create_uotputs失败,是因为 atmel_hlcdc_check_endpoint失败!!,然而换作预装hdmi的dts时,却成功!!
	原来hdmi的dts里 的 sil9022节点模块,使用了 drm_bridge_add(),所以 atmel_hlcdc_check_endpoint->of_drm_find_bridge 正确输出 
	所所谓的 bridge 可以理解为 drm 的 encoder 
	不使用 sil9022模块的我们应该如何修改 ??
	从 check_endpoint 看到了,除了 bridge 匹配的方式外,还有 panel 匹配方式, 
	查看代码,发现drm/panel被编译了,也就说,可以尝试在这里添加 信息,用于匹配!!
先pannel 添加 pr_debug:
	panel/Makefile: 添加 ccflags-y := -DDEBUG
	panel-simple.c 添加:
	#include <linux/kernel.h>
	然后就可以在要检测的地方加pr_debug
再次改写dts!!
	panel-simple.c 添加:
	static const struct drm_display_mode atmel_lcd_display_control_mode = {
		.clock = 33260,
		.hdisplay = 800,
		.hsync_start = 800 + 168,
		.hsync_end = 800 + 168 + 64,
		.htotal= 800 + 168 + 64 + 88,
		.vdisplay = 480,
		.vsync_start = 480 + 37,
		.vsync_end = 480 + 37 + 2,
		.vtotal = 480 + 37 + 2 + 8,
		.vrefresh = 60,
	};
	
	static const struct panel_desc atmel_lcd_display_control = {
		.modes = &atmel_lcd_display_control_mode,
		.num_modes = 1,
		.bpc = 8,
		.size = {
			.width = 108,
			.height = 65,
		},
		.bus_format = MEDIA_BUS_FMT_RGB888_1X24,
	};

	static const struct of_device_id platform_of_match[] = {
		...
		{
		//by william
		.compatible = "atmel,lcd-display-control",
		.data = &atmel_lcd_display_control,
		},
		...
	}
	dts添加: (参考sama5d3xdm.dtsi)
	/{
		........
		ahb {
			apb {
				hlcdc: hlcdc@f0000000 {
					status = "okay";
	
					hlcdc-display-controller {
						pinctrl-names = "default";
						pinctrl-0 = <&pinctrl_lcd_base &pinctrl_lcd_rgb888>;
	
						port@0 {
							hlcdc_panel_output: endpoint@0 {
								reg = <0>;
								remote-endpoint = <&panel_input>;
							};
						};
					};
				};
				........
			};
			......
		};
			....
		backlight: backlight {
			compatible = "pwm-backlight";
			pwms = <&hlcdc_pwm 0 50000 0>;
			brightness-levels = <0 4 8 16 32 64 128 255>;
			default-brightness-level = <6>;
			power-supply = <&bl_reg>;
			status = "okay";
		};
	
		bl_reg: backlight_regulator {
			compatible = "regulator-fixed";
			regulator-name = "backlight-power-supply";
			regulator-min-microvolt = <5000000>;
			regulator-max-microvolt = <5000000>;
			status = "okay";
		};
	
		panel: panel {
			compatible = "atmel,lcd-display-control", "simple-panel";
			backlight = <&backlight>;
			power-supply = <&panel_reg>;
			#address-cells = <1>;
			#size-cells = <0>;
			status = "okay";
	
			port@0 {
				#address-cells = <1>;
				#size-cells = <0>;
	
				panel_input: endpoint@0 {
					reg = <0>;
					remote-endpoint = <&hlcdc_panel_output>;
				};
			};
		};
	
		panel_reg: panel_regulator {
			compatible = "regulator-fixed";
			regulator-name = "panel-power-supply";
			regulator-min-microvolt = <3300000>;
			regulator-max-microvolt = <3300000>;
			status = "okay";
		};
	};	
	成功跳过错误,并 DRM device successfully registered  
	但未接屏幕测试.
	发生了一次奇怪现象: panel-simple-probe 独立执行了两次!!!执行了两次atmel-hlcdc-dc_probe!!独立执行了三次
	多次调用直到把功能初始化了的机制是什么?
	为什么,第一次 panel-simple-probe 会运行到一般断掉后面也没有恢复,而下一次却重新panel-simple-probe却完整执行??
	没有时钟信号输出 !!
搭建tftp服务器,以便于日后往开发板烧录测试文件!!
	1.安装tftp的服务端和客户端：
		sudo apt-get install tftpd-hpa ；安装tftp服务端
		sudo apt-get install tftp-hpa   ；安装tftp客户端
	2.安装xinetd:	sudo apt-get install xinetd：支持对tcp、udp、RPC服务的东东
	3.mkdir ~/tftpboot
		释放权限：sudo chmod 777 ~/tftpboot
	4.配置TFTP服务器,编辑tftpd-hpa：	sudo gedit /etc/default/tftpd-hpa
	# /etc/default/tftpd-hpa
	TFTP_USERNAME="tftp"
	TFTP_DIRECTORY="/home/infortech-ubuntu-1404/tftpboot"
	TFTP_ADDRESS="0.0.0.0:69"
	TFTP_OPTIONS="--secure"
	5.重启xinetd服务:	sudo /etc/init.d/xinetd restart
	6.重启tftpd服务:	sudo /etc/init.d/tftpd-hpa restart
开发板tftp命令:
	tftp -gl 文件名 服务器ip	(tftp -gl text.txt 192.168.105.117)	//下载文件到开发板!!











20161227
昨日添加了panel后初始化驱动成功,但是示波器检测排口发现没有输出!!
	开了 bootup_logo 测试输出,发现没有输出!!
	网上发现还要开framebuffer console !! 开后 lcd排针有输出
	修改 panel-simple.c 的帧参数,发现相应改变了 vs hs clk 的输出频率,但是,并没有完全适配等同panel上设置的参数!!!!!!
测试fb设备功能!!!编写一个简单的显示程序!!!
	ubuntu jpg 转换 bmp :
		sudo apt-get install Imagemagick
		convert filename.jpg filename.bmp	//简单转换
		如果你使用JPEG等大小和图片质量有关的图形格式化，可以使用-quality参数。参数的数值在0至100之间，数值越大文件越大，
		通常情况下，60-80就可以了，譬如：convert -quality 80 filename.bmp filename.jpg
workqueue学习:
	关于workqueue 与 per-cpu的worker thread 的关系!!! (面向多核多线程的芯片,即多cpu芯片)
	struct workqueue_struct {
	    struct cpu_workqueue_struct *cpu_wq; －－－－－per-cpu work queue struct
	    struct list_head list; －－－workqueue list
	    const char *name;
	    int singlethread; －－－－single thread or multi thread
	    int freezeable;  －－－－和电源管理相关的一个flag
	}; 
	    struct cpu_workqueue_struct {
	
	        spinlock_t lock; －－－－用来保护worklist资源的访问
	
	        struct list_head worklist;
	        wait_queue_head_t more_work; －－－－－等待队列头
	        struct work_struct *current_work; －－－－当前正在处理的work
	
	        struct workqueue_struct *wq; －－－－－－指向work queue struct
	        struct task_struct *thread; －－－－－－－worker thread task
	
	        int run_depth;        /* Detect run_workqueue() recursion depth */
	    } ____cacheline_aligned;
	假如用户创建了一个 workqueue 就有一个 workqueue_struct !!
		workqueue_struct 里有一个 struct cpu_workqueue_struct 指针,
		这个指针应该是指向 一个 struct cpu_workqueue_struct[] 队列的,(per cpu分配的)
		每个struct cpu_workqueue_struct[] 队列成员面向对应的cpu,对应的worker thread,也只能被指定的cpu访问!! 
	一般而言，当创建一个workqueue的时候会为每一个系统内的processor创建一个内核线程，该线程处理本cpu调度的work。
	每个挂入workqueue的work都据实际情况在哪一个cpu上被调度，就挂入哪一个worker thread(即某个struct cpu_workqueue_struct队列成员)
	调度work执行有两个接口，
		一个是schedule_work，将work挂入系统默认workqueue（keventd_wq），
		另外一个是queue_work，可以将work挂入指定的workqueue
	到底插入workqueue的哪一个worker thread呢？这是由wq_per_cpu定义的：
		static struct cpu_workqueue_struct *wq_per_cpu(struct workqueue_struct *wq, int cpu)
		{
 	       	if (unlikely(is_single_threaded(wq)))
        		    cpu = singlethread_cpu;
        		return per_cpu_ptr(wq->cpu_wq, cpu);
		}
		普通情况下，都是根据当前的cpu id，通过per_cpu_ptr获取cpu_workqueue_struct的数据结构，对于single thread而言，cpu是固定的。 
	不管是否是single thread workqueue，worker thread（cpu_workqueue_struct）的数据结构总是per cpu分配的（稍显浪费），
		不过实际上对于single thread workqueue而言，
		只会使用其中的一个cpu,(其中的一个worker thread,其中的一个struct cpu_workqueue_struct[] 队列成员)
Concurrency Managed Workqueue 与 旧的workqueue 比较
	接口API
		1、初始化work的接口保持不变，可以静态或者动态创建work。
		2、调度work执行也保持和旧的workqueue一致。
		3、创建workqueue。和旧的create_workqueue接口不同，CMWQ采用了alloc_workqueue这样的接口符号，	
	旧:
		用户每建立一个 新workqueue 都会马上为每个cpu都新建一个新的work thread 线程
		所以每个workqueue 都有一组work thread,( 一个struct cpu_workqueue_struct[] 队列)
		并发处理问题:
			a,b,c,d四个work 挂到同一个workqueue的同一个cpu里(同一个work thread 线程),
			四个work只能排队串行执行
	Concurrency Managed:
		workqueue 与work_thread 概念分开!!
		用户每建立一个 新workqueue 不会为每个cpu都新建一个新的work thread 线程
		但是 引入了woeker pool 概念,worker pool 独立于workqueue
		每个cpu都只有一个 worker pool,
		每个加入到 workqueue 的 work,都会动态随机第地挂入 其中一个worker pool ,work只是与workqueue有联系
		但是work到底安排到 那条线程里执行是不是分配一条新的线程执行,什么时候执行,由worker pool 自己执行决定!!
		解决并发问题:
			a,b,c,d四个work 挂到同一个workqueue的同一个cpu里(同一个worker pool),
			四个work可行执行,
			例如,a运行过程中遇到阻塞,woker pool可以另外生成一条新线程执行b,c,d
			b遇阻塞时,同理另外建新线程执行c,d
grep 使用技巧:
	grep “字符串” *            如果要搜索的目录下没有目录的话，完全不用加参数
	grep -r “字符串” *        如果有目录，-r可以递归搜索，好像-R也可以，而且man手册还区分了，可能在符号链接上有什么区别，但是没有试验过
	grep -i “字符串” *        忽略字符串中的大小写
	grep -n "字符串" *       列出字符串所在文件的行号，结合vim 文件 +行号 打开文件很有用
	在grep实际使用中，可能还会结合转义字符\，比如带“->“的，就需要搜索时加转义”\->“不然搜不到的。反正有时候搜索带通用匹配符而又搜不到结果时， 
	例子:grep -rin "samsung" 
find命令:	
	find . | grep "vt.c"	//列出文件名含 vt.c 字符 文件路径 
终端中的复制/粘贴: Shift+Ctrl+C:复制 Shift+Ctrl+V:粘贴











20161228
昨日打开了framebuffer console 后信号针有输出,意味着应该能够看到bootup_logo
	昨日编译的zImage配上官方hdmi.dtb 接入大电视,过看到图片和图标,
	今天的lcd转接板也能正常工作!!!但偏暗!!! 开发板供电不足够? 开发板backlight 电路有问题?
网上下载显示bmp软件的用户程序,成功编译,输出信号!! 没有显示企鹅logo???
此外 lcd 过一段时间会自动熄灭,但是插入 鼠标键盘触发后,又重新显示!!
在 uboot 的默认 bootargs 里添加 console=tty0, 重刷uboot 有部分开机启动信息在lcd屏上输出!!!
依然没有显示 bootup logo !!!
屏幕 算作 成功显示!! 下一步,启动触摸模块!!!!
芯片adc知识,使用四线touchscreen模式!!
	ADC AD0/XP PC27 X1
	ADC AD1/XM PC28 X1
	ADC AD2/YP PC29 X1
	ADC AD3/YM PC30 X1  
初学 linux clock 子系统:
	系统启动过程中，什么时候开始有tick？
		多核系统，BSP首先启动，在其初始化过程中会调用time_init，这里会启动clocksource的初始化过程。
		这时候，周期性的tick就会开始了。在某个阶段，其他的processor会启动，然后会注册其自己的local timer，
		这样，各个cpu上的tick就都启动了。 
	所谓per cpu就是说每个cpu都会维护属于一个自己的对象。例如，对于tick device，每个CPU都会维护自己的tick device













20161229
启动adc-touchscreen
	有两个文件:at91_adc.c,和atmel-sama5d2_adc.c
	at91_adc.c针对通用芯片, atmel-sama5d2_adc.c只针对sama5d2这一款芯片
	sama5d4 使用 at91_adc.c
按dts指导txt修改dts,貌似成功初始化了触摸屏,但是:
	使用测试程序时,貌似 阻塞在读函数
	点击触摸屏什么也没发生!!!
	发现,触摸屏只对应逻辑设备文件是 /dev/input/touchscreen0
		因为打开 touchscreen0 时会调用: atmel_ts_open()
	发现重点:struct at91_adc_caps->has_tsmr //only at91sam9x5,sama5d3 有 TSMR reg 
		看datasheet: sama5d4 有!!!  
	还有一个关于pen的问题!!!未解决
恶补 input 设备 iio 设备 !!! 
	cat /dev/input/event1 | hexdump   //测试input设备命令  例如鼠标, 滑动就能有数据!!
	怀疑 input 逻辑设备文件 与 iio逻辑设备文件根本是两回事 read_raw 只给iio设备逻辑文件使用,而不是给input文件的
	看datasheet tsmr是touchscreen mode register 
		TSMOD四模式:非触摸屏模式,4线模式,4线带笔触压力模式,5线模式!!
		TSAV转换值获取4式: 1次转换取值, 2次转换取平均值,4次转换取平均值,8次转换取平均值
	Trigger Period: 前后两次转换间的最小间隔时间,一定要大于转换工作所用的时间!!
	Threshold: (比较用的)临界值,阀值.
	• EOCx: End of Conversion Interrupt Mask x
	• XRDY: Touchscreen Measure XPOS Ready Interrupt Mask
	• YRDY: Touchscreen Measure YPOS Ready Interrupt Mask
	ADC_LCDR: 存储最新一次得到的转换值及对应的通道
		adc-dma:的做法:(估计)测量得到一堆数据,然后这堆数据存到一个DMA-buffer,用户从ADC_LCDR寄存器入口取出这些数据
		每取出一个,buffer里就丢弃一个
	简单说sama5d4,可直接硬件把4adc电压值 转换成一个x坐标和y坐标值!!
	




20161230
先做一个小 input 驱动来
	设置外部中断 即设置gpio针 
	drivers/pinctrl/pinctrl-at91.c
	设置个gpio针!!
		根据dts pinctrl@ compatable 得知 使用 at91sam9x5_ops 设置!!!
	设置函数还不能随便调用,要通过设置dts来设备io口
第一步:做一个linux 模块,测试挂入系统功能,注意makefile编写,详见 /home/kingders/SAMA5D4/sources/driver_test/button
	测试命令:	tftp -gl button.ko 192.168.1.100
			insmod button.ko	//加载
			rmmod butto		//卸载
	成功!
第二步,修改pe8gpio脚, 上升下降沿触发中断!!
	readl_relaxed(reg)		//直接读取硬件寄存器reg地址内容!!
	writel_relaxed(value, reg);	//把内容value,写入硬件寄存器地址!!
	官方说明这样配置中断gpio的irq!!(可是已经没有这个函数了,玩野!!)	
	at91_set_gpio_input()then maybe enable its glitch filter
	request_irq()
	pioE的中断号是 26 !!
	似乎中断好是错的!!! linux里26不对应pioe 
	kernel里
		23对应 at91_tick
		26对应 aic5_set???
		52对应 ???		
		25对应 ehci_hcd:usb1
		41对应 aic5_set_type??
		44 refer atmel-sha
		明显,request 绑定irq也是有自己的一套规则的 起码中断号与芯片的硬件中断号不一致
		要恶补linux 的中断设置!!包括芯片和kernel的内容!!
回望adctouchscreen驱动
	初步认为,input设备是不提供read接口的,使用自身独有的read接口!!
		之所以read阻塞,极有可能是驱动逻辑设备文件里还没有数据!!adc转换中断没有真正开了!!
	读出注册中断处理程序request的前一刻 用到的 st->irq 号 居然是41!! 不是44!!
		乱改request里的 st->irq 号 为51 居然成功注册,启动且意外执行了中断处理程序
		dts的adc interrupt 号怎么改,最终 st->irq 还是41
		dts的adc interrupt 注释掉有提示irq初始化出去错!!
ubuntu使用sourceinsight:
	wine /home/kingders/smart210/tools/source_insight/SourceInsight/Insight3.exe 








20170103
geditor打不开文件时:(取消编码检测)
	gsettings set org.gnome.gedit.preferences.encodings auto-detected "['UTF-8', 'CURRENT', 'ISO-8859-15', 'UTF-16']"
重新解决中断问题!!
	request 使用IRQF_SHARED 后成功注册,但按键没有反应!!!
	怀疑是硬件中断号与linuxh中断号的转换问题!!
	查看中断是否产生,命令 
	# cat /proc/interrupts
		linux中断号  触发次数`类型??		??	触发		中断名字 
		186:         48      GPIO		8	Edge     	pb_user1	//原生加入的!!
		 26:          0      atmel-aic5		67 	Level     	button1		//自己刷入的!!1
		 41:          0	     atmel-aic5  	59 	Level     	at91_adc	//触摸对应的中断模块!!
	发现了 原来按键中断已经加入!!!
	按键后,源码自己触发次数成双增加,及上升下降沿都触发
	更改自己按键模块设置关闭pe8的寄存器操作,原生加入的中断将不再工作,证明自己操作寄存器的操作没有出错!!
	还有,发现触摸屏对应的adc中断模块未曾触发过!!
下一步分析原生按键的初始化过程:
	原来 event1 对应的是 pe8 的用户按键!!!
	cat /dev/input/event1 | hexdump	
	一些重点drivers/input/keyboard/gpio_keys.c	
		gpio_keys_resume() //虽然有向input/event1文件report数据,但不是中断处理函数!!
		注册了的中断处理bottom_half程序(在workqueue里的)是 gpio_keys_gpio_work_func()
	从gpio_keys_probe剖析一个platform_device/driver从dts_node里取出dts数据初始化驱动的过程!!
		对应dts_node:
		gpio_keys {
			compatible = "gpio-keys";
	
			pinctrl-names = "default";
			pinctrl-0 = <&pinctrl_key_gpio>;
	
			pb_user1 {
				label = "pb_user1";	//关于 gpio_keys_button -> const char *desc;
				gpios = <&pioE 8 GPIO_ACTIVE_HIGH>;
				linux,code = <0x100>;	//关于 input event code (KEY_*, SW_*
				gpio-key,wakeup;
			};
		};
		重要的数据结构:
		struct gpio_keys_button {
			/* Configuration parameters */
			unsigned int code;	/* input event code (KEY_*, SW_*) */
			int gpio;		/* -1 if this key does not support gpio */
			int active_low;
			const char *desc;	
			unsigned int type;	/* input event type (EV_KEY, EV_SW, EV_ABS) */
			int wakeup;		/* configure the button as a wake-up source */
			int debounce_interval;	/* 去抖延时 */
			bool can_disable;
			int value;		/* axis value for EV_ABS */
			unsigned int irq;	/* Irq number in case of interrupt keys */
		};
		先分配一个空间存储平台设备数据
		pdata = gpio_keys_get_devtree_pdata(dev);	//从dts取出platdate
			dev->of_node 指的就是gpio_keys 这个node
			nbuttons = of_get_child_count(node);	//得到子node的数目,这里就只有 pb_user1 这个按键
			子节点的内容终要变成规范的设备数据
			//分配数据空间给平台设备数据 
			pdata = kzalloc(sizeof(*pdata) + nbuttons * (sizeof (*struct gpio_keys_button)),GFP_KERNEL);
			pdata->buttons = (struct gpio_keys_button *)(pdata + 1);//按键数据在平台设备数据里的开始地址
			pdata->nbuttons = nbuttons;	//按键数目
			for_each_child_of_node(node, pp)//for循环的宏定义,比那是遍历直接点
				of_find_property(pp, "gpios", NULL)	//找到字节点 gpios 这个 property 
				重点!!!!!!是of_get_gpio_flags:
					struct device_node *np = pp, int index = 0, enum of_gpio_flags *flags = &flags
					const char *propname = "gpios"
					gpio = of_get_gpio_flags(pp, 0, &flags);
					->of_get_named_gpio_flags(pp, "gpios", 0, &flags);	//只是分析了dts里,按钮子节点的内容
						->ret = of_parse_phandle_with_args(np, propname, "#gpio-cells", index, &gg_data.gpiospec);
							const struct device_node *np = np, const char *list_name = "gpios":
							const char *cells_name = "#gpio-cells", int index = 0:
							struct of_phandle_args *out_args = &gg_data.gpiospec:
							应该是給 gg_data.gpiospec 初始化内容
						...	// 越来越混乱!!!
					//寻找对应芯片的的gpio模块,并转换成对应的linux设备数据内容 重点!!
					->gpiochip_find(&gg_data, of_gpiochip_find_and_xlate);
					找到了drivers/gpio/gpiolib.c 专们是at91的gpio模块

				...
		再分配一个空间存储平台设备驱动的数据空间
		然后把平台设备数据 和 input逻辑设备接口数据 的地址 挂入驱动数据里!!
		ddata = kzalloc(sizeof(struct gpio_keys_drvdata) + pdata->nbuttons * sizeof(struct gpio_button_data), GFP_KERNEL);
		ddata->pdata = pdata;
		ddata->input = input;	
		...
		然后重点之一,设置key: error = gpio_keys_setup_key(pdev, input, bdata, button);
		来到注册中断操作这个阶段,
		中断号的获取是通过探测得到:(重要 这里得到的中毒昂好是186)
			irq = gpio_to_irq(button->gpio);
		问题:知道linux_pE8的irq是186,但是,我自己编写时,直接写入186却有反应,
		而原声的,不通过gpio_to_irq,而是直接给予186,却通过!!,怀疑在gpio_to_irq之前存在一个中断号186生成和绑定过程,不能直接使用,
		而这个生成绑定过程不在 gpio_to_irq 里!!
		后面分析有发现 硬件中断号,与linux中断号已经绑定好,所以并不需要初始化时绑定,
		也就的说,可以直接使用对应中断号!!!呢么没有反应,应该是硬件初始化的问题!!
		果然 pull_up不能设置!!!设置pull_up还先清除设备可能设置了的pull_down
		完整代码见:
			/home/kingders/SAMA5D4/sources/driver_test/input_device/button :button.c







20170104
给button,c 套入input框架 注册成一个input设备!!!
	注意到,设置 keybit 不能乱来, 
		暂时只能设置为 BTN_0 设置其他会出错?例如,设KEY_1模块init阶段就执行了input设备的ops的open函数
		(但不科学啊,因为 KEY_1 也是默认值之一 )
		关于 keybit 的设定,可以查看: include/dt-bindings/input/input.h 或者 include/uapi/linux/input.h
	但是, 中断input_report_key函数似乎没有正常地把数据内容递交额 event1 设备逻辑文件!!
	cat /proc/bus/input/devices	//查看input设备属性数据
	按键 input驱动 基本完成,但是input_report 失败!!!
	最后手段,改input子系统源码 加入pr_debug!!










20170105
恶补input子系统知识:
	input 设备 是一个抽象出来的共性设备,可以看作是一个接口!!, 每一个输入类硬件设备初始化注册到linux时,
		都会另外注册一个虚拟的input设备,作为标准的接口与用户程序及其他驱动交互
	首先,kernel启动时会 注册 一个 input子系统 的主设备,为未来实际的input设备建立做好准备
	一些硬件设备驱动初始化时,注册到 input子系统 的次设备,实际就是建立了一个属于自己的 event字符设备, 
从一个按键驱动来分析!!! 	//详见 /home/kingders/SAMA5D4/sources/driver_test/input_device/button : inputdev0.c
	module_init初始化一个按键驱动的首先就是:	input_allocate_device 分配一个 struct input_dev 数据,得到这个数据的指针 *X
	然后初始话这个数据:
		X->name = "button"; 	//input子设备的名字
		X->phys = "william/PE8_button";		//物理途径???
		X->id.bustype = BUS_HOST;		//总线类型??
		X->dev.init_name = "input_key"; 	// /sys/devices/virtual/input/目录里这个设备的属性文件名
		X->keycodemax = KEY_NUM; 		//按键数目
	
		//自定义input,不要设置版本信息!!!
		//X->id.vendor = 0x0001;  
		//X->id.product = 0x0002;  
		//X->id.version = 0x0100; 
	
		// event事件类型 为 按键类型(EV_KEY)  
		set_bit(EV_KEY,X->evbit);	/*正确设法1*/
        	//X->evbit[BIT_WORD(EV_KEY)] = BIT_MASK(EV_KEY);/*正确设法2*/  
		//使用那一个编码的按键, 按国际标准,每一个键盘按键,鼠标事件,其他设备的功能广义按键都有一个唯一的ID (但是用code表示)
		//	例如 KEY_1 表示 键盘的数字 1 按键,有趣的是,后面注册设备时,如果检测到有键盘的按键编码时,认为插入了一个键盘,
		//					 注册时会自动执行 open 函数,因为键盘默认是插入注册到linux后便可以直接使用的
		//					 使用之前,当然要 open 设备, 所以就自动打开了设备
		//	     BTN_1 表示 广泛的通用的按键	1	
		//	     BTN_3 表示 广泛的通用的按键 3
		set_bit(BTN_3,X->keybit); /*正确设法1*/ 	//这里就是 设置按键ID为BTN_3
        	//X->keybit[BIT_WORD(BTN_3)] = BIT_MASK(BTN_3); /*正确设法2*/
		
		//初始化 key 值		这个对于不规范的按键驱动开发相当重要!!后面分析按钮问题分析到!!!
		set_bit(0,X->key);  
		//set_bit(BTN_3,key_dev->key);  
	
		X->open = PE8_open;  	//打开这个input次设备 (即是event逻辑设备文件),需要附加的私有的open函数,一般用于进一步硬件初始化
		key_dev->close = PE8_release;	//关闭这个input次设备, 需要附加用上的私有释放函数,释放占有的资源,硬件资源
 	然后就是往linux注册这个input子设备了:	input_register_device(X)
		然后就会自己自动建立自己的 eventx 逻辑设备文件到 /dev/input里了,
	打开 event 设备:
		首先我们使用的是 BTN_3 的一个通用按键的编码来标识 PE8 这个按键,所以input_register_device(X)时,不会误认为这是一个键盘硬件设备,
			只是一个通用的按钮硬件设备,所以,不会自动执行 open /dev/input/eventX 操作,
			所以第一步先打开 eventx 设备,打开操作经过通用的打开初始化操作后,最后会跑到 PE8_open 执行私有的硬件初始化!!
		PE8_open:	
			注册中断:
			首先:kernel启动时,已经生成了 硬件中断号 与 linux中断号irq.no 的对照表 
			//linux中断号irq.no:系统已经绑定给针 PE8 的中断号, 这里PE8 对应186
			//button_inter:中断处理函数, 
			//flags:IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING 表示上升下降沿触发中断,
			//button1:中断的名称, 
			//ID:中断号irq_desc里挂载关于这个中断的中断事件id号,从而区别使用同一个中断号里的各个中断事件(主要为共享中断服务,
			//	一般复用dev数据指针作为ID号)
			request_irq(key1.irq_no, button_inter, IRQF_TRIGGER_RISING, key1.name, (void *)(&key1)); //只有上升沿触发	
			//硬件初始化!!!
			hw_init();
		注意到:
			但是request 里, 我故意让只有山上升沿时才触发中断
			然后,硬件初始化里,我做的工作是当遇到 上升沿和下降沿时都会触发中断!!
			测试时发现,只有按下后抬起的时候才有中断时间发生(即上升沿才发生!! 因为按钮开路时接上拉电阻)
			两者都设置了中断触发条件,但却以request 的为准!!以软件设置为准,而不是硬件??当中有跟复杂的学问!!
	按下按钮后,触发 request 注册的 button_inter 中断处理函数:
		//repot函数!!辗转到input_event()事件	
		//X:这个按键时间对应的 struct input_dev 结构数据的指针
		//EV_KEY:表示,这个event事件为按键事件!!1
		//BTN_3:这个按键对应的编码ID , 
		//i:应该是规范的按键值才对,我就是这里出问题了!!!!	
		//这个函数就是往 event设备递交数据值的,然而实际上,提交的数据,一般暂存在自己的 struct input_dev 里的一个buffer
		//并不会马上投放到 /dev/input/deentx 对应的 逻辑设备文件里 
		//但当buffer数据满了以后,会自动投放到 /dev/input/deentx 对应的 逻辑设备文件里 
		input_report_key(X,BTN_3,i)
			->input_event(X, EV_KEY, BTN_3, i)
		//repot函数!!辗转到input_event()事件
		//这里不是传递数据,而是通知,把 buffer 里的数据 即时 投放到 /dev/input/deentx 对应的 逻辑设备文件里 
		input_sync(X);	
			->input_event(X, EV_SYN, SYN_REPORT, 0);
	按键问题:
		按照上述设定,执行cat /dev/input/eventx | hexdump 时,按下按键应该有输出!!!	但没有
			cat /dev/input/eventx | hexdump 命令:打开eventx 阻塞方式读出数据,吧数据装换16进制形式然后输出!!
		窥探input_event时,发现,
			->input_handle_event
				disposition = input_get_disposition(dev, type, code, &value); //得到一个disposition
				//对于按键类型来说,这个disposition == INPUT_PASS_TO_HANDLERS == 1 时,才会把数值放入 buffer 或则投放到eventx
				//但是由于我的驱动 默认了 当前键值key值是0, 而每次按键interrupts,都赋值1,
				第一次按键时,input_get_disposition()关于EV_KEY的部分,会比较当前key值是不是不等于即将赋予的按键值,
					if (!!test_bit(code, dev->key) != !!value ) 只有不等于的情况下才会赋予 disposition = 1
					否则 disposition = 0, 0表示忽略这个信号,实际意义就是,当前键值已经等于即将的赋值,不用重新赋值
				X->key 就是保存当前键值数据的,
				按规范,	当按键按下时,按键interrupts应赋值1,X->key改为1
					当按键松开时,按键interrupts应赋值0,X->key然后改为0
					但现在我的驱动问题是,不管按键是否按下,按键interrupts,都赋值1,X->key被赋值前也是1,
						所以 disposition = 0 按键事件被忽略,所以,也不把内容放入 buffer
						最终,也没有内容投放到 /dev/input/deentx 对应的 逻辑设备文件里
网上下载了两个测试input设备的用户态程序!!!! evtest.c 和 getevent(但是getevent源码损坏,不能用) 
	详见:/home/kingders/SAMA5D4/sources/driver_test/input_device/button :evtest.c getevent.c getevent.h
最后手段,改input子系统源码 加入pr_debug!!	
	发现:
		input_report_key 调用一次 input_event
		input_sync 也调用一次 input_event
		终于发现,由于我的的button设备并不规范,所以,按键信息被忽略掉了!!!
		具体通过查看 input_event 源码得到










20170109
补充电阻触摸屏的知识!!!
其实触摸屏上有4层悬空透明导体!!当用尖锐的物体点击屏幕时,悬空的四层导体会接触!!!
至于触摸屏的原理是:
	空闲状态时,X+(Xp)点处于3.3V高电平,而且内部串联了一个100kΩ的电阻,其他层处于低电平
	当有尖物触摸时,X+(Xp)层与Y-(Ym)层接触时,X+会被拉低电压,从而得到一个接触中断信号!!
	接触中断信号也会诱发 中断号44的中断处理程序:
		中断程序关闭 接触中断 打开坐标数据预备好中断,和不再接触中断
		然后通知adc硬件模块便按照触摸屏的模式执行一个连续的转换模式:
			每个子工作都是是,先变更配置X+(Xp) Y+(Yp) X-(Xm) Y-(Ym) 脚,然后adc采样一种坐标数据
	当一连串的转换工作完成后,触发数据预备好中断,
	由于同样属于adc模块,所以同样诱发 中断号44的中断处理程序,但是执行程序其他部分的内容,
		即读出坐标数据,
	如果接触物不离开屏幕,触摸屏就处于不断转换坐标数据,并让 中断号44的中断处理程序 处理数据的过程
	当接触物离开屏,4层悬空透明导体再次悬空.触发 不再接触中断,同样诱发 中断号44的中断处理程序 执行第三步部分内容:
		关闭坐标数据预备好中断,和不再接触中断  重新开启接触中断 
	等待下次触摸接触!!!
adc的pin位
Instance 	Signal 	I/O Line 	Peripheral
ADC 		ADTRG 	PE31 		A
ADC 		AD0 	PC27 		X1
ADC 		AD1 	PC28 		X1
ADC 		AD2 	PC29 		X1
ADC 		AD3 	PC30 		X1
ADC 		AD4 	PC31 		X1

probe过程重要分析!!
	注意,channel设置哪里,官方代码at91_adc_channel_init 4线adcts只有初始化来两条idev-channel ????
	直到 at91_adc_channel_init 执行完 probe初始化函数也只是设置了 MR寄存器!!
	直到 at91_ts_register 只是初始化了 input 设备而已!!!
	直到 at91_ts_hw_init 才开始初始化 各个硬件寄存器!!
		发现 offset 为 0xc0 的 TSR 寄存器 要配置,但没有这个寄存器!!!
		at91_ts_hw_init 只是 配置了 ADC_MR ADC_TSR ADC_TSMR ADC_ACR
	整个过程并没有 开中断 或者 开始adc转换的操作!!!
分析 open 函数 !!
	关键就是 打开 了 中断控制寄存器的开关!! 打开 PEN,或者 NOPEN 这个开关!!!
分析 interrupt 函数!!
	检测到 EOCx 时,简单处理,就是丢弃数据!!!
	检测到 笔接触时,关闭笔接触中断!! 开启非笔接触和X,Y,P, 的RD中断!!
	检测到 非笔接触时, 设置软件触发adc转换, 关闭非笔接触和X,Y,P, 的RD中断 ,开启笔接触中断!! report 按钮事件
	检测到 X,Y,P, 的RD时,当笔触还在接触时,分析 report X,Y,P 事件, 当笔触没有接触时,直接读出寄存器数据(读出而不report,等于丢弃!!!)
不管怎么弄就是不触发中断!!!!,所以尝试从裸机adc入手,顺便学习裸机包的使用!!
	看了文档,比想象中麻烦,的放弃!!!不过学习!!纠缠adc初始化源码!!!!!
后面发现,adc里好像没有对GPIO做初始化,然后看了看寄存器状态!! 5针,都设了peripheral 都设了peripheral A 但都处于 低电平 level 0
	但是data sheet 里要求 peripheral X! 而不是 A !!!! 什么鬼!!!
	还有既然都设置为 adc 的话, 应该不全是level 0 的
	还有,PMC_ADC peripheral clock 是启动了的 
今天为了解构为什么不触发中断,特意扒了adc转换的裸机源码,分析初始化和工作执行的步骤!!! 本来想另外写一个linux模块测试!!
	详见:driver_test/adc_module/adc_裸机分析(特别重视 AIC中断管理器的使用!!)
终于找到原因了,开发板,与触摸屏相关的还有地方分开了,并没有用 0R 电阻连接上!!!!
	成功有反应了:
	注意:使用了evtest 用户程序来测试: ./evtest /dev/input/event0
	evtest 用户程序在: sources/driver_test/input_device/button











20170109
深入makefile编写!!!!
	简单多文件结构的 linux 驱动模块的 makefile 编写: 参考(已经调试好的) sources/driver_test/multifiles_make_test1
	特别注意:
		module license 'unspecified' taints kernel. Disabling lock debugging due to kernel taint
		这种错误是由于多文件 链接成一个统一单.o文件时, 这个统一.o文件,与其他一个,o文件重名了!!
	还有一种:集成到内核源码里的方式:
	将驱动源代码文件（夹）放置在Linux内核源码的driver/xxx/的相应路径中，修改本层和上层的Makefile和KConfig文件，
	并重新make menuconfig内核，可以在Menu中选中新加入的驱动模块，然后make module，就可以在驱动源码文件夹生成.ko文件。
  	1. 要编译的驱动所在文件夹里的Makefile (本地Makefile)
	    #CONFIG_ECAT_DRV为m时编译为模块，为y时编进内核  
	    obj-$(CONFIG_ECAT_DRV) += ecat.o  
	    #-objs指定依赖的多个.o文件  
	    ecat-objs := ecateoe.o eoeappl.o mcihw.o ecatslv.o mailbox.o ecatappl.o ecat2440.o  
	2. 本地Kconfig
	    #建立一个本地子目录。“”为显示的目录名字  
	    menu "ecat driver here"       
	        depends on NET  #依赖于上层的某个开关  
	    config ECAT_DRV  #配置变量名，必须和Makefile中的变量后半段一样   
	        bool "ecat driver" #bool量， 显示的名字  
	        ---help---  #下面为要显示的帮助文字  
	            This is test for ecat.  
	    endmenu  #本地子目录结束  
	3. 上层Makefile
	    *  
	    *#添加下面这一句  
	    obj-$(CONFIG_ECAT_DRV) += ecat/  #打开下一级目录编译  
	    *  
	    *  
	4. 上层Kconfig
	    *  
	    *#添加下面这一句  
	    source "driver/xxx/ecat/Kconfig"  
	    #导入子文件夹中的Kconfig文件，可以为相对路径  
	    *  
	    *  
解决了:lcd 10分钟自动关屏幕问题!!
	推荐使用一个用户程序处理:
	display.c:
	#include <fcntl.h>
	#include <stdio.h>
	#include <sys/ioctl.h>
	int main(int argc ,char *argv[])
	{
	 int f0;
	 f0 = open("/dev/tty0", O_RDWR);
	 write(f0, "\033[9;0]", 8);
	 close(f0);
	 return 0;
	}
	arm-linux-gnueabihf-gcc -o display display.c //编译
	然后下载执行, 然后lcd的显示就又打开了!!!!
	如果要开机自动启动，复制到根目录后，在/etc/init.d/rcS里加上一句  /display
	详细原因见:http://blog.csdn.net/dongliqiang2006/article/details/4262950
	与console 和 tty 有巨大关联!!!
开发板的中断号与linux中断号的兑换表
	相关文件:linux-at91-master/drivers/irqchip/irq-atmel-aic5.c
	发现中断号 应该都在提取devicetree_node成platform_device_data时转换了










20170112
console 与 terminal 与 tty 重点!!
TTY:
	tty历史上是电传打字机的意思,后来是终端的意思!!
	(TTY)终端的概念: 一个提供输入和输出功能的实体硬件设备, 而且可以连接到电脑主机,与主机信息交互
		例如一台电脑的显示屏和键盘组合对于电脑主机来说这个组合是一个 TTY终端的硬件设备部分,
	业界把tty终端 可以连接到电脑主机,与主机信息交互 的部分抽象出来,就是没有实体硬件设备的终端,只有一个抽象接口
		当绑到一个实体硬件设备上的时候,这两者就成为一个真正意义上的终端
		然后操作硬件设备就相当于使用 终端 与 linux与电脑主机实现信息交互!!!
		每个终端每一时刻只能操作一个需要交互的用户程序!!
		这些 抽象接口 不严格意义上都可以统称 tty终端
	对于一台启动了的电脑!!
		我们常以为是运行在一个图形界面,
		实际上是:运行在 tty7终端上,而在这个终端上我们运行着一个大型的操作界面GUI程序而已!!
		在这里我们如果执行了一个 terminal程序,实际上是执行了一个 软件终端,
		透过这个软件,相当于我们在 tty7终端运行的大型软件 嵌套运行一个新的tty终端!!!		
	每一时刻只能操作一个需要交互的用户程序的概念例如:
		我们常常使用打开的terminal实际上就是一个终端软件,terminal窗口相当于输出端,硬件键盘就是输入端,
		terminal窗口和硬件键盘被这个 终端软件 打包模拟成一个实体硬件设备
		而这个硬件输入和输出功能的机器或机器组合,自动绑到一个抽象接口,即/dev/ttyX, 共同组合成一个真正意义上的终端
		通过这个接口,这个实体硬件设备 实现了与主机信息交互 的工作,
		也就是说 这个真正意义上的终端 实现了与主机信息交互 的工作
		在我们往 terminal 里 写执行命令时, 就相当于 通过通过终端往主机输入信息,
		主机把处理后的信息通过 /dev/ttyX 往terminal窗口送,便显示出来了
		在这样的交互过程中,我们只能一条条命令地输入执行,
		这就是每一时刻只能操作一个需要交互的用户程序的概念	
	理论上,各种类型实体硬件设备挂入 linux 都是注册一个终端设备,并生成绑定到对应的一个唯一的/dev/ttyXXX的字符设备文件,
		共同组合成一个含有输入和输出功能的硬件机器或机器组合,一个真正意义的终端!!
		例如著名的串口终端设备:
			/dev/ttyS0(对应通用标平台硬件0号口的串口终端设备) 
			/dev/ttySAC1(对应三星平台硬件1号口的串口终端设备)
			/dev/ttyACM4(对应at91平台硬件4号口的串口终端设备)
			/dev/ttyUSB0(对应通用标平台硬件0号口的usb串口终端设备)
		以上是一个硬件设备对照一个字符设备文件接口!!
		这些字符设备文件接口 俗称 串口终端设备
	然而,还有一种叫 虚拟终端设备 的概念: 
		有时希望第一终端正在执行一条漫长工作的指令,但是,又需要现在执行另一条指令,又不能停掉现在执行的那条,
		那么,我们就只能使用另外一个终端执行就可以了!!!
		因为一般实体硬件就只有一套,例如我们地脑的显示屏和键盘,那么,我们只需要把这套硬件绑到另外一个抽象接口,即另一个/dev/ttyX
		便可以得到一个新的终端,在这个终端里执行新的命令,
		虽然从旧的/dev/ttyX解绑出来,但是旧的终端并没有被关闭,只是被卸下实体硬件设备,旧的终端正在工作的命令还是在继续工作着,
		当我们把这套硬件绑回原来的抽象接口,就相当于给旧的终端装回硬件,转回到原来的终端上去!!!!
		这些抽象接口 /dev/ttyX 相当于没有硬件设备的终端, 俗称 虚拟终端设备 
		因为他们共用 显示屏和键盘 这套硬件设备!!!! 不像串口终端设备那样一对一的关系!!
console:	
	控制台终端,实际上是一个特殊终端!实际上他是基于 tty终端的,当把/dev/console映射到/dev/ttyXXX(例ttySAC0,tty0等等)时,
		实际上就是给普通的 tty终端 赋予了控制台的属性!!!,这个tty终端也就成了控制台终端!!
		控制台比tty终端多出来的属性是:(日志输出功能)可以显示printk内容!!!
	在移植内核时,我们写的bootargs里 有 console=tty0,console=ttyACM0 的内容就是说,tty0和ttyACM0 俩个tty终端赋予了控制台属性!!!
		但控制台终端只有一个!!!!
		这两个tty终端,会同时输出日志消息!!,即在tty0执行命令输出pingtk消息时,ttyACM0也会输出同样pintk消息
		但是,最后配置上控制台属性的 ttyACM0 才是一个实现基础的人机交互 的控制终端!!! 
			即例如开发板看到lcd屏显示,串口输出也有显示,但是,只能使用串口输入执行命令
			能用于人机交互的控制台,还有一个专有属性 就是提供用户登陆的功能!!
	控制台终端 与 普通的tty终端也就以上那点区别!!那么为啥还要另外弄一个控制台终端的概念?
		Linux kernel有一个很强烈的隐性规则----内核空间的代码不应该直接利用用户空间接口访问某些资源
		所以kernel的代码（如printk），就不能直接使用TTY的接口访问TTY设备
		kernel代码不应该直接使用文件系统接口访问文件（虽然它可以）
			TTY框架通过字符设备（也即文件系统）向用户空间提供接口
		console 是为此 开凿出来的后门.
伪终端 Pseudo Terminal，简称pty:
	并不是所有硬件设备都是通过串口的方式接入计算机开发板什么的,所以他们也不能简单地作为一个终端的输入输出功能的硬件
	相反,他们需要把自己的通讯方式模拟成串口硬件设备一样的,于是就出现了伪终端 pty 一般成对出现 pts ptm
	一般的:
		 硬件设备 接入 ttyX, ttyx与主机交互
	特殊的:
		特殊通讯协议硬件设备 接向 ptm, ptm与pts交互,  pts类似ttyx一样与主机交互
软件终端:
	我们平时 使用的的terminal,SecureCRT就是软件终端,
	但是也有区别:
		terminal: 
			把键盘输入功能和自身软件窗口输出功能打包模拟成一个串口硬件设备,或者其他特殊通讯协议的硬件设备
			然后 接入 一般的 /dev/ttyx 接口, ttyx与主机交互 组成一个真正的终端 			 
			或者其他特殊通讯协议的硬件设备
			通过伪终端方式 接入 ptm ptm又与专有pts交互,  pts类似ttyx一样与主机交互
		SecureCRT:
			模拟一个串口硬件设备接入到 开发板的 ttyX, ttyx与主机交互
最后,有一些未曾解决的疑问!!!
	kernal里配置 framebuffer_console 后, 开发板的串口和lcd都同时输出!!这是有两个console??
	当前可以进行人机交互的 tty终端,等同于console(控制台终端)么??
	我知道 tty0 永远是当前执行的终端,即电脑开机后,我是执行着 tty7的终端,而此刻的tty0就是tty7,
		而开机bootargs 里console=tty0, 就是说,当前不论执行在哪个tty终端都是console终端?
		唯有通过 terminal 执行的tty终端才可以不是console中端??








20170113
尝试使用官网的 连续buildroot一条龙工具链看看,
	$ git clone git://git.buildroot.net/buildroot     /* 下载buildroot 一条龙工具链  */
	$ git tag	/* 查看版本 */
	$ git checkout  2016.11-rc3 -b buildroot-2016.11-rc3	/* 选择 2016.11-rc3 这一版本 */
	$ make atmel_sama5d2_xplained_defconfig 	/* 建立一个配置,配置文件 XXX_defconfig 在 configs 文件夹可查看 */
	$ make		/* 开始一条龙编译, 最终所用生成文件放在 output/images里*/
	//开始刷写 flash
	$ ./board/atmel/flasher.sh ./output /dev/ttyACM1 sama5d4_xplained
	出错:
		couldn't load file "/tmp/tcloqFb5D": libXss.so.1: cannot open shared object file: No such file or directory
		couldn't load file "/tmp/tcl1oGOVF": libXft.so.2: cannot open shared object file: No such file or directory
	解决:
		sudo apt-get install libxss1:i386
		sudo apt-get install libxss1:i386
	继续出错:
		-I- Waiting ...
		-I- TCL platform : Linux
		-I- SAM-BA CDC 2.16  on : linux
		-I- Retrieved arguments from command line :
		-I- argv 0 : /dev/ttyACM1
		-I- argv 1 : at91sama5d4x-ek
		-I- argv 2 : ./board/atmel/nandflash.tcl
		-I- Connection /dev/ttyACM1
		-E- Connection /dev/ttyACM1 not found		//明明已经插好!!!使用新的sam-ba 3 可以链接!!
		-E- Connection list : 
	未解决:先搁置!!
尝试移植官方版 yocto_project:
	git clone 了 poky 的前三个软件包


偷闲分析usb驱动!
	drivers/usb/gadget/udc/atmel_usba_udc.c usb从设备驱动?就是把 开发板看做usb设备,而不是主机!!!








20170116
所谓usb_gaget 就是一个搭载linux工作的硬件设备,作为其他PC主机的 usb从设备,而需要用到的模块!!
usb_gaget驱动:
	基于底层提供的资源， Gadget 驱动可以运行在各种硬件平台上。重要的驱动有：
	Gadget Zero, 类似于 dummy hcd, 该驱动用于测试 udc 驱动。它会帮助您通过 USB-IF 测试。
	Ethernet over USB， 该驱动模拟以太网网口，它支持多种运行方式：
	CDC Ethernet: usb 规范规定的 Communications Device Class “Ethernet Model” protocol。
	CDC Subset： 对硬件要求最低的一种方式，主要是 Linux 主机支持该方式。
	RNDIS： 微软公司对 CDC Ethernet 的变种实现。
	File-backed Storage Gadget最常见的 U 盘功能实现。
	Serial Gadget 实现，包括：
	Generic Serial 实现（只需要Bulk-in/Bulk-out端点+ep0）
	CDC ACM 规范实现。
	Gadget Filesystem, 将 Gadget API 接口暴露给应用层，以便在应用层实现user mode driver。
	MIDI: 暴露ALSA接口，提供 recording 以及 playback 功能。
常见的 usb device 有 U 盘， usb 鼠标、键盘，usb 蓝牙模块，usb 读卡器，等等。这些设备比较简单，通常不会运行Linux。
	运行Linux Gadget 的通常是一些集成 CPU 以及很多外设接口的 SOC （System-on-Chip）， 
	其中 CPU 通常为 32 bit 的 CPU, 并且 udc 也是该 SOC 的一部分（ 顺带还有 DMA 通道，FIFO）。
观察:
  │ │                               --- USB Gadget Support                                                                                
  │ │                               [ ]   Debugging messages (DEVELOPMENT)                                                                
  │ │                               [ ]   Debugging information files (DEVELOPMENT)                                                       
  │ │                               [ ]   Debugging information files in debugfs (DEVELOPMENT)                                            
  │ │                               (2)   Maximum VBUS Power usage (2-500 mA)                                                             
  │ │                               (2)   Number of storage pipeline buffers                                                              
  │ │                                     USB Peripheral Controller  --->                                                                 
  │ │                               <M>   USB Gadget Drivers                                                                              
  │ │                               <M>     USB functions configurable through configfs                                                   
  │ │                               [ ]       Generic serial bulk in/out                                                                  
  │ │                               [*]       Abstract Control Model (CDC ACM)                                                            
  │ │                               [ ]       Object Exchange Model (CDC OBEX)                                                            
  │ │                               [ ]       Network Control Model (CDC NCM)                                                             
  │ │                               [ ]       Ethernet Control Model (CDC ECM)                                                           
  │ │                               [ ]       Ethernet Control Model (CDC ECM) subset     
  │ |                               [ ]       RNDIS                                                                                     
  │ │                               [ ]       Ethernet Emulation Model (EEM)                                                              
  │ │                               [*]       Mass storage                                                                                
.........                                                                      
  │ │                               < >     Gadget Zero (DEVELOPMENT)                                                                     
  │ │                               < >     Audio Gadget                                                                                  
  │ │                               < >     Ethernet Gadget (with CDC Ethernet support)                                                   
.......                                                                    
  │ │                               <M>     Mass Storage Gadget 
  │ │                               <M>     Serial Gadget (with CDC ACM and CDC OBEX support) 
得到的模块(gaget模块):
	libcomposite.ko
	u_serial.ko
	g_serial.ko
	usb_f_acm.ko
	usb_f_obex.ko
	usb_f_serial.ko
	g_mass_storage.ko
	atmel_usba_udc.ko
	usb_f_mass_storage.ko
从 Makefile 里得知:
	在function里编译得到的ko都是 接口中间模块,而在 legacy 里得到的ko都是真正的有实质工作的 上层usb从设备驱动
	中间模块;
		usb_f_acm.ko
		usb_f_obex.ko
		usb_f_serial.ko	
		u_serial.ko
		usb_f_mass_storage.ko
	实质从设备驱动:
		g_serial.ko
		g_mass_storage.ko
	gaget:udc控制器驱动:
		atmel_usba_udc.ko
	与复合usb从设备功能有关的中间模块:
		libcomposite.ko
学习到:
	acm 和 obex 都是特殊的串口通讯协议,serial才是传统的串口通讯协议
	所以 g_serial.ko 注册时,会选择其中一个通讯协议执行,
	也就是说 usb_f_acm.ko,usb_f_obex.ko, usb_f_serial.ko 三个挂载的中间模块中,我们会选择使用其中一个,
	这里 我们使用了usb_f_acm.ko
	发现,f_serial.c里的函数暂时也就只有f_serial.c自己调用!!很奇怪,作为一个中间模块.里面的函数绝对被放到指针里被调用了
如果项测试开发板的gaget串口功能!!可以这样:
	把编译好的内核烧入开发板，加载生成的驱动文件，注意加载顺序，否则会出现错误。
	insmod  u_serial.ko
	insmod  libcomposite.ko
	insmod   usb_f_serial.ko
	insmod  usb_f_obex.ko
	insmod  usb_f_acm.ko
	insmod  g_serial.ko
	出现内核信息如下：
	[   27.310000] --------file=composite.c-------usb_composite_probe------1830
	[   27.320000] ------------402
	[   27.320000] -----usb_gadget_probe_driver------411
	[   27.330000] -------udc_bind_to_driver-----342
	[   27.330000] g_serial gadget: Gadget Serial v2.4
	[   27.340000] g_serial gadget: g_serial ready
	[   18.960000] g_serial gadget: high-speed config #2: CDC ACM config
	说明加载成功。
	此时你打开 win7 设备管理器会发现多了一个串口设备，
	ELMO GMAS（COM10）
	(未测试!!)
测试:
	本想安装上述.ko 但发现其实都已经=安装,表示有一shell文件,自动把这些.ko都安装上了!!!!
	在这里,由于 usba 口 本来就接上电脑了
	所以,其实gaget 实际上已经工作了,
	然而,以下的初始化顺序还是很模糊!!!
		假如 insmod g_serial.ko 后,就认为gaget已工作?,就已经建立了 /dev/ttyGS0 ??,还是插线材后??
		pc(ubuntu)上,出现了 ttyACM1符号,显然是 由gaget 这方提供的信息,让pc机初始化的,但未见是gaget的哪部分初始化代码实现
	pc机 打开 ttyACM1 串口终端,往里写数据
	开发板 cat /dev/ttyGS0 监听到数据!!!
	注意:g_serial.ko 是 gaget 串口上层模块,通俗是我们常叫做的 usb串口驱动 (从设备端的!!)
卸载串口驱动,重新加载	
	# rmmod g_serial.ko 
	# insmod g_serial.ko
	g_serial gadget: Gadget Serial v2.4
	g_serial gadget: g_serial ready
	插入usb线到 usba口
	g_serial gadget: high-speed config #2: CDC ACM config	//插入出现的log!!!
	然后又可以观察串口工作:
	pc机 打开 ttyACM1 串口终端,往里写数据
	开发板 cat /dev/ttyGS0 监听到数据!!!
gaget作为u盘设备测试!!
	先安装两个模块:
		//libcomposite.ko, atmel_usba_udc.ko 两个模块 开示时已安装!!!
		# insmod usb_f_mass_storage.ko	//中间模块!!!
		# insmod g_mass_storage.ko	//u盘驱动 然而安装失败
		由于 gaget_usb控制器atmel_usba_udc 已经被作为串口占用了,出现这样错误!!
		insmod: ERROR: could not insert module g_mass_storage.ko: No such device
		# rmmod g_serial.ko //先卸载 usb 串口驱动
		//然而先不要 再次加载 u盘驱动!!
		//如果执行insmod g_mass_storage.ko还是会出错,从错误信息中发现,加载时需要写入参数的
		//Number of LUNs=8
		//Mass Storage Function, version: 2009/09/11
		//LUN: removable file: (no medium)
		//Number of LUNs=1
		//no file given for LUN0
		//g_mass_storage 400000.gadget: failed to start g_mass_storage: -22
	在加载u盘驱动前,先在 开发板 分配一个空间为u盘所用!!!! 
   		# dd if=/dev/zero of=vfat.img bs=1M count=20	//制作一个fat格式的镜像 1M*20=20M大小的 文件，
		20+0 records in
		20+0 records out
		20971520 bytes (21 MB) copied, 0.177479 s, 118 MB/s
   		# losetup /dev/loop0 vfat.img			//将镜像与loop0建立连接
    		# mkfs.vfat /dev/loop0				//格式化做出的镜像
		mkfs.fat 3.0.28 (2015-05-16)
		Loop device does not match a floppy size, using default hd params
    		# mkdir vfat_mount_point				//创建挂载点
    		# mount /dev/loop0 vfat_mount_point/   		//挂载挂载点
    		# insmod g_mass_storage.ko file=/dev/loop0 stall=0 removable=1     //这才是加载u盘驱动的真正方式
		g_mass_storage: unknown parameter 'removeble' ignored
		Number of LUNs=8
		Mass Storage Function, version: 2009/09/11
		LUN: removable file: (no medium)
		Number of LUNs=1
		LUN: file: /dev/loop0
		Number of LUNs=1
		g_mass_storage gadget: Mass Storage Gadget, version: 2009/09/11
		g_mass_storage gadget: userspace failed to provide iSerialNumber
		g_mass_storage gadget: g_mass_storage ready
		g_mass_storage gadget: high-speed config #1: Linux File-Backed Storage   //注意这句 是在usba口经usb线接到pc机时出现,
    		插上开发板的usb从接口，即可从PC机段看到vfat_mount_point下的内容,
		pc机可以刷写内容到里面!! 开发板来到vfat_mount_point 可以看到刷入数据
		开发板往里写内容,pc机可见!!!!!
测试总结:
	显然如果不加载 g_XXX.ko 插入usb线并没有信息输出,gaget功能并不会实现!!!!
	初步分析,当usb插入时,才会调用 struct usb_composite_driver里的 .bind 函数!!
gaget 串口例程分析:
	legacy: serial.c 将编译成上层实质从设备驱动模块 g_serial.ko:
	(感觉这不是一个热插拔自动加载的驱动,手动加载后,就自动存在 并存在建立好的 /dev逻辑设备文件,不管此刻是否接上usb!!)
	serial.c 初始化 :
		static struct usb_composite_driver gserial_driver = {
		.name		= "g_serial",
		.dev		= &device_desc,
		.strings	= dev_strings,
		.max_speed	= USB_SPEED_SUPER,
		.bind		= gs_bind,
		.unbind		= gs_unbind,
		};
		struct usb_configuration serial_config_driver;
		serial_config_driver.bmAttributes = USB_CONFIG_ATT_SELFPOWER;
		serial_config_driver.label = "Generic Serial config";
		serial_config_driver.bConfigurationValue = 1;
		struct usb_device_descriptor device_desc;
		device_desc.bDeviceClass = USB_CLASS_VENDOR_SPEC;
		device_desc.idProduct =	cpu_to_le16(GS_PRODUCT_ID);
		static struct usb_string strings_dev[];
		strings_dev[STRING_DESCRIPTION_IDX].s = serial_config_driver.label;
		usb_composite_probe(&gserial_driver);			//composite.c
			struct usb_composite_driver *driver = &gserial_driver;
			struct usb_gadget_driver *gadget_driver;
			static const struct usb_gadget_driver composite_driver_template = {
				.bind		= composite_bind,
				.unbind		= composite_unbind,
				.setup		= composite_setup,
				.reset		= composite_disconnect,
				.disconnect	= composite_disconnect,
				.suspend	= composite_suspend,
				.resume		= composite_resume,
				.driver	= {
					.owner		= THIS_MODULE,
					},
				};	
			driver->gadget_driver = composite_driver_template;
			gadget_driver = &driver->gadget_driver;
			gadget_driver->function =  (char *) driver->name;
			gadget_driver->driver.name = driver->name;
			gadget_driver->max_speed = driver->max_speed;
			usb_gadget_probe_driver(gadget_driver);			//udc_core.c
				struct usb_gadget_driver *driver = gadget_driver
				list_for_each_entry(udc, &udc_list, list)
				(	if (!udc->driver)	//如果udc里没有驱动
						goto found;	//即udc_bind_to_driver(udc, driver);	
				}
				udc_bind_to_driver(udc, driver);			
					struct usb_udc *udc = udc 
					struct usb_gadget_driver *driver = driver
					struct usb_udc {		//udc_core.c
						struct usb_gadget_driver	*driver;
						struct usb_gadget		*gadget;
						struct device			dev;
						struct list_head		list;
						bool				vbus;
					};
 					udc->driver = driver;
					udc->dev.driver = &driver->driver;
					udc->gadget->dev.driver = &driver->driver;
					ret = driver->bind(udc->gadget, driver);//这里的bind是 composite_bind
						//然后转到 gs_bind 函数
					ret = usb_gadget_udc_start(udc);
						//这里执行的 ops.udc_start 应该就是 atmel_usba_udc 的这个udc驱动
					usb_udc_connect_control(udc);
						//Enables the D+ (or potentially D-) pullup
					kobject_uevent(&udc->dev.kobj, KOBJ_CHANGE);
						//通知了用户空间,注意只是通知了 atmel_usba_udc 驱动得变化,
						//并不是通知发生了热插拔事件!!!
关于 uevent:
	uevent(user space event) 内核与用户空间的一种通信机制，基于netlink机制，主要用于设备驱动模型，例如热插拔
		也就是说在某个时刻触发某个事件并通知给用户空间。
	事件：
		enum kobject_action {
		 KOBJ_ADD,
		 KOBJ_REMOVE,
		 KOBJ_CHANGE,
		 KOBJ_MOVE,
		 KOBJ_ONLINE,
		 KOBJ_OFFLINE,
		 KOBJ_MAX
		};
	触发点 kobject_uevent() :
 		如device_add()中的触发：
			kobject_uevent(&dev->kobj, KOBJ_ADD);
 		在kobject_uevent()中会先执行集成在kset中的kset_uevent_ops, 之后再通过netlink传递给用户空间。
 		struct kset_uevent_ops {
		 int (* const filter)(struct kset *kset, struct kobject *kobj);
		 const char *(* const name)(struct kset *kset, struct kobject *kobj);
		 int (* const uevent)(struct kset *kset, struct kobject *kobj,
		        struct kobj_uevent_env *env);
		};
 		filter用于判断uevent是否要发出去，name用于得到subsystem的名字，uevent用于填充env变量。
 		我们可以看到kobject_uevent()中的代码： 
			 if (uevent_ops && uevent_ops->filter)
			  if (!uevent_ops->filter(kset, kobj)) {
			       ......
			  }
			 /* originating subsystem */
			 if (uevent_ops && uevent_ops->name) {
			  subsystem = uevent_ops->name(kset, kobj);
			  ......
			 }
			  ......
			 /* let the kset specific function add its stuff */
			 if (uevent_ops && uevent_ops->uevent) {
			  retval = uevent_ops->uevent(kset, kobj, env);
			    ......
			 }
 		最后调用netlink接口发送出去，用户层会根据所设置的env变量来启动相应操作，至于env变量设置内容暂时不深究。
	当 kobject_uevent() 把内容通知到了用户空间后,用户空间的处理!! 
 		uevent的用户空间程序有两个，一个是udev，一个是mdev。
 		udev通过netlink监听uevent消息，它能完成两个功能：
 		      1．自动加载模块
 		      2．根据uevent消息在dev目录下添加、删除设备节点。
		另一个是mdev，mdev在busybox的代码包中能找到，它通过上节提到的uevent_helper函数被调用。
		udev的模块自动加载过程：
 			etc目录下有一个uevent规则文件/etc/udev/rules.d/50-udev.rules
			udev程序收到uevent消息后，在这个规则文件里匹配，如果匹配成功，则执行这个匹配定义的shell命令。
			例如，规则文件里有这么一行：
			ACTION=="add", SUBSYSTEM=="?*", ENV{MODALIAS}=="?*", RUN+="/sbin/modprobe $env{MODALIAS}"
			所以，当收到uevent的add事件后，shell能自动加载在MODALIAS中定义的模块。	
		mdev的模块自动加载过程与之类似，它的配置文件在/etc/mdev.conf中。例如：
			$MODALIAS=.* 0:0 660 @modprobe "$MODALIAS"
			这条规则指的是：当收到的环境变量中含有MODALIAS，那么加载MODALIAS代表的模块。
			mdev的详细说明在busybox的docs/mdev.txt中。
关于 OTG
	OTG 是 usb 的一个通用标准功能!! USB硬件内部有一条 动态的ID线
	当我们配置使用 OTG 功能, usb控制器驱动就会多了一个工作,监测当前usb口连接的状态,
	当检测到 ID线接地 这个usb口会作为host口,这台设备工作在usb 的主机模式,并不会工作在usb 从机模式,即不会使用 gaget 的驱动
	当检测到 ID线悬空 这个usb口会作为slave口,这台设备作为usb从设备,会使用 gaget 的驱动 执行工作!!!
	这个动态id线 通过 刷写 寄存器 改变状态!!
github常用命令:
平时提交!!
git add -A	//把所有修改了的文件和新建的文件的痕迹加入暂存区,相当于全员备份
git add modules/*	// */  把modules整个文件夹及其内容载入暂存区
git commit -m "xxx"	//提交
git push origin master	//提交远程库
git rm --cached tools/qt/qt-everywhere-opensource-src-5.6.0-rc.tar.gz	//移除多余错误添加git add 到index缓存的文件
git reset --soft HEAD^	//软回溯到上个版版本,即上个版本还没有git commit 的状态














20170117
编译 yocto project:
先建立一个总文件夹 我直接设了一个poky文件夹 cd Poky
	git clone git://git.yoctoproject.org/poky -b krogoth	/* 下载 yocto project 总工具链 */
	git clone git://git.openembedded.org/meta-openembedded -b krogoth	/* 下载 meta-openembedded 包 */
	git clone git://github.com/meta-qt5/meta-qt5.git -b krogoth	/* 下载 meta-qt5 包 */
	git clone git://github.com/linux4sam/meta-atmel.git -b krogoth	/* 下载 meta-atmel 包 */
	备份!!4个包!! 出Poky文件夹, 另建 Poky_backup 保存git clone下来的四个工具包
然后继续: 
	cd poky
	source oe-init-build-env build-atmel	//建立了编译工作文件夹 bulid-atmel 拷贝了通用配置到里面,并自动 cd 到 build-atmel 文件夹
	gedit conf/bblayers.conf	//修改 ./build-amel/conf/bblayers.conf 文件	
/* build-amel/conf/bblayers.conf: start */
# POKY_BBLAYERS_CONF_VERSION is increased each time build/conf/bblayers.conf
# changes incompatibly
POKY_BBLAYERS_CONF_VERSION = "2"
BBPATH = "${TOPDIR}"
BBFILES ?= ""
# 官方建议的BSPDIR ,但使用时出现大量 checksum错误 ,和文件无法找到的错误
# BSPDIR := "${@os.path.abspath(os.path.dirname(d.getVar('FILE', True)) + '/../../..')}"
# by willam 所以最好改为静态路径
BSPDIR := "/home/infortech-ubuntu-1404/SAMA5D4/sources/Yocto_project/Poky"
BBLAYERS ?= " \
  ${BSPDIR}/poky/meta \
  ${BSPDIR}/poky/meta-poky \
  ${BSPDIR}/poky/meta-yocto-bsp \
  ${BSPDIR}/meta-atmel \
  ${BSPDIR}/meta-openembedded/meta-oe \
  ${BSPDIR}/meta-openembedded/meta-networking \
  ${BSPDIR}/meta-openembedded/meta-python \
  ${BSPDIR}/meta-openembedded/meta-ruby \
  ${BSPDIR}/meta-openembedded/meta-multimedia \
  ${BSPDIR}/meta-qt5 \
  "
BBLAYERS_NON_REMOVABLE ?= " \
  ${BSPDIR}/poky/meta \
  ${BSPDIR}/poky/meta-poky \
  "
/* build-amel/conf/bblayers.conf: end */

	gedit conf/local.conf //继续 修改 ./build-amel/conf/local.conf 文件

/* build-amel/conf/local.conf: start */
...
#by william	
MACHINE ?= "sama5d4-xplained"
...
# 还是用回 默认路径,因为这样,似乎不会出现 checksum 和 文件 not found 错误
# 这里是指定一个下载的库文件要寄放的文件夹!!
DL_DIR ?= "${TOPDIR}/downloads"		
#by william
# DL_DIR ?= "/home/infortech-ubuntu-1404/SAMA5D4/sources/Yocto_project/Poky"
....
#by william 符合 atmel 官方的policy configure
DISTRO = "poky-atmel"
....
#
# Package Management configuration
#
# This variable lists which packaging formats to enable. Multiple package backends
# can be enabled at once and the first item listed in the variable will be used
# to generate the root filesystems.
# Options are:
#  - 'package_deb' for debian style deb files
#  - 'package_ipk' for ipk files are used by opkg (a debian style embedded package manager)
#  - 'package_rpm' for rpm style packages
# E.g.: PACKAGE_CLASSES ?= "package_rpm package_deb package_ipk"
#by william Package Management configuration 使用默认使用 ipk 格式包 
PACKAGE_CLASSES ?= "package_ipk"
....
# We default to enabling the debugging tweaks.
EXTRA_IMAGE_FEATURES ?= "debug-tweaks"
....
#by william  未知有何用,,
USER_CLASSES ?= "buildstats image-mklibs"
....
# Runtime testing of images
PATCHRESOLVE = "noop"
....
# Disk Space Monitoring during the build
BB_DISKMON_DIRS = "\
    STOPTASKS,${TMPDIR},1G,100K \
    STOPTASKS,${DL_DIR},1G,100K \
    STOPTASKS,${SSTATE_DIR},1G,100K \
    STOPTASKS,/tmp,100M,100K \
    ABORT,${TMPDIR},100M,1K \
    ABORT,${DL_DIR},100M,1K \
    ABORT,${SSTATE_DIR},100M,1K \
    ABORT,/tmp,10M,1K"
.....
# Qemu configuration
PACKAGECONFIG_append_pn-qemu-native = " sdl"
PACKAGECONFIG_append_pn-nativesdk-qemu = " sdl"
....
CONF_VERSION = "1"
/* build-amel/conf/local.conf: end */
	
	bitbake core-image-minimal
		ERROR:  OE-core's config sanity checker detected a potential misconfiguration.
		    Either fix the cause of this error or at your own risk disable the checker (see sanity.conf).
		    Following is the list of potential problems / advisories:

		    Please install the following missing utilities: makeinfo,gawk,chrpath

		Summary: There was 1 ERROR message shown, returning a non-zero exit code.
		解决1:
		sudo apt-get install makeinfo gawk chrpath
			没有makeinfo 其实装的是texinfo 非makeinfo
		解决2:
		sudo apt-get install texinfo gawk chrpath
	再次: bitbake core-image-minimal
		WARNING: /home/infortech-ubuntu-1404/SAMA5D4/sources/Yocto_project/Poky/poky/meta/recipes-bsp/grub/grub-efi_2.00.bb: 
		Unable to get checksum for grub-efi-native SRC_URI entry cfg: file could not be found
		...
		解决:
		之前的 bblayers.conf: BSPDIR 改为:
			BSPDIR := "/home/infortech-ubuntu-1404/SAMA5D4/sources/Yocto_project/Poky"
		仍然 warning
		把 local.conf:DL_DIR 改回与来的 :
			DL_DIR ?= "${TOPDIR}/downloads" 就是说说编译过程中要下载的文件放入 build-atmel/downloads
		居然好了
	再次: bitbake core-image-minimal 几乎用了15小时, 还从网上下载了 25 G 内容!!!!!
		但是还是有错!!!! 具体 log;
/* 编译log?: start */ 
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ bitbake core-image-minimal
Parsing recipes: 100% |###################################################################################################################################| Time: 00:00:30
Parsing of 1934 .bb files complete (0 cached, 1934 parsed). 2490 targets, 379 skipped, 0 masked, 0 errors.
NOTE: Resolving any missing task queue dependencies

Build Configuration:
BB_VERSION        = "1.30.0"
BUILD_SYS         = "x86_64-linux"
NATIVELSBSTRING   = "Ubuntu-14.04"
TARGET_SYS        = "arm-poky-linux-gnueabi"
MACHINE           = "sama5d4-xplained"
DISTRO            = "poky-atmel"
DISTRO_VERSION    = "2.1.2"
TUNE_FEATURES     = "arm armv7a vfp thumb neon       callconvention-hard       cortexa5"
TARGET_FPU        = "hard"
meta              
meta-poky         
meta-yocto-bsp    = "krogoth:ae9b341ecfcc60e970f29cfe04306411ad26c0cf"
meta-atmel        = "krogoth:c415e7330e6fd92e860423d144d6c98bf20c8887"
meta-oe           
meta-networking   
meta-python       
meta-ruby         
meta-multimedia   = "krogoth:55c8a76da5dc099a7bc3838495c672140cedb78e"
meta-qt5          = "krogoth:2b1871f0d139dc3caaa779a32a1931409c245a36"

NOTE: Fetching uninative binary shim from http://downloads.yoctoproject.org/releases/uninative/1.0.1/x86_64-nativesdk-libc.tar.bz2;sha256sum=acf1e44a0ac2e855e81da6426197d36358bf7b4e88e552ef933128498c8910f8
NOTE: Preparing RunQueue
NOTE: Executing SetScene Tasks
NOTE: Executing RunQueue Tasks
WARNING: zlib-native-1.2.8-r0 do_fetch: Failed to fetch URL http://www.zlib.net/zlib-1.2.8.tar.xz, attempting MIRRORS if available
WARNING: quilt-native-0.64-r0 do_fetch: Failed to fetch URL http://download.savannah.gnu.org/releases/quilt/quilt-0.64.tar.gz, attempting MIRRORS if available
WARNING: attr-native-2.4.47-r0 do_fetch: Failed to fetch URL http://download.savannah.gnu.org/releases/attr/attr-2.4.47.src.tar.gz, attempting MIRRORS if available
WARNING: libpcre-native-8.38-r0 do_fetch: Failed to fetch URL ftp://ftp.csx.cam.ac.uk/pub/software/programming/pcre/pcre-8.38.tar.bz2, attempting MIRRORS if available
WARNING: bash-4.3.30-r0 do_fetch: Failed to fetch URL http://ftp.gnu.org/gnu/bash/bash-4.3-patches/bash43-033;apply=yes;striplevel=0;name=patch033, attempting MIRRORS if available
WARNING: sysvinit-2.88dsf-r14 do_fetch: Failed to fetch URL http://download.savannah.gnu.org/releases/sysvinit/sysvinit-2.88dsf.tar.bz2, attempting MIRRORS if available
NOTE: Tasks Summary: Attempted 1843 tasks of which 9 didn't need to be rerun and all succeeded.

Summary: There were 6 WARNING messages shown.



infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky$ source oe-init-build-env build-atmel
bash: infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky$: 没有那个文件或目录
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ You had no conf/local.conf file. This configuration file has therefore been
You：未找到命令
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ created for you with some default values. You may wish to edit it to, for
未找到 'created' 命令，您要输入的是否是：
 命令 'createdb' 来自于包 'postgresql-client-common' (main)
 命令 'createdb' 来自于包 'postgres-xc-client' (universe)
created：未找到命令
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ example, select a different MACHINE (target hardware). See conf/local.conf
bash: 未预期的符号 `(' 附近有语法错误
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ for more information as common configuration options are commented.
bash: 未预期的符号 `information' 附近有语法错误
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ 
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ You had no conf/bblayers.conf file. This configuration file has therefore been
You：未找到命令
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ created for you with some default values. To add additional metadata layers
未找到 'created' 命令，您要输入的是否是：
 命令 'createdb' 来自于包 'postgres-xc-client' (universe)
 命令 'createdb' 来自于包 'postgresql-client-common' (main)
created：未找到命令
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ into your configuration please add entries to conf/bblayers.conf.
未找到 'into' 命令，您要输入的是否是：
 命令 'pinto' 来自于包 'pinto' (universe)
 命令 'info' 来自于包 'info' (main)
into：未找到命令
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ 
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ The Yocto Project has extensive documentation about OE including a reference
未找到 'The' 命令，您要输入的是否是：
 命令 'the' 来自于包 'the' (universe)
The：未找到命令
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ manual which can be found at:
manual：未找到命令
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$     http://yoctoproject.org/documentation
bash: http://yoctoproject.org/documentation: 没有那个文件或目录
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ 
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ For more information about OpenEmbedded see their website:
未找到 'For' 命令，您要输入的是否是：
 命令 'tor' 来自于包 'tor' (universe)
 命令 'sor' 来自于包 'pccts' (universe)
 命令 'vor' 来自于包 'vor' (universe)
For：未找到命令
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$     http://www.openembedded.org/
bash: http://www.openembedded.org/: 没有那个文件或目录
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ 
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ 
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ ### Shell environment set up for builds. ###
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ 
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ You can now run 'bitbake <target>'
You：未找到命令
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ 
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ Common targets are:
Common：未找到命令
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$     core-image-minimal
core-image-minimal：未找到命令
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$     core-image-sato
core-image-sato：未找到命令
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$     meta-toolchain
meta-toolchain：未找到命令
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$     meta-ide-support
meta-ide-support：未找到命令
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ 
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ You can also run generated qemu images with a command like 'runqemu qemux86'
You：未找到命令
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ bitbake core-image-minimal
bash: infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$: 没有那个文件或目录
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ Parsing recipes: 100% |###################################################################################################################################| Time: 00:00:30
> Parsing of 1934 .bb files complete (0 cached, 1934 parsed). 2490 targets, 379 skipped, 0 masked, 0 errors.
bash: 未预期的符号 `(' 附近有语法错误
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ NOTE: Resolving any missing task queue dependencies
NOTE:：未找到命令
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ 
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ Build Configuration:
未找到 'Build' 命令，您要输入的是否是：
 命令 'guild' 来自于包 'guile-2.0-libs' (main)
Build：未找到命令
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ BB_VERSION        = "1.30.0"
BB_VERSION：未找到命令
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ BUILD_SYS         = "x86_64-linux"
BUILD_SYS：未找到命令
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ NATIVELSBSTRING   = "Ubuntu-14.04"
NATIVELSBSTRING：未找到命令
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ TARGET_SYS        = "arm-poky-linux-gnueabi"
TARGET_SYS：未找到命令
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ MACHINE           = "sama5d4-xplained"
MACHINE：未找到命令
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ DISTRO            = "poky-atmel"
DISTRO：未找到命令
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ DISTRO_VERSION    = "2.1.2"
DISTRO_VERSION：未找到命令
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ TUNE_FEATURES     = "arm armv7a vfp thumb neon       callconvention-hard       cortexa5"
TUNE_FEATURES：未找到命令
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ TARGET_FPU        = "hard"
TARGET_FPU：未找到命令
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ meta              
未找到 'meta' 命令，您要输入的是否是：
 命令 'metar' 来自于包 'flightgear' (universe)
 命令 'metar' 来自于包 'metar' (universe)
meta：未找到命令
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ meta-poky         
meta-poky：未找到命令
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ meta-yocto-bsp    = "krogoth:ae9b341ecfcc60e970f29cfe04306411ad26c0cf"
meta-yocto-bsp：未找到命令
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ meta-atmel        = "krogoth:c415e7330e6fd92e860423d144d6c98bf20c8887"
meta-atmel：未找到命令
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ meta-oe           
meta-oe：未找到命令
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ meta-networking   
meta-networking：未找到命令
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ meta-python       
meta-python：未找到命令
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ meta-ruby         
meta-ruby：未找到命令
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ meta-multimedia   = "krogoth:55c8a76da5dc099a7bc3838495c672140cedb78e"
meta-multimedia：未找到命令
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ meta-qt5          = "krogoth:2b1871f0d139dc3caaa779a32a1931409c245a36"
meta-qt5：未找到命令
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ 
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ NOTE: Fetching uninative binary shim from http://downloads.yoctoproject.org/releases/uninative/1.0.1/x86_64-nativesdk-libc.tar.bz2;sha256sum=acf1e44a0ac2e855e81da6426197d36358bf7b4e88e552ef933128498c8910f8
NOTE:：未找到命令
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ NOTE: Preparing RunQueue
NOTE:：未找到命令
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ NOTE: Executing SetScene Tasks
NOTE:：未找到命令
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ NOTE: Executing RunQueue Tasks
NOTE:：未找到命令
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ WARNING: zlib-native-1.2.8-r0 do_fetch: Failed to fetch URL http://www.zlib.net/zlib-1.2.8.tar.xz, attempting MIRRORS if available
WARNING:：未找到命令
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ WARNING: quilt-native-0.64-r0 do_fetch: Failed to fetch URL http://download.savannah.gnu.org/releases/quilt/quilt-0.64.tar.gz, attempting MIRRORS if available
WARNING:：未找到命令
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ WARNING: attr-native-2.4.47-r0 do_fetch: Failed to fetch URL http://download.savannah.gnu.org/releases/attr/attr-2.4.47.src.tar.gz, attempting MIRRORS if available
WARNING:：未找到命令
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ Currently 8 running tasks (191 of 1843):
bash: 未预期的符号 `(' 附近有语法错误
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ 0: gcc-source-5.3.0-5.3.0-r0 do_fetch (pid 15030)bash: 未预期的符号 `(' 附近有语法错误
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ 1: ncurses-native-6.0+20160213-r0 do_fetch (pid 15046)
bash: 未预期的符号 `(' 附近有语法错误
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ 2: binutils-cross-arm-2.26-r0 do_fetch (pid 15122)
bash: 未预期的符号 `(' 附近有语法错误
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ 3: linux-libc-headers-4.4-r0 do_fetch (pid 15145)bash: 未预期的符号 `(' 附近有语法错误
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ 4: glibc-initial-2.23-r0 do_fetch (pid 15156)
bash: 未预期的符号 `(' 附近有语法错误
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ 5: glibc-2.23-r0 do_fetch (pid 28211)
bash: 未预期的符号 `(' 附近有语法错误
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ 6: openssl-native-1.0.2h-r0 do_compile (pid 20726)
bash: 未预期的符号 `(' 附近有语法错误
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ 7: xproto-native-1_7.0.28-r0 do_fetch (pid 11955)bash: 未预期的符号 `(' 附近有语法错误
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ 
/* 编译log: end*/
	过程中,有六个网上获取包失败!!!
	经过发现,后面的所谓命令找不到,极可能是以不正当的方式在输出一个报告文件,
	实际上已经全部编译完成!!!!!!镜像放在:
		/home/infortech-ubuntu-1404/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel/tmp/deploy/images/sama5d4-xplained
测试便以结果!!!!
只烧写了 dtb 和 zImage,成功!!! 
sudo sam-ba -p serial:ttyACM1:115200 -b sama5d4-xplained -a nandflash -c erase:0x200000:0x600000 -c erase:0x180000:0x80000 -c write:zImage-at91-sama5d4_xplained.dtb:0x180000 -c write:zImage:0x200000
只烧写 uboot dtb zImage 成功!!!
sudo sam-ba -p serial:ttyACM1:115200 -b sama5d4-xplained -a nandflash -c erase:0x40000:0x80000 -c erase:0x200000:0x600000 -c erase:0x180000:0x80000 -c write:u-boot.bin:0x40000 -c write:zImage-at91-sama5d4_xplained.dtb:0x180000 -c write:zImage:0x200000
只烧写 uboot dtb zImage fs成功!!!
sudo sam-ba -p serial:ttyACM1:115200 -b sama5d4-xplained -a nandflash -c erase:0x40000:0x80000 -c erase:0x200000:0x600000 -c erase:0x180000:0x80000 -c erase:0x800000:0x1f800000 -c write:u-boot.bin:0x40000 -c write:zImage-at91-sama5d4_xplained.dtb:0x180000 -c write:zImage:0x200000 -c write:core-image-minimal-sama5d4-xplained.ubi:0x800000
都烧写:(注意,at91bootstrap居然 链接到uboot,也是uboot?你妹,名字差点就坑死我了,注意是spl-uboot!!) 
/* 不成功!!!!!!! */
sudo sam-ba -p serial:ttyACM1:115200 -b sama5d4-xplained -a nandflash -c erase:0x0:0x40000 -c erase:0x40000:0x80000 -c erase:0x200000:0x600000 -c erase:0x180000:0x80000 -c erase:0x800000:0x1f800000 -c write:at91bootstrap-sama5d4_xplained.bin:0x0 -c write:u-boot.bin:0x40000 -c write:zImage-at91-sama5d4_xplained.dtb:0x180000 -c write:zImage:0x200000 -c write:core-image-minimal-sama5d4-xplained.ubi:0x800000
/* 成功 */  /* 注意,bootstrap 用 writeboot 指令 ,不用加地址 ":0x0" */
sudo sam-ba -p serial:ttyACM1:115200 -b sama5d4-xplained -a nandflash -c erase:0x0:0x40000 -c erase:0x40000:0x80000 -c erase:0x200000:0x600000 -c erase:0x180000:0x80000 -c erase:0x800000:0x1f800000 -c writeboot:at91bootstrap-sama5d4_xplained.bin -c write:u-boot.bin:0x40000 -c write:zImage-at91-sama5d4_xplained.dtb:0x180000 -c write:zImage:0x200000 -c write:core-image-minimal-sama5d4-xplained.ubi:0x800000
	至此,全部生成镜像 通过!!
	把景象文件全考到:core-image-minimal_demo文件夹备份
	另外,如何 更改内核配置!!! 而bitbake 又可以通过????
处理好 core-image-minimal 后,开始搭载 QT界面镜像的编译!!!
	特别注意,由于重启电脑的关系!!!!等等情况
	回到 poky 文件夹!!!
	重新执行一次: source oe-init-build-env build-atmel 指令!!!
	自动转到build-atmel
	把备份了的 build-atmel/conf 覆盖当前conf
	gedit conf/local.conf	//最后添加两行
		......
		LICENSE_FLAGS_WHITELIST += "commercial"
		SYSVINIT_ENABLED_GETTYS = ""
	然后才:bitbake atmel-qt5-demo-image	
	如果不重新执行 source oe-init-build-env build-atmel:
		直接修改 conf/local.conf
		然后执行 bitbake atmel-qt5-demo-image 会出现 bitbake命令没找到的错误!!!!!!
/* 编译log : start */
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky$ source oe-init-build-env build-atmel

### Shell environment set up for builds. ###

You can now run 'bitbake <target>'

Common targets are:
    core-image-minimal
    core-image-sato
    meta-toolchain
    meta-ide-support

You can also run generated qemu images with a command like 'runqemu qemux86'
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ bitbake atmel-qt5-demo-image
Loading cache: 100% |#####################################################################################################################################| ETA:  00:00:00
Loaded 2486 entries from dependency cache.
Parsing recipes: 100% |###################################################################################################################################| Time: 00:00:06
Parsing of 1934 .bb files complete (1929 cached, 5 parsed). 2490 targets, 358 skipped, 0 masked, 0 errors.
NOTE: Resolving any missing task queue dependencies

Build Configuration:
BB_VERSION        = "1.30.0"
BUILD_SYS         = "x86_64-linux"
NATIVELSBSTRING   = "universal"
TARGET_SYS        = "arm-poky-linux-gnueabi"
MACHINE           = "sama5d4-xplained"
DISTRO            = "poky-atmel"
DISTRO_VERSION    = "2.1.2"
TUNE_FEATURES     = "arm armv7a vfp thumb neon       callconvention-hard       cortexa5"
TARGET_FPU        = "hard"
meta              
meta-poky         
meta-yocto-bsp    = "krogoth:ae9b341ecfcc60e970f29cfe04306411ad26c0cf"
meta-atmel        = "krogoth:c415e7330e6fd92e860423d144d6c98bf20c8887"
meta-oe           
meta-networking   
meta-python       
meta-ruby         
meta-multimedia   = "krogoth:55c8a76da5dc099a7bc3838495c672140cedb78e"
meta-qt5          = "krogoth:2b1871f0d139dc3caaa779a32a1931409c245a36"

NOTE: Preparing RunQueue
NOTE: Executing SetScene Tasks
NOTE: Executing RunQueue Tasks
WARNING: apr-native-1.5.2-r0 do_fetch: Failed to fetch URL http://archive.apache.org/dist/apr/apr-1.5.2.tar.bz2, attempting MIRRORS if available
WARNING: libcap-2.24-r0 do_fetch: Failed to fetch URL http://kernel.org/pub/linux/libs/security/linux-privs/libcap2/libcap-2.24.tar.xz, attempting MIRRORS if available
WARNING: iso-codes-3.65-r0 do_fetch: Failed to fetch URL https://pkg-isocodes.alioth.debian.org/downloads/iso-codes-3.65.tar.xz, attempting MIRRORS if available
WARNING: libtirpc-1.0.1-r0 do_fetch: Failed to fetch URL http://distfiles.gentoo.org/distfiles/libtirpc-glibc-nfs.tar.xz;name=glibc-nfs, attempting MIRRORS if available
ERROR: libtirpc-1.0.1-r0 do_fetch: Fetcher failure: Fetch command failed with exit code 4, output:
wget: unable to resolve host address 'distfiles.gentoo.org'

ERROR: libtirpc-1.0.1-r0 do_fetch: Function failed: Fetcher failure for URL: 'http://distfiles.gentoo.org/distfiles/libtirpc-glibc-nfs.tar.xz;name=glibc-nfs'. Unable to fetch URL from any source.
ERROR: Logfile of failure stored in: /home/infortech-ubuntu-1404/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel/tmp/work/cortexa5hf-neon-poky-linux-gnueabi/libtirpc/1.0.1-r0/temp/log.do_fetch.9327
ERROR: Task 4195 (/home/infortech-ubuntu-1404/SAMA5D4/sources/Yocto_project/Poky/poky/meta/recipes-extended/libtirpc/libtirpc_1.0.1.bb, do_fetch) failed with exit code '1'
WARNING: qtbase-native-5.6.2+gitAUTOINC+b4ada3f0d8-r0 do_fetch: Failed to fetch URL git://github.com/qt/qtbase.git;name=qtbase;branch=5.6;protocol=git, attempting MIRRORS if available
ERROR: qtbase-native-5.6.2+gitAUTOINC+b4ada3f0d8-r0 do_fetch: Fetcher failure: Fetch command failed with exit code 128, output:
Cloning into bare repository '/home/infortech-ubuntu-1404/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel/downloads/git2/github.com.qt.qtbase.git'...
fatal: read error: Connection reset by peer
fatal: early EOF
fatal: index-pack failed

ERROR: qtbase-native-5.6.2+gitAUTOINC+b4ada3f0d8-r0 do_fetch: Function failed: Fetcher failure for URL: 'git://github.com/qt/qtbase.git;name=qtbase;branch=5.6;protocol=git'. Unable to fetch URL from any source.
ERROR: Logfile of failure stored in: /home/infortech-ubuntu-1404/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel/tmp/work/x86_64-linux/qtbase-native/5.6.2+gitAUTOINC+b4ada3f0d8-r0/temp/log.do_fetch.3732
ERROR: Task 1923 (/home/infortech-ubuntu-1404/SAMA5D4/sources/Yocto_project/Poky/meta-qt5/recipes-qt/qt5/qtbase-native_git.bb, do_fetch) failed with exit code '1'
WARNING: qtbase-5.6.2+gitAUTOINC+b4ada3f0d8-r0 do_fetch: Failed to fetch URL git://github.com/qt/qtbase.git;name=qtbase;branch=5.6;protocol=git, attempting MIRRORS if available
ERROR: qtbase-5.6.2+gitAUTOINC+b4ada3f0d8-r0 do_fetch: Fetcher failure: Fetch command failed with exit code 128, output:
Cloning into bare repository '/home/infortech-ubuntu-1404/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel/downloads/git2/github.com.qt.qtbase.git'...
fatal: read error: Connection timed out
fatal: early EOF
fatal: index-pack failed

ERROR: qtbase-5.6.2+gitAUTOINC+b4ada3f0d8-r0 do_fetch: Function failed: Fetcher failure for URL: 'git://github.com/qt/qtbase.git;name=qtbase;branch=5.6;protocol=git'. Unable to fetch URL from any source.
ERROR: Logfile of failure stored in: /home/infortech-ubuntu-1404/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel/tmp/work/cortexa5hf-neon-poky-linux-gnueabi/qtbase/5.6.2+gitAUTOINC+b4ada3f0d8-r0/temp/log.do_fetch.3735
ERROR: Task 630 (/home/infortech-ubuntu-1404/SAMA5D4/sources/Yocto_project/Poky/meta-qt5/recipes-qt/qt5/qtbase_git.bb, do_fetch) failed with exit code '1'
NOTE: Tasks Summary: Attempted 1498 tasks of which 1066 didn't need to be rerun and 3 failed.
Waiting for 0 running tasks to finish:

Summary: 3 tasks failed:
  /home/infortech-ubuntu-1404/SAMA5D4/sources/Yocto_project/Poky/poky/meta/recipes-extended/libtirpc/libtirpc_1.0.1.bb, do_fetch
  /home/infortech-ubuntu-1404/SAMA5D4/sources/Yocto_project/Poky/meta-qt5/recipes-qt/qt5/qtbase-native_git.bb, do_fetch
  /home/infortech-ubuntu-1404/SAMA5D4/sources/Yocto_project/Poky/meta-qt5/recipes-qt/qt5/qtbase_git.bb, do_fetch
Summary: There were 6 WARNING messages shown.
Summary: There were 6 ERROR messages shown, returning a non-zero exit code.
/* 编译log : end */
	log显示 qtbase-native-5.6.2+gitAUTOINC+b4ada3f0d8-r0 下载失败,感觉这个是关键!!
	测试生成的镜像,全部成功启动,就是不知道最终是否有图像帧输出!!!!
	感觉并没有QT界面demo程序的出现
感觉 bitbake atmel-qt5-demo-image 是失败了的,官网上 Build Atmel Poky Qt-Embedded SDK 是什么鬼??
	bitbake -c populate_sdk atmel-qt5-demo-image //先尝试,不管了,
	//这次鸣不需要重新执行一次: source oe-init-build-env build-atmel 指令!!! 估计是没有重启关系,配置文件没用删回原样!!
	//另外,观察是不是每次bitbake都要重新下载文件!!! 并没有重新下载文件!! 然而 qtbase包还是没有!!
/* log : start */
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ bitbake -C populate_sdk atmel-qt5-demo-image
Loading cache: 100% |#####################################################################################################################################| ETA:  00:00:00
Loaded 2486 entries from dependency cache.
Parsing recipes: 100% |###################################################################################################################################| Time: 00:00:36
Parsing of 1934 .bb files complete (1929 cached, 5 parsed). 2490 targets, 358 skipped, 0 masked, 0 errors.
NOTE: Resolving any missing task queue dependencies

Build Configuration:
BB_VERSION        = "1.30.0"
BUILD_SYS         = "x86_64-linux"
NATIVELSBSTRING   = "universal"
TARGET_SYS        = "arm-poky-linux-gnueabi"
MACHINE           = "sama5d4-xplained"
DISTRO            = "poky-atmel"
DISTRO_VERSION    = "2.1.2"
TUNE_FEATURES     = "arm armv7a vfp thumb neon       callconvention-hard       cortexa5"
TARGET_FPU        = "hard"
meta              
meta-poky         
meta-yocto-bsp    = "krogoth:ae9b341ecfcc60e970f29cfe04306411ad26c0cf"
meta-atmel        = "krogoth:c415e7330e6fd92e860423d144d6c98bf20c8887"
meta-oe           
meta-networking   
meta-python       
meta-ruby         
meta-multimedia   = "krogoth:55c8a76da5dc099a7bc3838495c672140cedb78e"
meta-qt5          = "krogoth:2b1871f0d139dc3caaa779a32a1931409c245a36"

NOTE: Preparing RunQueue
NOTE: Tainting hash to force rebuild of task /home/infortech-ubuntu-1404/SAMA5D4/sources/Yocto_project/Poky/meta-atmel/qt5-layer/recipes-qt/images/atmel-qt5-demo-image.bb, do_populate_sdk
NOTE: Executing SetScene Tasks
NOTE: Executing RunQueue Tasks
WARNING: libproxy-0.4.11-r0 do_fetch: Failed to fetch URL http://snapshot.debian.org/archive/debian/20160728T043443Z/pool/main/libp/libproxy/libproxy_0.4.11.orig.tar.gz, attempting MIRRORS if available
WARNING: ethtool-4.2-r0 do_fetch: Failed to fetch URL http://kernel.org/pub/software/network/ethtool/ethtool-4.2.tar.gz, attempting MIRRORS if available
WARNING: openssh-7.1p2-r0 do_fetch: Failed to fetch URL http://ftp.openbsd.org/pub/OpenBSD/OpenSSH/portable/openssh-7.1p2.tar.gz, attempting MIRRORS if available
WARNING: mpeg2dec-0.4.1-r2 do_fetch: Failed to fetch URL http://libmpeg2.sourceforge.net/files/mpeg2dec-0.4.1.tar.gz, attempting MIRRORS if available
WARNING: apmd-3.2.2-15-r0 do_fetch: Failed to fetch URL http://snapshot.debian.org/archive/debian/20160728T043443Z/pool/main/a/apmd/apmd_3.2.2.orig.tar.gz;name=tarball, attempting MIRRORS if available
WARNING: sysklogd-1.5.1-r0 do_fetch: Failed to fetch URL http://www.infodrom.org/projects/sysklogd/download/sysklogd-1.5.1.tar.gz, attempting MIRRORS if available
ERROR: apmd-3.2.2-15-r0 do_fetch: Fetcher failure: Fetch command failed with exit code 4, output:
wget: unable to resolve host address 'snapshot.debian.org'

ERROR: apmd-3.2.2-15-r0 do_fetch: Function failed: Fetcher failure for URL: 'http://snapshot.debian.org/archive/debian/20160728T043443Z/pool/main/a/apmd/apmd_3.2.2.orig.tar.gz;name=tarball'. Unable to fetch URL from any source.
ERROR: Logfile of failure stored in: /home/infortech-ubuntu-1404/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel/tmp/work/cortexa5hf-neon-poky-linux-gnueabi/apmd/3.2.2-15-r0/temp/log.do_fetch.15423
ERROR: Task 3283 (/home/infortech-ubuntu-1404/SAMA5D4/sources/Yocto_project/Poky/poky/meta/recipes-bsp/apmd/apmd_3.2.2-15.bb, do_fetch) failed with exit code '1'
ERROR: sysklogd-1.5.1-r0 do_fetch: Fetcher failure: Fetch command failed with exit code 4, output:
wget: unable to resolve host address 'www.infodrom.org'

ERROR: sysklogd-1.5.1-r0 do_fetch: Function failed: Fetcher failure for URL: 'http://www.infodrom.org/projects/sysklogd/download/sysklogd-1.5.1.tar.gz'. Unable to fetch URL from any source.
ERROR: Logfile of failure stored in: /home/infortech-ubuntu-1404/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel/tmp/work/cortexa5hf-neon-poky-linux-gnueabi/sysklogd/1.5.1-r0/temp/log.do_fetch.15450
ERROR: Task 3270 (/home/infortech-ubuntu-1404/SAMA5D4/sources/Yocto_project/Poky/poky/meta/recipes-extended/sysklogd/sysklogd_1.5.1.bb, do_fetch) failed with exit code '1'
WARNING: time-1.7-r2 do_fetch: Failed to fetch URL http://ftp.gnu.org/gnu/time/time-1.7.tar.gz, attempting MIRRORS if available
WARNING: wpa-supplicant-2.5-r0 do_fetch: Failed to fetch URL http://w1.fi/releases/wpa_supplicant-2.5.tar.gz, attempting MIRRORS if available
WARNING: qtbase-native-5.6.2+gitAUTOINC+b4ada3f0d8-r0 do_fetch: Failed to fetch URL git://github.com/qt/qtbase.git;name=qtbase;branch=5.6;protocol=git, attempting MIRRORS if available
ERROR: qtbase-native-5.6.2+gitAUTOINC+b4ada3f0d8-r0 do_fetch: Fetcher failure: Fetch command failed with exit code 128, output:
Cloning into bare repository '/home/infortech-ubuntu-1404/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel/downloads/git2/github.com.qt.qtbase.git'...
fatal: read error: Connection timed out
fatal: early EOF
fatal: index-pack failed

ERROR: qtbase-native-5.6.2+gitAUTOINC+b4ada3f0d8-r0 do_fetch: Function failed: Fetcher failure for URL: 'git://github.com/qt/qtbase.git;name=qtbase;branch=5.6;protocol=git'. Unable to fetch URL from any source.
ERROR: Logfile of failure stored in: /home/infortech-ubuntu-1404/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel/tmp/work/x86_64-linux/qtbase-native/5.6.2+gitAUTOINC+b4ada3f0d8-r0/temp/log.do_fetch.12778
ERROR: Task 1923 (/home/infortech-ubuntu-1404/SAMA5D4/sources/Yocto_project/Poky/meta-qt5/recipes-qt/qt5/qtbase-native_git.bb, do_fetch) failed with exit code '1'
NOTE: Tasks Summary: Attempted 2348 tasks of which 1710 didn't need to be rerun and 3 failed.
Waiting for 0 running tasks to finish:

Summary: 3 tasks failed:
  /home/infortech-ubuntu-1404/SAMA5D4/sources/Yocto_project/Poky/poky/meta/recipes-bsp/apmd/apmd_3.2.2-15.bb, do_fetch
  /home/infortech-ubuntu-1404/SAMA5D4/sources/Yocto_project/Poky/poky/meta/recipes-extended/sysklogd/sysklogd_1.5.1.bb, do_fetch
  /home/infortech-ubuntu-1404/SAMA5D4/sources/Yocto_project/Poky/meta-qt5/recipes-qt/qt5/qtbase-native_git.bb, do_fetch
Summary: There were 9 WARNING messages shown.
Summary: There were 6 ERROR messages shown, returning a non-zero exit code.
/* log : end */
	











20170120
关于 yocto project  的学习!!
You can find log files for each task in the recipe's temp directory 
	(e.g. poky/build/tmp/work/qemux86-poky-linux/foo/1.3.0-r0/temp). 
	 Log files are named log.taskname (e.g. log.do_configure, log.do_fetch, and log.do_compile). 
To add a new machine, you need to add a new machine configuration file to the layer's conf/machine directory. 
	This configuration file provides details about the device you are adding. 	
	The most important variables you must set in your machine configuration file 	
	or include from a lower-level configuration file are as follows:
		TARGET_ARCH (e.g. "arm")
		PREFERRED_PROVIDER_virtual/kernel
		MACHINE_FEATURES (e.g. "apm screen wifi")
	You might also need these variables:
		SERIAL_CONSOLES (e.g. "115200;ttyS0 115200;ttyS1")
		KERNEL_IMAGETYPE (e.g. "zImage")
		IMAGE_FSTYPES (e.g. "tar.gz jffs2")
	You can find full details on these variables in the reference section. 
	You can leverage existing machine .conf files from meta-yocto-bsp/conf/machine/. 
Adding a Kernel for the Machine








20170203
/** 配置qt5.6.2 环境 **/
下载源码:
	http://download.qt.io/official_releases/qt/5.6/5.6.2/single/下载(官方发布非调试版本):
		qt-everywhere-opensource-src-5.6.2.zip
	然后解压
配置 qmake:
	qtbase/mkspecs/linux-arm-gnueabi-g++/qmake.conf
	#
	# qmake configuration for building with arm-linux-gnueabi-g++
	#

	MAKEFILE_GENERATOR      = UNIX
	CONFIG                 += incremental
	QMAKE_INCREMENTAL_STYLE = sublib
	
	QT_QPA_DEFAULT_PLATFORM = linuxfb   
	#QMAKE_CFLAGS_RELEASE   +=-O2 -march=armv5te  
	QMAKE_CFLAGS_RELEASE	+= -O2 -march=armv7-a      	#选择armv7架构
	QMAKE_CXXFLAGS_RELEASE	+= -O2 -march=armv7-a  		#选择armv7架构
	
	include(../common/linux.conf)
	include(../common/gcc-base-unix.conf)
	include(../common/g++-unix.conf)
	
	# modifications to g++.conf
	QMAKE_CC                = arm-linux-gnueabihf-gcc	#把 arm-linux-gnueabi  换成arm-linux-gnueabihf
	QMAKE_CXX               = arm-linux-gnueabihf-g++
	QMAKE_LINK              = arm-linux-gnueabihf-g++
	QMAKE_LINK_SHLIB        = arm-linux-gnueabihf-g++
	
	# modifications to linux.conf
	QMAKE_AR                = arm-linux-gnueabihf-ar cqs
	QMAKE_OBJCOPY           = arm-linux-gnueabihf-objcopy
	QMAKE_NM                = arm-linux-gnueabihf-nm -P
	QMAKE_STRIP             = arm-linux-gnueabihf-strip
	load(qt_config)

配置 QT 工具链:
	cd 到 qt-everywhere-opensource-src-5.6.2 源码根目录
	..sources/qt/qt-5.6.2/qt-everywhere-opensource-src-5.6.2$ ./configure -release -opensource -xplatform linux-arm-gnueabi-g++ -prefix /home/infortech-ubuntu-1404/SAMA5D4/sources/qt/qt-5.6.2/armv7-a -no-c++11 -qreal float
		//-xplatform linux-arm-gnueabi-g++ 说明 生成的QT工具包和库是面向arm架构的，表示这些工具和库要用对应的编译工具生成
		//-prefix home/infortech-ubuntu-1404/SAMA5D4/sources/qt/qt-5.6.2/armv7-a 表示 生成的QT工具包和库 都install到的目标文件夹
		//-no-c++11 表示不使用C++11标准来编译文件, 即使用旧版的 c++98 标准来编译工具链
	./configure出错:  bash: ./configure: /bin/sh^M: 解释器错误: 没有那个文件或目录
		由于configure文件本来面向win系统 以 \n\r表示行结尾, 而linux单纯以 \n表示行结尾,
		在linux里 \r 被显示为^M
		所以要把\r替换为空格
		注意使用gedit 去掉\r 不彻底,由于gedit自动识别到 configure是 win文件 所以 保存文件时又会重新添上 \r
		不然./configure还会出现像:/bin/sh: 0: Can't open  这样的错误!!
		所以使用命令替换\r为空格 : sed -i 's/\r$//' configure
		./configure 继续出错: ./configure: 49: exec: /home/infortech-ubuntu-1404/SAMA5D4/sources/qt/qt-5.6.2/qt-everywhere-opensource-src-5.6.2/qtbase/configure: not found
		原因是: qtbase/configure 依然有 /r
			sed -i 's/\r$//' ./qtbase/configure
		./configure 继续出错: You don't seem to have 'make' or 'gmake' in your PATH.
			初步解决办法: sudo apt-get install build-essential(未执行)

发现: qt-everywhere-opensource-src-5.6.2.zip 是面向 win 的源码包,
	我们应该下载面向linux 的源码包 :qt-everywhere-opensource-src-5.6.2.tar.gz
	重新配置....
	然后 ./cofigure 一直通过,没有再出现之前遇到的错误
/* log : start */
+ cd qtbase
+ /home/infortech-ubuntu-1404/SAMA5D4/sources/qt/qt-5.6.2/qt-everywhere-opensource-src-5.6.2/qtbase/configure -top-level -release -opensource -xplatform linux-arm-gnueabi-g++ -prefix /home/infortech-ubuntu-1404/SAMA5D4/sources/qt/qt-5.6.2/armv7-a -no-c++11 -qreal float

This is the Qt Open Source Edition.

You are licensed to use this software under the terms of
the Lesser GNU General Public License (LGPL) versions 2.1.
You are also licensed to use this software under the terms of
the GNU Lesser General Public License (LGPL) versions 3.

Type '3' to view the GNU Lesser General Public License version 3.
Type 'L' to view the Lesser GNU General Public License version 2.1.
Type 'yes' to accept this license offer.
Type 'no' to decline this license offer.

Do you accept the terms of either license? yes

Running configuration tests (phase 1)...
Done running configuration tests.
Creating qmake...
.........................................................................................Done.
Running configuration tests (phase 2)...
Warning: Disabling pkg-config since PKG_CONFIG_LIBDIR is not set and
the host's .pc files would be used (even if you set PKG_CONFIG_PATH).
Set this variable to the directory that contains target .pc files
for pkg-config to function correctly when cross-compiling or
use -pkg-config to override this test.
Warning: Disabling pkg-config since PKG_CONFIG_SYSROOT_DIR is not set.
Set this variable to your sysroot for pkg-config to function correctly when
cross-compiling or use -pkg-config to override this test.
checking for default C++ standard edition...  yes.
checking for 64-bit std::atomic...  yes.
checking for sse2...  no.
checking for ipc_sysv...  yes.
checking for zlib...  no.
checking for mtdev...  no.
checking for libjpeg...  no.
checking for libpng...  no.
checking for dlopen...  no.
checking for libdl...  yes.
checking for DB2...  no.
checking for InterBase...  no.
checking for MySQL (thread-safe)...  no.
checking for MySQL (thread-unsafe)...  no.
checking for OCI...  no.
checking for ODBC...  no.
checking for iODBC...  no.
checking for PostgreSQL...  no.
checking for SQLite2...  no.
checking for TDS...  no.
checking for Cups...  no.
checking for POSIX iconv...  yes.
checking for D-Bus...  no.
checking for libproxy...  no.
checking for Glib...  no.
checking for ICU...  no.
checking for PulseAudio...  no.
checking for OpenGL...  no.
checking for OpenGL ES 2.0...  no.
checking for FontConfig...  no.
checking for libudev...  no.
checking for evdev...  yes.
checking for tslib...  no.
checking for xkbcommon...  no.
checking for XLib...  no.
checking for Xrender...  no.
checking for XInput2...  no.
checking for xcb...  no.
checking for GBM...  no.
checking for LinuxFB...  yes.
checking for KMS...  no.
checking for Mir client...  no.
checking for EGL...  no.
checking for FreeType...  no.
checking for STL...  yes.
checking for POSIX clock_gettime()...  yes.
checking for POSIX Monotonic Clock...  yes.
checking for posix_fallocate...  yes.
checking for mremap...  yes.
checking for getaddrinfo...  yes.
checking for inotify...  yes.
checking for eventfd...  yes.
checking for IPv6 interface name...  yes.
checking for getifaddrs...  yes.
checking for cloexec...  yes.
checking for OpenSSL...  no.
checking for PCRE...  no.
checking for OpenVG...  no.
checking for OpenVG...  no.
checking for OpenVG (lc includes)...  no.
checking for OpenVG (lc includes)...  no.
checking for alsa...  no.
checking for GStreamer 1.0...  no.
checking for GStreamer 0.10...  no.
Done running configuration tests.

   Configure summary

Building on:   linux-g++ (x86_64, CPU features: mmx sse sse2)
Building for:  linux-arm-gnueabi-g++ (arm, CPU features: none detected)
Platform notes:

            - Also available for Linux: linux-clang linux-kcc linux-icc linux-cxx
        
Build options:
  Configuration .......... accessibility audio-backend clock-gettime clock-monotonic compile_examples concurrent cross_compile dbus enable_new_dtags evdev eventfd freetype full-config getaddrinfo getifaddrs harfbuzz iconv inotify ipv6ifname large-config largefile linuxfb medium-config minimal-config mremap no-pkg-config pcre png posix_fallocate precompile_header qpa qpa reduce_exports release rpath shared small-config threadsafe-cloexec zlib 
  Build parts ............ libs examples
  Mode ................... release
  Using sanitizer(s)...... none
  Using C++ standard ..... c++98		//使用旧版的 c++98 标准来编译工具链
  Using gold linker....... no
  Using new DTAGS ........ yes
  Using PCH .............. yes
  Using LTCG ............. no
  Target compiler supports:
    Neon ................. no

Qt modules and options:
  Qt D-Bus ............... yes (loading dbus-1 at runtime)
  Qt Concurrent .......... yes
  Qt GUI ................. yes
  Qt Widgets ............. yes
  Large File ............. yes
  QML debugging .......... yes
  Use system proxies ..... no

Support enabled for:
  Accessibility .......... yes
  ALSA ................... no
  CUPS ................... no
  Evdev .................. yes
  FontConfig ............. no
  FreeType ............... yes (bundled copy)
  Glib ................... no
  GStreamer .............. no
  GTK theme .............. no
  HarfBuzz ............... yes (bundled copy)
  Iconv .................. yes
  ICU .................... no
  Image formats: 
    GIF .................. yes (plugin, using bundled copy)
    JPEG ................. yes (plugin, using bundled copy)
    PNG .................. yes (in QtGui, using bundled copy)
  libinput................ no
  Logging backends: 
    journald ............... no
    syslog   ............... no
  mtdev .................. no
  Networking: 
    getaddrinfo .......... yes
    getifaddrs ........... yes
    IPv6 ifname .......... yes
    libproxy.............. no
    OpenSSL .............. no
  OpenGL / OpenVG: 
    EGL .................. no
    OpenGL ............... no
    OpenVG ............... no
  PCRE ................... yes (bundled copy)
  pkg-config ............. no 
  PulseAudio ............. no
  QPA backends: 
    DirectFB ............. no
    EGLFS ................ no
      EGLFS i.MX6 ........ no
      EGLFS i.MX6 Wayland. no
      EGLFS EGLDevice .... no
      EGLFS GBM .......... no
      EGLFS Mali ......... no
      EGLFS Raspberry Pi . no
      EGLFS X11 .......... no
    LinuxFB .............. yes
    Mir client............ no
    XCB .................. no
  Session management ..... yes
  SQL drivers: 
    DB2 .................. no
    InterBase ............ no
    MySQL ................ no
    OCI .................. no
    ODBC ................. no
    PostgreSQL ........... no
    SQLite 2 ............. no
    SQLite ............... yes (plugin, using bundled copy)
    TDS .................. no
  tslib .................. no
  udev ................... no
  xkbcommon-x11........... no
  xkbcommon-evdev......... no
  zlib ................... yes (bundled copy)

Info: creating super cache file /home/infortech-ubuntu-1404/SAMA5D4/sources/qt/qt-5.6.2/qt-everywhere-opensource-src-5.6.2/.qmake.super

        NOTICE: The -no-c++11 / --c++-level=c++98 option is deprecated.

        Qt 5.7 will require C++11 support. The options are in effect for this
        Qt 5.6 build, but you should update your build scripts to remove the
        option and, if necessary, upgrade your compiler.

Qt is now configured for building. Just run 'make'.
Once everything is built, you must run 'make install'.
Qt will be installed into /home/infortech-ubuntu-1404/SAMA5D4/sources/qt/qt-5.6.2/armv7-a

Prior to reconfiguration, make sure you remove any leftovers from
the previous build.
/* log : end */
	./configure成功
编译:
	make
	出错:
	在编译plugins/canbus时:
	../../../../include/QtSerialBus/../../src/serialbus/qcanbusdevice.h:98:46: error: ‘nullptr’ was not declared in this scope
In file included from main.cpp:37:0:
	../../../../include/QtSerialBus/../../src/serialbus/qcanbus.h:60:31: error: ‘nullptr’ was not declared in this scope
	main.cpp:58:14: error: ‘device’ does not name a type
	main.cpp:59:16: error: ‘device’ was not declared in this scope
	初步认为是,编译时没有开启支持 C++11 的特性!! 而一些内容需要C++11的特性来编译
重新配置:
	./configure -release -opensource -xplatform linux-arm-gnueabi-g++ -prefix /home/infortech-ubuntu-1404/SAMA5D4/sources/qt/qt-5.6.2/armv7-a -c++11 -qreal float	//注意 -c++11 前面没有-no前缀 ,这里配置应该就表示使用C++11标准编译 qt工具链 
/* log : start */
+ cd qtbase
+ /home/infortech-ubuntu-1404/SAMA5D4/sources/qt/qt-5.6.2/qt-everywhere-opensource-src-5.6.2/qtbase/configure -top-level -release -opensource -xplatform linux-arm-gnueabi-g++ -prefix /home/infortech-ubuntu-1404/SAMA5D4/sources/qt/qt-5.6.2/armv7-a -c++11 -qreal float

This is the Qt Open Source Edition.

You are licensed to use this software under the terms of
the Lesser GNU General Public License (LGPL) versions 2.1.
You are also licensed to use this software under the terms of
the GNU Lesser General Public License (LGPL) versions 3.

Type '3' to view the GNU Lesser General Public License version 3.
Type 'L' to view the Lesser GNU General Public License version 2.1.
Type 'yes' to accept this license offer.
Type 'no' to decline this license offer.

Do you accept the terms of either license? yes

Running configuration tests (phase 1)...
Done running configuration tests.
Creating qmake...
.Done.
Running configuration tests (phase 2)...
Warning: Disabling pkg-config since PKG_CONFIG_LIBDIR is not set and
the host's .pc files would be used (even if you set PKG_CONFIG_PATH).
Set this variable to the directory that contains target .pc files
for pkg-config to function correctly when cross-compiling or
use -pkg-config to override this test.
Warning: Disabling pkg-config since PKG_CONFIG_SYSROOT_DIR is not set.
Set this variable to your sysroot for pkg-config to function correctly when
cross-compiling or use -pkg-config to override this test.
checking for C++11...  yes.
checking for default C++ standard edition...  yes.
checking for 64-bit std::atomic...  yes.
checking for sse2...  no.
checking for ipc_sysv...  yes.
checking for zlib...  no.
checking for mtdev...  no.
checking for libjpeg...  no.
checking for libpng...  no.
checking for dlopen...  no.
checking for libdl...  yes.
checking for DB2...  no.
checking for InterBase...  no.
checking for MySQL (thread-safe)...  no.
checking for MySQL (thread-unsafe)...  no.
checking for OCI...  no.
checking for ODBC...  no.
checking for iODBC...  no.
checking for PostgreSQL...  no.
checking for SQLite2...  no.
checking for TDS...  no.
checking for Cups...  no.
checking for POSIX iconv...  yes.
checking for D-Bus...  no.
checking for libproxy...  no.
checking for Glib...  no.
checking for ICU...  no.
checking for PulseAudio...  no.
checking for OpenGL...  no.
checking for OpenGL ES 2.0...  no.
checking for FontConfig...  no.
checking for libudev...  no.
checking for evdev...  yes.
checking for tslib...  no.
checking for xkbcommon...  no.
checking for XLib...  no.
checking for Xrender...  no.
checking for XInput2...  no.
checking for xcb...  no.
checking for GBM...  no.
checking for LinuxFB...  yes.
checking for KMS...  no.
checking for Mir client...  no.
checking for EGL...  no.
checking for FreeType...  no.
checking for STL...  yes.
checking for POSIX clock_gettime()...  yes.
checking for POSIX Monotonic Clock...  yes.
checking for posix_fallocate...  yes.
checking for mremap...  yes.
checking for getaddrinfo...  yes.
checking for inotify...  yes.
checking for eventfd...  yes.
checking for IPv6 interface name...  yes.
checking for getifaddrs...  yes.
checking for cloexec...  yes.
checking for OpenSSL...  no.
checking for PCRE...  no.
checking for OpenVG...  no.
checking for OpenVG...  no.
checking for OpenVG (lc includes)...  no.
checking for OpenVG (lc includes)...  no.
checking for alsa...  no.
checking for GStreamer 1.0...  no.
checking for GStreamer 0.10...  no.
Done running configuration tests.

   Configure summary

Building on:   linux-g++ (x86_64, CPU features: mmx sse sse2)
Building for:  linux-arm-gnueabi-g++ (arm, CPU features: none detected)
Platform notes:

            - Also available for Linux: linux-clang linux-kcc linux-icc linux-cxx
        
Build options:
  Configuration .......... accessibility audio-backend c++11 clock-gettime clock-monotonic compile_examples concurrent cross_compile dbus enable_new_dtags evdev eventfd freetype full-config getaddrinfo getifaddrs harfbuzz iconv inotify ipv6ifname large-config largefile linuxfb medium-config minimal-config mremap no-pkg-config pcre png posix_fallocate precompile_header qpa qpa reduce_exports release rpath shared small-config threadsafe-cloexec zlib 
  Build parts ............ libs examples
  Mode ................... release
  Using sanitizer(s)...... none
  Using C++ standard ..... c++11		//使用C++11标准来 编译
  Using gold linker....... no
  Using new DTAGS ........ yes
  Using PCH .............. yes
  Using LTCG ............. no
  Target compiler supports:
    Neon ................. no

Qt modules and options:
  Qt D-Bus ............... yes (loading dbus-1 at runtime)
  Qt Concurrent .......... yes
  Qt GUI ................. yes
  Qt Widgets ............. yes
  Large File ............. yes
  QML debugging .......... yes
  Use system proxies ..... no

Support enabled for:
  Accessibility .......... yes
  ALSA ................... no
  CUPS ................... no
  Evdev .................. yes
  FontConfig ............. no
  FreeType ............... yes (bundled copy)
  Glib ................... no
  GStreamer .............. no
  GTK theme .............. no
  HarfBuzz ............... yes (bundled copy)
  Iconv .................. yes
  ICU .................... no
  Image formats: 
    GIF .................. yes (plugin, using bundled copy)
    JPEG ................. yes (plugin, using bundled copy)
    PNG .................. yes (in QtGui, using bundled copy)
  libinput................ no
  Logging backends: 
    journald ............... no
    syslog   ............... no
  mtdev .................. no
  Networking: 
    getaddrinfo .......... yes
    getifaddrs ........... yes
    IPv6 ifname .......... yes
    libproxy.............. no
    OpenSSL .............. no
  OpenGL / OpenVG: 
    EGL .................. no
    OpenGL ............... no
    OpenVG ............... no
  PCRE ................... yes (bundled copy)
  pkg-config ............. no 
  PulseAudio ............. no
  QPA backends: 
    DirectFB ............. no
    EGLFS ................ no
      EGLFS i.MX6 ........ no
      EGLFS i.MX6 Wayland. no
      EGLFS EGLDevice .... no
      EGLFS GBM .......... no
      EGLFS Mali ......... no
      EGLFS Raspberry Pi . no
      EGLFS X11 .......... no
    LinuxFB .............. yes
    Mir client............ no
    XCB .................. no
  Session management ..... yes
  SQL drivers: 
    DB2 .................. no
    InterBase ............ no
    MySQL ................ no
    OCI .................. no
    ODBC ................. no
    PostgreSQL ........... no
    SQLite 2 ............. no
    SQLite ............... yes (plugin, using bundled copy)
    TDS .................. no
  tslib .................. no
  udev ................... no
  xkbcommon-x11........... no
  xkbcommon-evdev......... no
  zlib ................... yes (bundled copy)


Qt is now configured for building. Just run 'make'.
Once everything is built, you must run 'make install'.
Qt will be installed into /home/infortech-ubuntu-1404/SAMA5D4/sources/qt/qt-5.6.2/armv7-a

Prior to reconfiguration, make sure you remove any leftovers from
the previous build.
/* log : end */
	然后直接make
	之前用 c++98 编译的,不用再编译,之后未编译的用 c++11 标准继续编译!!
	出错!!
/* log : start */
make[2]:正在离开目录 `/home/infortech-ubuntu-1404/SAMA5D4/sources/qt/qt-5.6.2/qt-everywhere-opensource-src-5.6.2/qtcanvas3d/src'
cd examples/ && ( test -e Makefile || /home/infortech-ubuntu-1404/SAMA5D4/sources/qt/qt-5.6.2/qt-everywhere-opensource-src-5.6.2/qtbase/bin/qmake /home/infortech-ubuntu-1404/SAMA5D4/sources/qt/qt-5.6.2/qt-everywhere-opensource-src-5.6.2/qtcanvas3d/examples/examples.pro -o Makefile ) && make -f Makefile 
make[2]: 正在进入目录 `/home/infortech-ubuntu-1404/SAMA5D4/sources/qt/qt-5.6.2/qt-everywhere-opensource-src-5.6.2/qtcanvas3d/examples'
cd canvas3d/ && ( test -e Makefile || /home/infortech-ubuntu-1404/SAMA5D4/sources/qt/qt-5.6.2/qt-everywhere-opensource-src-5.6.2/qtbase/bin/qmake /home/infortech-ubuntu-1404/SAMA5D4/sources/qt/qt-5.6.2/qt-everywhere-opensource-src-5.6.2/qtcanvas3d/examples/canvas3d/canvas3d.pro -o Makefile ) && make -f Makefile 
make[3]: 正在进入目录 `/home/infortech-ubuntu-1404/SAMA5D4/sources/qt/qt-5.6.2/qt-everywhere-opensource-src-5.6.2/qtcanvas3d/examples/canvas3d'
cd textureandlight/ && ( test -e Makefile || /home/infortech-ubuntu-1404/SAMA5D4/sources/qt/qt-5.6.2/qt-everywhere-opensource-src-5.6.2/qtbase/bin/qmake /home/infortech-ubuntu-1404/SAMA5D4/sources/qt/qt-5.6.2/qt-everywhere-opensource-src-5.6.2/qtcanvas3d/examples/canvas3d/textureandlight/textureandlight.pro -o Makefile ) && make -f Makefile 
Project ERROR: Unknown module(s) in QT: quick
make[3]: *** [sub-textureandlight-make_first] 错误 3
make[3]:正在离开目录 `/home/infortech-ubuntu-1404/SAMA5D4/sources/qt/qt-5.6.2/qt-everywhere-opensource-src-5.6.2/qtcanvas3d/examples/canvas3d'
make[2]: *** [sub-canvas3d-make_first] 错误 2
make[2]:正在离开目录 `/home/infortech-ubuntu-1404/SAMA5D4/sources/qt/qt-5.6.2/qt-everywhere-opensource-src-5.6.2/qtcanvas3d/examples'
make[1]: *** [sub-examples-make_first] 错误 2
make[1]:正在离开目录 `/home/infortech-ubuntu-1404/SAMA5D4/sources/qt/qt-5.6.2/qt-everywhere-opensource-src-5.6.2/qtcanvas3d'
make: *** [module-qtcanvas3d-make_first] 错误 2
/* log : end */
	由于是未知错误,所以,无法追踪出错源头,初步怀疑是之前用C++98 编译的模块 与后面用 C++11 编译的模块 要组合时出错!!!
	make distclean	//把之前所有生成的东西都删掉!!!! 但make distclean 也有出错的!!!	加上 -j8 加快clean速度 
	make confclean	//恢复出厂配置 configure 和 qmake.conf
	
	编译 qtcanvas3d 失败 是因为 使用的 quick 模块 需要 opengl
	网上参考:
		在编译之前，还有个改动，额。。。qt3d和qtcanvas3d在编译的时候会报错，说是未识别模块，
		而且嵌入式的没有opengl，识别了也会报错，导致编译失败，而且编译配置参数里面也没有这两个模块的配置。
		我的解决方法简单粗暴，在配置时参数加-no-opengl，然后打开qt-everywhere-opensource-src-5.7.0/qt.pro文件，找到：
			addModule(qt3d, qtdeclarative qtimageformats)
			addModule(qtcanvas3d, qtdeclarative)
		这两行注释掉（#号注释），或者直接删掉。如果不注释掉，即使加了-no-opengl也会报错，编译失败。
	这就是说跳过 qtcanvas3d qt3d 的意思,如果我坚决要编译的话,就得加入 opengl
	重新./configure:
		./configure -release -opensource -xplatform linux-arm-gnueabi-g++ -prefix /home/infortech-ubuntu-1404/SAMA5D4/sources/qt/qt-5.6.2/armv7-a -c++11 -opengl -qreal float	//添加了opengl项
		出错:
			checking for OpenGL...  no.
			checking for OpenGL ES 2.0...  no.
			All the OpenGL functionality tests failed!
			You might need to modify the include and library search paths by editing
 			QMAKE_INCDIR_OPENGL, QMAKE_LIBDIR_OPENGL and QMAKE_LIBS_OPENGL in
 			/home/infortech-ubuntu-1404/SAMA5D4/sources/qt/qt-5.6.2/qt-everywhere-opensource-src-5.6.2/qtbase/mkspecs/linux-arm-gnueabi-g++.
	网上参考:
		编译安装Qt可能出现的问题及解决办法:
		以下模块，yes的是qt默认安装的。
		Debug ............... no
		Qt 3 compatibility .. yes
		QtDBus module ....... no
		QtScriptTools module  yes
		QtXmlPatterns module  yes
		Phonon module ....... no
		SVG module .......... yes
		WebKit module ....... yes
		STL support ......... yes
		PCH support ......... yes
		MMX/3DNOW/SSE/SSE2..  yes/yes/yes/yes
		Graphics System ..... default
		IPv6 support ........ yes
		IPv6 ifname support . yes
		getaddrinfo support . yes
		getifaddrs support .. yes
		Accessibility ....... yes
		NIS support ......... yes
		CUPS support ........ no
		Iconv support ....... yes
		Glib support ........ yes
		GStreamer support ... no
		Large File support .. yes
		GIF support ......... plugin
		TIFF support ........ plugin (qt)
		JPEG support ........ plugin (system)
		PNG support ......... yes (system)
		MNG support ......... plugin (system)
		zlib support ........ system
		Session management .. yes
		OpenGL support ...... yes (Desktop OpenGL)
		NAS sound support ... no
		XShape support ...... yes
		XSync support ....... yes
		Xinerama support .... runtime
		Xcursor support ..... runtime
		Xfixes support ...... runtime
		Xrandr support ...... runtime
		Xrender support ..... yes
		Xi support .......... runtime
		MIT-SHM support ..... yes
		FontConfig support .. yes
		XKB Support ......... yes
		immodule support .... yes
		GTK theme support ... no
		PostgreSQL support .. plugin
		SQLite 2 support .... plugin
		SQLite support ...... plugin (qt)
		OpenSSL support ..... yes (run-time)
		所以，但我们开始装qt之前没有编译显示no的那些模块，我们可以
		重新编译一次。
		#./configure -phonon
		但这时候，可能会提示以下内容，
		Phonon support cannot be enabled due to functionality tests 
		解决办法：
		先下载必要的包：
		sudo apt-get install libgstreamer0.10-dev libgstreamer-plugins-base0.10-dev
		重新#./configure -phonon
		即可。。。

		如出现
		Basic XLib functionality test failed!
		则先安装libxext-dev
		sudo apt-get install libxext-dev

		mark时出现
		/usr/bin/ld: cannot find -lXext
		则需安装libxt-dev
		sudo apt-get install libxt-dev

		mark时出现
		/usr/bin/ld: cannot find -lXrender
		则需安装libxrender-dev
		sudo apt-get install libxrender-dev

		出现
		X11/extensions/Xdamage.h: No such file or directory
		则安装libxdamage-dev
		sudo apt-get install libxdamage-dev

		About QtOpenGL
		If try -opengl then: All the OpenGL functionality tests failed!
		sudo apt-get install libgl1-mesa-dev libglu1-mesa-dev

		About QtDBus
		If try -dbus then:The QtDBus module cannot be enabled because libdbus-1 version 0.93 was not found
		sudo apt-get install libdbus-1-dev
		sudo apt-get install libedbus-dev

		gconf
		sudo apt-get install libgconf2-dev

		icu
		sudo apt-get install libicu-dev

	因此:先sudo apt-get install libgl1-mesa-dev libglu1-mesa-dev
	然后qtbase/mkspecs/linux-arm-gnueabi-g++/qmake.conf添加:
		QMAKE_INCDIR_OPENGL   = /usr/include/GL
		QMAKE_LIBDIR_OPENGL   = /usr/lib
		QMAKE_LIBS_OPENGL     = -lGLU -lGL	
	依然错误:	All the OpenGL functionality tests failed!
	网上参考:
		如果需要openGL，就需要用 -opengl选项指定opengl的api，对于嵌入式平台，一般使用 opengl ES2，配置选项中加入" -opengl es2 " 。
		不过想使用openGL可能会比较麻烦，因为openGL一般在有硬件图形加速的条件下才能高效运行，而这需要显卡或Soc厂家提供openGL的支持库，
		但并不是所有Soc都能找到对应的支持库，比如三星就没有提供S5PV210的openGL库，所以我这里编译的Qt也是没有opengl的。
		(openGL的替代方案：如果没有厂家提供的硬件图形库，可以考虑使用纯软件实现的opengl，这样的软件库有很多是开源的，如mesa3D库等，
		不过纯软件实现的opengl在效率方面肯定要比带硬件加速的低很多，而且要想在嵌入式平台上使用，必须将opengl的软件库也交叉编译出来，
		我在交叉编译mesa3D时遇到了些问题，所以目前还没能在开发板上用上openGL)；
	还是先放弃 opengl:
		








20170204
昨天编译QT 一直卡在qtcanvas3d编译失败,原因是需要用到opengl模块,但是并没有加载安装使用oepngl 所以试图先跳过qtcanvas与qt3d 
然而按晚上参考的 qt.pro里没有对应项给予更改!!!
不过知道了,虽然卡在了canvas3d上,但是qt的主体部分已经编译完成!!!
所以直接make install 输出生成文件!!!
现在的工作是拷到文件系统里,做测试!!!
由于没有使用nfs 所以,先学习制作 ubi文件系统!!!

以下实验基于yocto项目生成好文件系统镜像展开,并所有实验内容都放在:/home/infortech-ubuntu-1404/SAMA5D4/sources/rootfs/rootfs1 里
解压一个ubi镜像:
网上参考(走运,直接找到sama5d4_xpl的): http://blog.csdn.net/andylao62/article/details/50750404
	sudo apt-get install mtd-utils //安装mtd-utils
	//sama5d4ek or sama5d4_xplained board, the nand flash is different, 
	//so use following line to do the nandsim, change the page size to 4096.
	sudo modprobe nandsim first_id_byte=0x2c second_id_byte=0xdc third_id_byte=0x90 fourth_id_byte=0xa6	
	sudo modprobe ubi mtd=0
	sudo ubidetach /dev/ubi_ctrl -m 0
	sudo ubiformat /dev/mtd0 -s 4096 -f xxxx.ubi 	//2048 改为 4096
	sudo ubiattach /dev/ubi_ctrl -m 0 -O 4096	//2048 改为 4096
	sudo mkdir /mnt/loop
	sudo mount -t ubifs ubi0 /mnt/loop
	sudo cp -R /mnt/loop/* ./xxxfs 		//把内容全部拷到xxxfs文件夹里!! */
	//注意,不同的 nandflash 匹配不同的 nandsim 和 page size 以下nandsim 不是sama5d4开发板所用nandflash对应的nandsim 
要根据自己机器的情况来选择：
modprobe nandsim first_id_byte=0x20 second_id_byte=0x33 - 16MiB, 512 bytes page;
modprobe nandsim first_id_byte=0x20 second_id_byte=0x35 - 32MiB, 512 bytes page;
modprobe nandsim first_id_byte=0x20 second_id_byte=0x36 - 64MiB, 512 bytes page;
modprobe nandsim first_id_byte=0x20 second_id_byte=0x78 - 128MiB, 512 bytes page;
modprobe nandsim first_id_byte=0x20 second_id_byte=0x71 - 256MiB, 512 bytes page;
modprobe nandsim first_id_byte=0x20 second_id_byte=0xa2 third_id_byte=0x00 fourth_id_byte=0x15 - 64MiB, 2048 bytes page;
modprobe nandsim first_id_byte=0xec second_id_byte=0xa1 third_id_byte=0x00 fourth_id_byte=0x15 - 128MiB, 2048 bytes page;
modprobe nandsim first_id_byte=0x20 second_id_byte=0xaa third_id_byte=0x00 fourth_id_byte=0x15 - 256MiB, 2048 bytes page;
modprobe nandsim first_id_byte=0x20 second_id_byte=0xac third_id_byte=0x00 fourth_id_byte=0x15 - 512MiB, 2048 bytes page;
modprobe nandsim first_id_byte=0xec second_id_byte=0xd3 third_id_byte=0x51 fourth_id_byte=0x95 - 1GiB, 2048 bytes page;我昨天解包的时候就是在这里搞错了（我的机器需要4096 bytes page），然后再最后mount的时候老是mount不上，记住这步至关重要！ 5，检查加入模块的环境

附加:解压JFFS2 images
	sudo modprobe nandsim first_id_byte=0x2c second_id_byte=0xda third_id_byte=0x00 fourth_id_byte=0x15
	sudo modprobe mtdblock
	sudo modprobe mtdchar
	sudo modprobe mtd mtd=0
	sudo dd if=xxxxxxxxjffs2 of=/dev/mtd0
	sudo mkdir /mnt/loop
	sudo mount -t jffs2 /dev/mtdblock0 /mnt/loop
	sudo cp -R /mnt/loop/* ./xxxfs	//把内容全部拷到xxxfs文件夹里!! */

然后压缩成一个 ubi 镜像!!!
	//假如现在处于 rootfs1 ,把 rootfs1/minfs 整个文件夹制作成ubi文件系统
	sudo mkfs.ubifs -r /home/infortech-ubuntu-1404/SAMA5D4/sources/rootfs/rootfs1/minfs -m 4KiB -e 248KiB -c 2048 -o minfs.ubifs
	//mkfs.ubifs 制作成 ubifs镜像
	//-r 要制作成镜像的文件夹路径
	//-m nandflash 的 page 大小
	//-e 逻辑擦除块大小 block 大小, 每个物理块有2个4KiB(2个page)是由系统管理不可被用户使用的,所以不可被擦除,所以大小是248KiB,非256KiB
	//-c 有多少个逻辑擦除块
	//-o 生成镜像的名字!!!
	sudo ubinize -o minfs.ubi -m 4KiB -p 256KiB -s 4096 -O 4096 ubinize.cfg
	//mkfs.ubifs 制作成 ubi 二进制镜像
	//-m nandflash 的 page 大小
	//-p 物理块大小(物理块就是 逻辑擦除块 + 由系统管理不可被用户使用的空间)
	//-s 给 ubi文件系统头信息所使用的空间 一般等于一个对应的 nandflash page大小
	//-O 逻辑擦除块 距物理块开始位置的偏移量,一般为一个 由系统管理不可被用户使用的空间
	ubinize.cfg : 配置文件
[rootfs-volume]  
mode=ubi
image=/home/infortech-ubuntu-1404/SAMA5D4/sources/rootfs/rootfs1/minfs.ubifs
vol_id=0
vol_size=520MiB  
vol_type=dynamic
vol_name=min-rootfs
vol_flags=autoresize
	//生成镜像加载失败!!!
	由于知道了 mkfs.ubifs 通过追踪 yocto项目此命令的使用途径就可以跟踪到具体出错处,
	最后挖掘到  成功生成镜像并执行  的命令集!!! (并且是把解压的 ubi文件 重新打包生成镜像执行,说明,解压的方法也是正确的!!)
	sudo mkfs.ubifs -r /home/infortech-ubuntu-1404/SAMA5D4/sources/rootfs/rootfs1/minfs -o minfs.ubifs -e 0x3e000 -c 2082 -m 0x1000 -x lzo
	//-e 0x3e000	即 248KiB 与上面的指令的参数及意义一样
	//-c 2082	2082 表示理论上有2082个逻辑块, 意味着2082个物理块,意味着理论上文件系统应管理的nandflash磁盘空间有520MiB
	//-m 0x1000	即 4KiB 与上面的指令的参数及意义一样	
	//-x lzo	强调 制作成 .ubifs 镜像是 lzo 压缩格式
	sudo ubinize -o minfs.ubi -m 0x1000 -p 0x40000 ubinize.cfg
	//-m 0x1000	即 4KiB 与上面的指令的参数及意义一样	
	//-p 0x40000	即 256KiB 与上面的指令的参数及意义一样
	//此外并没有设置 -s -O 参数,任其自动使用默认值
	ubinize.cfg : 配置文件
[rootfs-volume]		//名字顺便改,不参与内核识别,只便于程序员阅读
mode=ubi
image=/home/infortech-ubuntu-1404/SAMA5D4/sources/rootfs/rootfs1/minfs.ubifs
vol_id=0		//内核会识别
vol_size=480MiB 	//虽然 yocto 工程里面没有,但是这里一定要加入!!
vol_type=dynamic
vol_name=rootfs		//内核会识别ubi文件系统的名称,所以不能乱改,只能是 rootfs 这个名字
vol_flags=autoresize
	//特别注意:vol_size=480MiB 这一项,对比yocto工程发现,yocto工程里对应的ubinize.cfg本身没有这一项!!
	//yocto工程使用工程自带封闭的 mkfs.ubifs 工具来编译生成 ubi文件系统镜像,与我使用的 mkfs.ubifs 工具 可能版本不一样
	//所以yocto工程里对应的ubinize.cfg可以没有这一项,但是我的没有这一项vol_size=.. 使用ubinize时便会报错:
ubinize: volume size was not specified in section "rootfs-volume", assume minimum to fit image "/home/infortech-ubuntu-1404/SAMA5D4/sources/rootfs/rootfs1/minfs.ubifs"6602752 bytes (6.3 MiB)
	//而vol_size=480MiB 的值也有讲究:
	//上面曾设置为: vol_size=520MiB,而 mkfs.ubifs 参数-c 2082 也暗示这个文件系统将可以管理nandflash磁盘空间有520MiB
	//然而加载时出错:
ubi0 error: vtbl_check: too large reserved_pebs 2165, good PEBs 2012
	//这里表示内核运行时会扫描nandflash,会把坏的物理块标记,最后告知,只剩下2012个可用物理快,表明实际可被使用的空间 只有500MiB左右,
	//并没有520MiB那么多, 而且,对于文件系统说,内核 与 bootloader 与 dtb 占据的空间不可访问,
	//所以实际上 文件系统将可以管理nandflash磁盘空间或许只能是480MiB左右,文件系统不可能写入多于这个量的内容到磁盘上
	//所以 vol_size=520MiB 时会出错,提示,磁盘实际上没有这么多空间!!!!!

	成功运行 自己制作的ubi镜像的log信息
/* log : start */
ubi0: attaching mtd7
random: nonblocking pool is initialized
ubi0: scanning is finished
ubi0 warning: print_rsvd_warning: cannot reserve enough PEBs for bad PEB handling, reserved 26, need 36
ubi0: volume 0 ("rootfs") re-sized from 1982 to 1982 LEBs
ubi0: attached mtd7 (name "rootfs", size 504 MiB)
ubi0: PEB size: 262144 bytes (256 KiB), LEB size: 253952 bytes
ubi0: min./max. I/O unit sizes: 4096/4096, sub-page size 4096
ubi0: VID header offset: 4096 (aligned 4096), data offset: 8192
ubi0: good PEBs: 2012, bad PEBs: 4, corrupted PEBs: 0
ubi0: user volume: 1, internal volumes: 1, max. volumes count: 128
ubi0: max/mean erase counter: 1/0, WL threshold: 4096, image sequence number: 1337189846
ubi0: available PEBs: 0, total reserved PEBs: 2012, PEBs reserved for bad PEB handling: 26
ubi0: background thread "ubi_bgt0d" started, PID 662
at91_rtc fc0686b0.rtc: setting system clock to 2017-01-16 21:01:12 UTC (1484600472)
panel-power-supply: disabling
ALSA device list:
  No soundcards found.
UBIFS (ubi0:0): UBIFS: mounted UBI device 0, volume 0, name "rootfs", R/O mode
UBIFS (ubi0:0): LEB size: 253952 bytes (248 KiB), min./max. I/O unit sizes: 4096 bytes/4096 bytes
UBIFS (ubi0:0): FS size: 500793344 bytes (477 MiB, 1972 LEBs), journal size 9404416 bytes (8 MiB, 38 LEBs)
UBIFS (ubi0:0): reserved for root: 0 bytes (0 KiB)
UBIFS (ubi0:0): media format: w4/r0 (latest is w4/r0), UUID 9B79CCE3-363E-40CB-9F39-03BF4EF7F87B, small LPT model
VFS: Mounted root (ubifs filesystem) readonly on device 0:14.
devtmpfs: mounted
Freeing unused kernel memory: 200K (c068c000 - c06be000)
INIT: version 2.88 booting
Starting udev
udevd[692]: starting version 3.1.5
open_ts!
ubi0 error: ubi_open_volume: cannot open device 0, volume 0, error -16
ubi0 error: ubi_open_volume: cannot open device 0, volume 0, error -16
UBIFS (ubi0:0): background thread "ubifs_bgt0_0" started, PID 721
Populating dev cache
/* log : end */

通过学习制作ubi格式文件系统!!更深刻地了解了文件系统的运作!!!
	从 ubi 文件系统来分析!!!
	首先在打包成ubi镜像前的 根文件目录里的内容只不过是普通的文件内容而已,并不是文件系统本身!
	内核完成启动后,就开始访问既定的用户内容了,而这些内容就是我们知道的放在根文件目录里的各项内容,
	内核如何访问和执行这些内容?
		首先,从硬件低层看,文件内容是分割成各个部分 存放在各个 page 和物理块上,
		要有效率地取得内核想要的内容,我们就得及建立关于文件内容在底层硬件里存放的框架协议,例如 ubi 这种框架
		文件内容按照 ubi 这种框架规范,分布存放在磁盘各处,
		而对应地,内核本身就有内置了遵从 ubi 这种规格收集文件内容的api函数,内核就可以方便地访问自己想要的内容了
		就好像,图书按ubi规则放到图书馆每个角落,而相当于人的内核,因为知道书本摆放规则,遵从ubi规则,很快就可以找到书本一样,
		按规则分布摆放在磁盘的内容,磁盘,还有内核内置的遵从规则收集所需内容的api 共同组成的才叫文件系统!!!
	那么文件系统镜像又是什么一回事?
		一般,linux系统,很多重要的功能都不能直接内置到内核里,这样内核会变得很大,根本不能很好维护,甚至工作效率低下,
		于是吧他们制作成文件内容,让内核启动后再访问磁盘找到他们然后执行!!
		如果真有这么一个奇葩,就是喜欢吧所有功能都往内核塞,那么,的确,我们约定俗成的根文件目录里可以什么都没有!!
		正因为,这些文件内容是必须的,又不推荐内置到内核里,所以,这些内容得在内核甚至机子启动之前就放入磁盘里
		文件系统镜像的一部分内容就是,这些必要的文件内容 按照 ubi框架规矩,符合nandflash硬件属性 排布成二进制数据块,
		然后 原封不动地拷到 物理介质nandflash里,
		相当于 有一个按照ubi规则放好图书的大书柜,连柜带书直接搬进图书馆,人可以直接遵从ubi规则,找书.
		当内核启动后,内核就可以去找要找的内容直接执行了!!
		文件系统镜像的另一部分内容,就是关于ubi框架的内容了,
		nandflash空间几百M,然而文件系统镜像可能就几M,以前误认为,可用的磁盘空间等于文件系统镜像的大小,然而并不是这样!!!
		虽然文件系统镜像才几M,但是可用的磁盘空间可以是几百M
		内核启动时,使用ubi框架的文件系统时,会先,根据镜像里的 附加属性信息,把镜像外,属性标明里的其他nandflash空白空间
		也规范成 符合 ubi 框架的 文件管理空间.
		当有新文件写入到机子nandflash时, 内核便会管理分拆成符合ubi框架的数据块,然后分布写入这些空白空间.
		所以总的来说,镜像只有打包了的 已经符合ubi框架的数据块内容,还有一些关于ubi框架的附加信息外,一般并没有操作数据的api内容
		而操作的api一般都直接内置到内核内部,
		内核启动时会检测 镜像究竟是属于那一种 文件内容框架,是ubi的,还是其他,
		然后选择对应规则的api,然后按照规则初始化指定磁盘空间, 然后就可以遵从规则,搜集,读写,操作想要的文件或数据了
	以上是文件系统的通用认识,按转时代,需求不同,有更多新的特性出现!!!有些特性甚至有,有别于以上通识的改动,
	不过文件系统的角色不曾改变!!!









20170206
解压官方demo的ubi!!由于昨日已经解压实验时已做好了一些解压环境配置工作,今天不用重复做
新建 rootfs2文件夹,把工作内容都放进去:
cd /home/infortech-ubuntu-1404/SAMA5D4/sources/rootfs/rootfs2
拷贝 atmel-xplained-demo-image-sama5d4-xplained.ubi 到此文件夹
sudo ubidetach /dev/ubi_ctrl -m 0
sudo ubiformat /dev/mtd0 -s 4096 -f atmel-xplained-demo-image-sama5d4-xplained.ubi
sudo ubiattach /dev/ubi_ctrl -m 0 -O 4096
sudo mount -t ubifs ubi0 /mnt/loop
sudo cp -R /mnt/loop/* ./demofs 	//把所有内容拷到 demofs 文件夹   */
官方 fs 的启动初始化log
/* log : start */
ubi0: attaching mtd7
random: nonblocking pool is initialized
ubi0: scanning is finished
ubi0: attached mtd7 (name "rootfs", size 504 MiB)
ubi0: PEB size: 262144 bytes (256 KiB), LEB size: 253952 bytes
ubi0: min./max. I/O unit sizes: 4096/4096, sub-page size 4096
ubi0: VID header offset: 4096 (aligned 4096), data offset: 8192
ubi0: good PEBs: 2012, bad PEBs: 4, corrupted PEBs: 0
ubi0: user volume: 1, internal volumes: 1, max. volumes count: 128
ubi0: max/mean erase counter: 3/0, WL threshold: 4096, image sequence number: 400630375
ubi0: available PEBs: 0, total reserved PEBs: 2012, PEBs reserved for bad PEB handling: 36
ubi0: background thread "ubi_bgt0d" started, PID 662
....
UBIFS (ubi0:0): recovery needed
UBIFS (ubi0:0): recovery deferred
UBIFS (ubi0:0): UBIFS: mounted UBI device 0, volume 0, name "rootfs", R/O mode
UBIFS (ubi0:0): LEB size: 253952 bytes (248 KiB), min./max. I/O unit sizes: 4096 bytes/4096 bytes
UBIFS (ubi0:0): FS size: 498253824 bytes (475 MiB, 1962 LEBs), journal size 9404416 bytes (8 MiB, 38 LEBs)
UBIFS (ubi0:0): reserved for root: 0 bytes (0 KiB)
UBIFS (ubi0:0): media format: w4/r0 (latest is w4/r0), UUID D094325A-A0E6-490A-8A23-FAC662B80F50, small LPT model
VFS: Mounted root (ubifs filesystem) readonly on device 0:14.
devtmpfs: mounted
Freeing unused kernel memory: 200K (c068c000 - c06be000)
INIT: version 2.88 booting
....
ubi0 error: ubi_open_volume: cannot open device 0, volume 0, error -16
Console: switching to colour frame buffer device 100x30
....
UBIFS (ubi0:0): completing deferred recovery
UBIFS (ubi0:0): background thread "ubifs_bgt0_0" started, PID 780
UBIFS (ubi0:0): deferred recovery completed
/* log : end */

重新压缩官方fs 成ubi镜像!!!!
sudo mkfs.ubifs -r /home/infortech-ubuntu-1404/SAMA5D4/sources/rootfs/rootfs2/demofs -o demofs.ubifs -e 0x3e000 -c 2082 -m 0x1000 -x lzo
sudo ubinize -o demofs.ubi -m 0x1000 -p 0x40000 ubinize.cfg
sudo sam-ba -p serial:ttyACM1:115200 -b sama5d4-xplained -a nandflash -c erase:0x800000:0x1f800000 -c write:demofs.ubi:0x800000
ubinize.cfg : 配置文件
	[rootfs-volume]		//名字顺便改,不参与内核识别,只便于程序员阅读
	mode=ubi
	image=/home/infortech-ubuntu-1404/SAMA5D4/sources/rootfs/rootfs1/minfs.ubifs
	vol_id=0		//内核会识别
	vol_size=480MiB 	//虽然 yocto 工程里面没有,但是这里一定要加入!!
	vol_type=dynamic
	vol_name=rootfs		//内核会识别ubi文件系统的名称,所以不能乱改,只能是 rootfs 这个名字
	vol_flags=autoresize
重新压缩后 启动初始化log:
/* log : start */
ubi0: attaching mtd7
random: nonblocking pool is initialized
ubi0: scanning is finished
ubi0 warning: print_rsvd_warning: cannot reserve enough PEBs for bad PEB handling, reserved 26, need 36
ubi0: volume 0 ("rootfs") re-sized from 1982 to 1982 LEBs
ubi0: attached mtd7 (name "rootfs", size 504 MiB)
ubi0: PEB size: 262144 bytes (256 KiB), LEB size: 253952 bytes
ubi0: min./max. I/O unit sizes: 4096/4096, sub-page size 4096
ubi0: VID header offset: 4096 (aligned 4096), data offset: 8192
ubi0: good PEBs: 2012, bad PEBs: 4, corrupted PEBs: 0
ubi0: user volume: 1, internal volumes: 1, max. volumes count: 128
ubi0: max/mean erase counter: 1/0, WL threshold: 4096, image sequence number: 1392490045
ubi0: available PEBs: 0, total reserved PEBs: 2012, PEBs reserved for bad PEB handling: 26
ubi0: background thread "ubi_bgt0d" started, PID 662
.....
UBIFS (ubi0:0): UBIFS: mounted UBI device 0, volume 0, name "rootfs", R/O mode
UBIFS (ubi0:0): LEB size: 253952 bytes (248 KiB), min./max. I/O unit sizes: 4096 bytes/4096 bytes
UBIFS (ubi0:0): FS size: 500793344 bytes (477 MiB, 1972 LEBs), journal size 9404416 bytes (8 MiB, 38 LEBs)
UBIFS (ubi0:0): reserved for root: 0 bytes (0 KiB)
UBIFS (ubi0:0): media format: w4/r0 (latest is w4/r0), UUID 4F5D1854-E45F-4000-A706-55B47390EA4B, small LPT model
VFS: Mounted root (ubifs filesystem) readonly on device 0:14.
devtmpfs: mounted
.....
ubi0 error: ubi_open_volume: cannot open device 0, volume 0, error -16
/* log : end */

计划移植 QT 和 QT 库到 开发板去!!!
从demo的fs里 没有发现任何关于 gui 等相关的执行程序!!!
所以,不打算使用demofs 来移植qt,因为demofs现有的文件太多,再加上qt库的话,最后压缩的ubi镜像会很大!!!
所以选择移植到 minfs
之前 编译的qt库,虽然仍然卡在qtcanvas而还没有全部编译完,但是,主体库已经完成,可以进行移植:
之前,qt编译后,我设定是把所有编译生成文件都放在 rootfs1/armv7-a
1,
把 rootfs1/armv7-a 文件夹里所有内容 拷到 minfs/opt/qt
修改 minfs 的系统变量: minfs/etc/profile最后添加:
	PATH=$PATH:/sbin:/usr/sbin
	LD_LIBRARY_PATH=/lib:/usr/lib:$LD_LIBRARY_PATH
	export PATH LD_LIBRARY_PATH HOSTNAME USER PS1 LOGNAME HOME
	export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/opt/qt/lib/		//添加qt库文件路径
	export QT_QPA_PLATFORM_PLUGIN_PATH=/opt/qt/plugins/platforms	//qt的平台模式
	export QT_QPA_PLATFORM=linuxfb:tty=/dev/fb0			//显示设备 fb0 即lcd屏
	export QT_QPA_FONTDIR=/opt/qt/lib/fonts  			//字体库
	export QT_QPA_GENERIC_PLUGINS=/dev/input/event0			//输入设备 event0 即触摸屏
	export LD_PRELOAD=/lib/preloadable_libiconv.so			//qt程序需要 libiconv库
2,
QT程序在运行时需要依赖libiconv库
下载：http://ftp.gnu.org/gnu/libiconv/libiconv-1.14.tar.gz
解压并进入对应 libiconv-1.14 目录
编译步骤：
在libiconv目录下：
$./configure --prefix=$PWD/temp --host=arm-linux-gnueabihf   //我们的编译器厂商是 arm-linux-gnueabihf
//参数
//--prefix=$PWD/temp  生成文件放置的目标文件夹
$make
$make install
上述命令执行完成后会在libiconv目录下生成新的temp目录，该目录下存在4个目录分别是：
bin include lib share
在lib目录下为生成的库文件，其中一个为preloadable_libiconv.so，
把它下载到开发板的lib目录下，然后再设置开发板的系统环境变量即可： minfs/etc/profile最后添加:
	export LD_PRELOAD=/lib/preloadable_libiconv.so
最后，开发板执行qt程序时，不会提示 iconv_open failed
3,
sudo mkfs.ubifs -r /home/infortech-ubuntu-1404/SAMA5D4/sources/rootfs/rootfs1/minfs -o demofs.ubifs -e 0x3e000 -c 2082 -m 0x1000 -x lzo
sudo ubinize -o minfs.ubi -m 0x1000 -p 0x40000 ubinize.cfg
sudo sam-ba -p serial:ttyACM1:115200 -b sama5d4-xplained -a nandflash -c erase:0x800000:0x1f800000 -c write:minfs.ubi:0x800000
生产ubi镜像并烧入如开发板
4,
测试,执行 /opt/qt/examples 的qt demo程序测试
后来发现还是缺少各种库,先通过 arm-linux-gnueabihf-readelf -a xxxx|grep "lib" 查找xxxx执行文件的依赖库,
然后把所缺乏的库找到,或者编译好,然后拷到 minfs对应lib文件夹,
最后,
成功执行demo,但是显示界面和触摸屏问题多多!!!
	qtgui与log信息并行使用fb0,导致gui与log消息抢屏现象
	触摸位置不正确!!!
试图移植tslib改善,触摸位置问题!!!
编译安装 git clone 下来的新版本 tslib 並不是使用tslib-1.4
apt-get install autoconf
apt-get install automake
apt-get install libtool
git clone https://github.com/kergoth/tslib
cd tslib
./autogen.sh
echo "ac_cv_func_malloc_0_nonnull=yes" >arm-linux-gnueabihf.cache
./configure --host=arm-linux-gnueabihf --cache-file=arm-linux-gnueabihf.cache --prefix=/home/infortech-ubuntu-1404/SAMA5D4/sources/qt/tslib/tslib/finish
//--prefix 一定要绝对路径!!!
make
//input_raw.c ts_uinput.c 都提示 没有 ABS_MT_TOOL_X, ABS_MT_TOOL_Y
//mt是多点触控的内容
//但是在 input_raw.c 有define
//初步调查发现 这些定义应该在linux/input.h的,但是pc机撒谎嗯的linux/input.h没有
//修改 input_raw.c 和 ts_uinput.c 用input_raw.c上define的 ABS_MT_TOOL_X, ABS_MT_TOOL_Y
make install
把--prefix 路径里的所有内容拷到 minfs/opt/tslib
修改 etc/profile 最后添加:
export TSLIB_ROOT=/opt/tslib
export TSLIB_TSDEVICE=/dev/input/event0
export TSLIB_CONFFILE=$TSLIB_ROOT/etc/ts.conf
export TSLIB_PLUGINDIR=$TSLIB_ROOT/lib/ts
export TSLIB_CALIBFILE=/etc/pointercal
export TSLIB_CONSOLEDEVICE=none
export TSLIB_FBDEVICE=/dev/fb0
PATH=$PATH:/sbin:/usr/sbin:$TSLIB_ROOT/bin/
LD_LIBRARY_PATH=/lib:/usr/lib:$LD_LIBRARY_PATH
export PATH LD_LIBRARY_PATH HOSTNAME USER PS1 LOGNAME HOME
export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$TSLIB_ROOT/lib:/opt/qt/lib/
export QT_QPA_PLATFORM_PLUGIN_PATH=/opt/qt/plugins/platforms
export QT_QPA_PLATFORM=linuxfb:tty=/dev/fb0
export QT_QPA_FONTDIR=/opt/qt/lib/fonts  
export QT_QPA_GENERIC_PLUGINS=tslib:/dev/input/event0
export LD_PRELOAD=/lib/preloadable_libiconv.so
但是失败!!
显示 fopen ts_config 文件not found
使用tslib1.4 重新制作,可以执行,但是 lcd没有显示的情况!!!
readelf 发现 ts_calibrate 的 library_rpath 有问题,是一个固定绝对的路径!!!这个路径对于开发板的文件系统来说据对是错的!!!!
所以,按照以下内容重新编译!!!!










20170207
继续处理tslib问题:
修改uboot 使得lcd不再作为一个console
uboot/include/configs/at91-sama5_common.h:
#define CONFIG_BOOTARGS							\
	"console=tty0 "							\
	"console=ttyS0,115200 earlyprintk "				\
	"mtdparts=atmel_nand:256k(bootstrap)ro,512k(uboot)ro,"		\
	"256K(env),256k(env_redundent),256k(spare),"			\
	"512k(dtb),6M(kernel)ro,-(rootfs) "				\
	"rootfstype=ubifs ubi.mtd=7 root=ubi0:rootfs"
改为:
#define CONFIG_BOOTARGS							\
	"console=ttyS0,115200 earlyprintk "				\
	"mtdparts=atmel_nand:256k(bootstrap)ro,512k(uboot)ro,"		\
	"256K(env),256k(env_redundent),256k(spare),"			\
	"512k(dtb),6M(kernel)ro,-(rootfs) "				\
	"rootfstype=ubifs ubi.mtd=7 root=ubi0:rootfs"
编译
make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf-
烧写:
sudo sam-ba -p serial:ttyACM1:115200 -b sama5d4-xplained -a nandflash -c erase:0x40000:0x80000 -c write:u-boot.bin:0x40000
启动开发板:
发现,已经没有作为console的大部分输出,但是还是有 please wait 和闪烁的命令字符光标.说现在的lcd屏作为 tty1 设备
执行qt demo 完美显示,但是 触摸屏错位,不能正确控制!!!!
另外通过,arm-linux-gnueabihf-readelf -a ts_calibrate|grep "lib"查看依赖库时,发现 library_rpath 涉及--prefix 的绝对路径
自然之前的编译移植tslib的方法自然不对!!!
由于我们要把生成的文件放到开发板的 /opt/tslib 里,所以--prefix设置成pc机的 /opt/tslib
./autogen.sh
echo "ac_cv_func_malloc_0_nonnull=yes" >arm-linux-gnueabihf.cache
./configure --host=arm-linux-gnueabihf --cache-file=arm-linux-gnueabihf.cache --prefix=/opt/tslib
make
make install
然后把pc上/opt/tslib里所有东西拷到 minfs/opt/tslib里,
设置 minfs/etc/profile
export TSLIB_ROOT=/opt/tslib
export TSLIB_TSDEVICE=/dev/input/event0
export TSLIB_CONFFILE=$TSLIB_ROOT/etc/ts.conf
export TSLIB_PLUGINDIR=$TSLIB_ROOT/lib/ts
export TSLIB_CALIBFILE=/etc/pointercal
export TSLIB_CONSOLEDEVICE=none
export TSLIB_FBDEVICE=/dev/fb0

PATH=$PATH:/sbin:/usr/sbin:$TSLIB_ROOT/bin/
LD_LIBRARY_PATH=/lib:/usr/lib:$LD_LIBRARY_PATH
export PATH LD_LIBRARY_PATH HOSTNAME USER PS1 LOGNAME HOME
export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$TSLIB_ROOT/lib:/opt/qt/lib/
export QT_QPA_PLATFORM_PLUGIN_PATH=/opt/qt/plugins/platforms
export QT_QPA_PLATFORM=linuxfb:tty=/dev/fb0
export QT_QPA_FONTDIR=/opt/qt/lib/fonts  
export QT_QPA_GENERIC_PLUGINS=tslib:/dev/input/event0
export LD_PRELOAD=/lib/preloadable_libiconv.so
设置 minfs/opt/tslib/etc/ts.conf
# Uncomment if you wish to use the linux input layer event interface
module_raw input
.......
重新编译,烧写,
还是出现相同错误,串口端表示成功执行,但是lcd没有任何显示!!
后来发现yocto 工程里下了个 tslib1.1版,
同样方法移植tslib1.1
成功lcd显示和执行,但是,触摸屏出现严重的误差问题!!!!








20170208
检查触摸屏的问题!!!
先修改触摸屏的压力值统一为 2000:
at91_adc.c:at91_ts_sample()
	if (pres < st->ts_pressure_threshold) {
		//by william  (set intergrate pressure)  设置统一的压力值!!!!
		if(pres < 500)		//当笔尖离开触摸屏,即要发生key_up事件,要求压力值pres值等于0 来提示触犯key_up事件
			pres = 0;
		else
			pres = 2000;	//注意 有pres时,表示一直处于key_down 我们统一压力值2000

		dev_dbg(&idev->dev, "x = %d, y = %d, pressure = %d\n",
					x, y, pres / factor);
		input_report_abs(st->ts_input, ABS_X, x);
		input_report_abs(st->ts_input, ABS_Y, y);
		input_report_abs(st->ts_input, ABS_PRESSURE, pres);
		input_report_key(st->ts_input, BTN_TOUCH, 1);
		input_sync(st->ts_input);
	} else {
		dev_dbg(&idev->dev, "pressure too low: not reporting\n");
重现编译内核,烧写!!!
make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf-
sudo sam-ba -p serial:ttyACM1:115200 -b sama5d4-xplained -a nandflash -c erase:0x200000:0x600000 -c write:zImage:0x200000
经检测发现:
关于 key_up key_down 的事件是 又input_event来判断的 !!
report pres = 2000 和 BTN_TOUCH 1 后 input_event 识别为key_down事件
report pres = 0 和 BTN_TOUCH 0 后 input_event 识别为key_up事件
key_up与key_down事件并不是 由at91_adc.c本身来生成的,而是由input_event 识别生成的!!!
触摸屏不可能只有key_up事件而没有key_down事件!!
所以把pres只设定为一个值,是不正确的,应该按上面的根据情况起码设置两个值!0和某值!!
但是这种改法还是不好,
不是每一次手离开触摸屏时,芯片能及时采样到一个pres低于500 的压力值,
于是 pres = 2000 和 BTN_TOUCH 0 report到 input_event ,input_event 并不能分析是处于key_up抑或是key_down事件,
虽然把今次事件强制认为是key_up事件,但会把这种奇怪的情况记录下来,
这是如果ctrl+c结束ts_test,再重新启动ts_test后,因为保存上次奇怪情况,而不在后续不能正常地分析触摸事件
所以,要压力值统一为 2000:的最佳做法!!
at91_adc.c:at91_ts_sample()
	if (pres < st->ts_pressure_threshold) {
		//by william  (set intergrate pressure)  设置统一的压力值!!!!
		pres = 2000;	//我们统一压力值2000

		dev_dbg(&idev->dev, "x = %d, y = %d, pressure = %d\n",
					x, y, pres / factor);
		input_report_abs(st->ts_input, ABS_X, x);
		input_report_abs(st->ts_input, ABS_Y, y);
		input_report_abs(st->ts_input, ABS_PRESSURE, pres);
		input_report_key(st->ts_input, BTN_TOUCH, 1);
		input_sync(st->ts_input);
	} else {
		dev_dbg(&idev->dev, "pressure too low: not reporting\n");
而
at91_adc.c:irqreturn_t at91_adc_9x5_interrupt()

	} else if (status & AT91_ADC_IER_NOPEN) {

		//by william
		pr_debug("nopen\n");	//表示笔尖离开触摸屏

		at91_adc_writel(st, st->registers->trigger_register, 0);
		at91_adc_writel(st, AT91_ADC_IDR, AT91_ADC_IER_NOPEN |
			ts_data_irq_mask);
		at91_adc_writel(st, AT91_ADC_IER, AT91_ADC_IER_PEN);

		//by william	
		input_report_abs(st->ts_input, ABS_PRESSURE, 0);	//report BRN_TOUCH 0 之前,多加一步 report pres 0

		input_report_key(st->ts_input, BTN_TOUCH, 0);
		input_sync(st->ts_input);
	} 

使用一个节衷的方法解决了触摸屏的跳屏问题!!!
观察到,触摸屏的第一次采样几乎是正确的!!! 而第一次采样是 采样开关开始后的第一次采样!!!
于是,我们可以频繁打开关闭采样开关,只为取第一次采样,于是 at91_adc.c 修改如下:
at91_adc.c:at91_ts_sample()
........
	/* calculate the pressure */
	reg = at91_adc_readl(st, AT91_ADC_TSPRESSR);

	//by william
	at91_adc_writel(st, AT91_ADC_IDR, (AT91_ADC_IER_XRDY |AT91_ADC_IER_YRDY | AT91_ADC_IER_PRDY));
.......
	//by william
	//ndelay(10000);
	at91_adc_readl(st, AT91_ADC_TSXPOSR);	//清空x y pres寄存器!!
	at91_adc_readl(st, AT91_ADC_TSYPOSR);
	at91_adc_readl(st, AT91_ADC_TSPRESSR);				
	at91_adc_writel(st, AT91_ADC_IER, (AT91_ADC_IER_XRDY |AT91_ADC_IER_YRDY | AT91_ADC_IER_PRDY));

	return 0;
}
从中还挖出几个重点!!!
1,irq pen_detect后会修改 中断触发开关,先关闭pen_detect 并开启开启开关
2,当 累计 x,y,pres 3个采样都就绪时,才在at91_ts_sample 一次性读出采样!!
3,当第一次采样完成后会,把采样结果放到对应寄存器,触发中断,然后不管中断函数中什么时候读取采样结果,就已经开始下一次采样了
  如果第二次采样也结束了,但第一次采样结果还没有读出,第二次的结果并不会写入寄存器,第三次采样不会开始,
  也就说,第一次结果被读出,第二次的结果就可以马上写入寄存器,然后开始第三次采样!!!
4,所以以上改动中,清空x y pres 寄存器操作非常重要!!!
5,虽然我们在读取第一次结果前(或者后) 关闭采样开关,但是已经无法停下已经执行的第二次采样!!,
  第二次采样的结果会在在第一次的结果被读出后迅速刷入寄存器,第二次结果是错误的,
  关闭采样开关,虽然不能阻止第二次结果刷入寄存器,但不会诱发第二次采样完成的中断函数!!!
  这时的寄存器是放置了数据的!!
6,假如我们你清空寄存器,就打开采样开关,硬件因为检测到寄存器有数据,并不开始重新采样便触发了中断,让用户读出上次未读出的错误数据
7,如果先清空了寄存器再 打开采样开关,这样,硬件就会重新采样,再写入寄存器!!
  儿这次采样就是正确率较高的 打开采样后的第一次采样!!!!
最后,
跳屏现象很有规律, 是跳屏采样点在 实际采样点与原点的线性关系上的点!!
认识到,跳屏,可能真的是由于采样频率过密而诱发的电压跳变误差造成!!!
所以,正途是重新修改 adc_clk 等一系列采样时间参数!!

此外,当采样数据送到 寄存器时, ISR对应位会起flag,读取ISR清flag!!
读取ISR清flag后如果没有及时读出 寄存器里的采样数据, 寄存器里的采样数据并不会丢失,而ISR对应位会重新起flag!!
这样就可以同时筹齐 x y pres 三个采样flag后,再一次性 ts_sample 读取三个寄存器的数据!!!

调节采样时间!!!!!!
	ADC_TRGR TRGPER: Trigger Period : 
		AT91_ADC_TRGR_TRGPER_(x)	((x) << 16)
		AT91_ADC_TRGR_TRGPER_(st->ts_sample_period_val)
		Trigger Period = (TRGPER + 1) / ADCCLK
		st->ts_sample_period_val = round_up((TOUCH_SAMPLE_PERIOD_US * adc_clk_khz / 1000) - 1, 1);
		adc_clk_khz = adc_clk / 1000
	ADC_TSMR:
		TSAV: Touchscreen Average 3: AVG8CONV : Averages 8 ADC conversions
		PENDBC: Pen Detect Debouncing Period
			Debouncing period = (2^PENDBC) / ADCCLK periods.
			st->ts_pendbc = round_up(TOUCH_PEN_DETECT_DEBOUNCE_US * adc_clk_khz / 1000, 1);
			adc_clk_khz = adc_clk / 1000











20170209
尝试修改 adc 的时钟来得到处理采样问题!!
追踪修改 adc_clk !!
sama5d4.dtsi
	periph32ck {
		compatible = "atmel,at91sam9x5-clk-peripheral";
		.....
		adc_clk: adc_clk {
			#clock-cells = <0>;
			reg = <44>;
		};

drivers/clk/at91/pmc.c:346:		.compatible = "atmel,at91sam9x5-clk-peripheral",
	........
	{
		.compatible = "atmel,at91sam9x5-clk-peripheral",
		.data = of_at91sam9x5_clk_periph_setup,
	},

drivers/clk/at91/clk-peripheral.c:414:void __init of_at91sam9x5_clk_periph_setup(struct device_node *np,
void __init of_at91sam9x5_clk_periph_setup(struct device_node *np,
					   struct at91_pmc *pmc)
{
	of_at91_clk_periph_setup(np, pmc, PERIPHERAL_AT91SAM9X5);
}
of_at91_clk_periph_setup(np, pmc, PERIPHERAL_AT91SAM9X5);
	for_each_child_of_node(np, periphclknp) {
		of_property_read_u32(periphclknp, "reg", &id)
		...
...跟丢了
但是后来发现 dts 的 adc_clk 与 at91_adc.c里的 st->adc_clk 不是同一回事,
而 dts 的 adc_op_clk 与 at91_adc.c里的 st->adc_clk 才是同一回事,
at91_adc.c: at91_adc_probe()
	mstrclk = clk_get_rate(st->clk);
	adc_clk = clk_get_rate(st->adc_clk);
	adc_clk_khz = adc_clk / 1000;

第二种改法
本来
mstrclk = 100000000
adc_clk = 1000000
adc_clk_hhz = 1000
当改成 
mstrclk = 1000000
adc_clk = 1000000
adc_clk_hhz = 1000
居然采样也正常采样了,但是采样的时间周期太长,因为mstrclk太小!!!!

本来
tsmr:TRGPER = 1999
改为 2499 ,没用!!
改成 2999 ,没用!!
改成 999, 更加没戏!!

本来
tsmr:TRACKTIM = 10
改为 15 ,没用!!
改成 20 ,没用!!

本来
tsmr:TSFREQ: = 3
改为 5 ,成功!!!!!!!!!
改成 4 ,没用!!

并没有设置 TSSCTIM:

累计使用三个方法改,但是结果都是,触摸的延时严重!!! 
1,频繁开关 采样中断
2,改 mstrclk
3,改 tsmr:TSFREQ

补充,关于 adc clk 的一些知识点!!!!
关于 adc的时钟 有两个
	st->clk = devm_clk_get(&pdev->dev, "adc_clk");
	st->adc_clk = devm_clk_get(&pdev->dev, "adc_op_clk");
st->clk 即 dts 的 adc_clk :
st->adc_clk 即 dts 的 adc_op_clk :
st->clk.rate = mstrclk =100000000
st->adc_clk.rate = adc_clk = 1000000
这两个数据都是从 dts里得到的!!!!
然后我们来看 dts 这里的内容:
/ {
	model = "Atmel SAMA5D4 family SoC";
	compatible = "atmel,sama5d4";
	interrupt-parent = <&aic>;

	ahb {
		compatible = "simple-bus";
		#address-cells = <1>;
		#size-cells = <1>;
		ranges;

		apb {
			compatible = "simple-bus";
			#address-cells = <1>;
			#size-cells = <1>;
			ranges;

			adc0: adc@fc034000 {
				compatible = "atmel,at91sam9x5-adc";
				/* 相当于platform_device 里的 IORESOURCE_MEM 类型 resource */
				reg = <0xfc034000 0x100>;
				/* 相当于platform_device 里的 IORESOURCE_IRQ 类型 resource 这里 */
				interrupts = <44 IRQ_TYPE_LEVEL_HIGH 5>;
				clocks = <&adc_clk>,
					 <&adc_op_clk>;
				clock-names = "adc_clk", "adc_op_clk";
				.........
以上是引用 "adc_clk", "adc_op_clk" 的位置 !!

/ {
	model = "Atmel SAMA5D4 family SoC";
	compatible = "atmel,sama5d4";
	interrupt-parent = <&aic>;
	clocks {
		adc_op_clk: adc_op_clk{
			compatible = "fixed-clock";
			#clock-cells = <0>;
			clock-frequency = <1000000>;
		};
		.........
以上是 "adc_op_clk", 的定义位置 !!
在这里 就已经找到 adc_op_clk 的 参数,即 st->adc_clk.rate = clock-frequency = 1000000

/ {
	model = "Atmel SAMA5D4 family SoC";
	compatible = "atmel,sama5d4";
	interrupt-parent = <&aic>;

	ahb {
		compatible = "simple-bus";
		#address-cells = <1>;
		#size-cells = <1>;
		ranges;

		apb {
			compatible = "simple-bus";
			#address-cells = <1>;
			#size-cells = <1>;
			ranges;

			pmc: pmc@f0018000 {
				compatible = "atmel,sama5d3-pmc", "syscon";
				reg = <0xf0018000 0x120>;
				interrupts = <1 IRQ_TYPE_LEVEL_HIGH 7>;
				interrupt-controller;
				#address-cells = <1>;
				#size-cells = <0>;
				#interrupt-cells = <1>;

				periph32ck {
					compatible = "atmel,at91sam9x5-clk-peripheral";
					#address-cells = <1>;
					#size-cells = <0>;
					clocks = <&h32ck>;

					adc_clk: adc_clk {
						#clock-cells = <0>;
						reg = <44>;	//其实就是 pmc 里的 PID 44
					};
				.........
以上是 "adc_clk", 的定义位置 !!
但是,还没有找到 adc_clk 的 参数 即st->clk.rate 的位置
发现 adc_clk 的clock,又隶属于 &h32ck 节点,则:

/ {
	model = "Atmel SAMA5D4 family SoC";
	compatible = "atmel,sama5d4";
	interrupt-parent = <&aic>;

	ahb {
		compatible = "simple-bus";
		#address-cells = <1>;
		#size-cells = <1>;
		ranges;

		apb {
			compatible = "simple-bus";
			#address-cells = <1>;
			#size-cells = <1>;
			ranges;

			pmc: pmc@f0018000 {
				compatible = "atmel,sama5d3-pmc", "syscon";
				reg = <0xf0018000 0x120>;
				interrupts = <1 IRQ_TYPE_LEVEL_HIGH 7>;
				interrupt-controller;
				#address-cells = <1>;
				#size-cells = <0>;
				#interrupt-cells = <1>;

				h32ck: h32mxck {
					#clock-cells = <0>;
					compatible = "atmel,sama5d4-clk-h32mx";
					clocks = <&mck>;
				};
以上是 "h32ck", 的定义位置 !!上面又说了,它自己的 clock又属于 &mck 则:

/ {
	model = "Atmel SAMA5D4 family SoC";
	compatible = "atmel,sama5d4";
	interrupt-parent = <&aic>;

	ahb {
		compatible = "simple-bus";
		#address-cells = <1>;
		#size-cells = <1>;
		ranges;

		apb {
			compatible = "simple-bus";
			#address-cells = <1>;
			#size-cells = <1>;
			ranges;

			pmc: pmc@f0018000 {
				compatible = "atmel,sama5d3-pmc", "syscon";
				reg = <0xf0018000 0x120>;
				interrupts = <1 IRQ_TYPE_LEVEL_HIGH 7>;
				interrupt-controller;
				#address-cells = <1>;
				#size-cells = <0>;
				#interrupt-cells = <1>;

				mck: masterck {
					compatible = "atmel,at91sam9x5-clk-master";
					#clock-cells = <0>;
					interrupt-parent = <&pmc>;
					interrupts = <AT91_PMC_MCKRDY>;
					clocks = <&clk32k>, <&main>, <&plladiv>, <&utmi>;
					atmel,clk-output-range = <125000000 200000000>;
					atmel,clk-divisors = <1 2 4 3>;
				};
				.......
以上是 "mck", 的定义位置 !!上面又说了,它自己的 clock 需要 <&clk32k>, <&main>, <&plladiv>, <&utmi> 一起参与, 则:
由于我们早知道st->clk.rate = mstrclk =100000000 而参数 100000000 就是 <&main>节点里参数!!

		............
		apb {
			compatible = "simple-bus";
			#address-cells = <1>;
			#size-cells = <1>;
			ranges;

			pmc: pmc@f0018000 {
				compatible = "atmel,sama5d3-pmc", "syscon";
				reg = <0xf0018000 0x120>;
				interrupts = <1 IRQ_TYPE_LEVEL_HIGH 7>;
				interrupt-controller;
				#address-cells = <1>;
				#size-cells = <0>;
				#interrupt-cells = <1>;

				main: mainck {
					compatible = "atmel,at91sam9x5-clk-main";
					#clock-cells = <0>;
					interrupt-parent = <&pmc>;
					interrupts = <AT91_PMC_MOSCSELS>;
					clocks = <&main_rc_osc &main_osc>;
				};
				........
以上是 "main", 的定义位置 !!上面又说了,它自己的 clock需要 <&main_rc_osc &main_osc> 参与,看情况, 则:

		............
		apb {
			compatible = "simple-bus";
			#address-cells = <1>;
			#size-cells = <1>;
			ranges;

			pmc: pmc@f0018000 {
				compatible = "atmel,sama5d3-pmc", "syscon";
				reg = <0xf0018000 0x120>;
				interrupts = <1 IRQ_TYPE_LEVEL_HIGH 7>;
				interrupt-controller;
				#address-cells = <1>;
				#size-cells = <0>;
				#interrupt-cells = <1>;

				main_rc_osc: main_rc_osc {
					compatible = "atmel,at91sam9x5-clk-main-rc-osc";
					#clock-cells = <0>;
					interrupt-parent = <&pmc>;
					interrupts = <AT91_PMC_MOSCRCS>;
					clock-frequency = <12000000>;
					clock-accuracy = <100000000>;
				};

				main_osc: main_osc {
					compatible = "atmel,at91rm9200-clk-main-osc";
					#clock-cells = <0>;
					interrupt-parent = <&pmc>;
					interrupts = <AT91_PMC_MOSCS>;
					clocks = <&main_xtal>;
				};
以上是 "main_rc_osc"和 "main_osc", 的定义位置 !!上面又说了,最终其实就是 main_rc_osc节点里的, 就不讨论main_osc 了
main_rc_osc 就是 "adc_clk" clock的最终使用参数的所在地!!
clock-frequency = <12000000>;	表示输入供main_rc_osc使用的clock频率 单位hz
clock-accuracy = <100000000>;	表示main_rc_osc 输出的clock频率 单位hz
而在这里 就已经找到 adc_clk 的 参数,即 st->adc_clk.rate = clock-accuracy = 100000000

触摸屏幕校对 ts_calibrate 只要多校对几次就好了!!









20170210
移植 window-manager 和 软键盘
软键盘 首选 syszuxpinyin 然而只是下载了源码,大概搜集了做法,却未实现
window-manager 先选 X-window 但是网上移植的教程不多
最后想到,还不如做 移植一个 ubuntu 的文件系统,里面就附带 window-manager
于是开始移植 ubuntu 文件系统!!
几经波折,居然勉强把ubuntu15 的文件系统给挂上!!!,但是容易死机,特便是 cloud-init什么初始化失败,login 时就死机!!
以下是一些移植 ubuntu 文件系统的 参考网页
https://www.ibm.com/developerworks/linux/tutorials/l-ubuntu/
http://blog.csdn.net/embbnux/article/details/12751465
http://www.arm9home.net/read.php?tid-81429.html
http://blog.csdn.net/kickxxx/article/details/15341079
http://cdimage.ubuntu.com/ubuntu-core/vivid/daily-preinstalled/20170104/
https://www.embbnux.com/category/embedded_linux/
http://cdimage.ubuntu.com/ubuntu-base/releases/12.04.4/release/









20170215
内核启动后,挂载根文件系统后的初始化有两种方式
1,传统的 System V initialization 需要先查询 /etc/inittab 文件, 
  init进程启动后第一时间找的就是inittab 文件！inittab负责初始化系统，设置系统runlevel及进 入各runlevel对应要执行的命令。
  假设当前inittab中设置的默认runlevle是5，则init会运行/etc/init.d/rc 5命令，该命令会依据系统服务的依赖关系遍历执行/etc/rc5.d中的脚本/程序。
  进入/etc/rc5.d目录可以发现里面的文件都是到/etc /init.d/下对应的脚本/程序的软链接。
  以S开头的为启动的意思，以K开头的为停止。并且S/K后面的两位数数字代表了服务的启动顺序（由服务依赖关系决定）
  传统的 System V initialization 是以 runlevel 为核心的,依据服务依赖关系初始化
  传统的 System V initialization 一般包含的主要文件有
  /etc/inittab
  /etc/init.d
  /etc/rc0.d
  /etc/rc1.d
  /etc/rc2.d
  /etc/rc3.d
  /etc/rc4.d
  /etc/rc5.d
  /etc/rc6.d
  /etc/rcS.d
2,新的方式是 Upstart job 模式!!
  就是事件驱动,才初始化启动对应的服务功能,严格上说只使用到 /etc/init 里的文件!!
  Upstart job 模式 把 分配 runlevel 也当做是一种事件!!
然而, ubuntu 使用的是合拼型的启动方式!!
ubuntu 的 /etc/init 有以下几个重点文件!!
rc.conf			//rc-sysinit在startup事件发生时被启动
rc-sysinit.conf		//rc在系统runlevel变化时被启动
rcS.conf		//rcS在系统runlevel为S时启动
ubuntu使用的合拼启动模式是,把 System V initialization 的后动当做是一个事件, 用Upstart init 来启动这个事件
在配置文件的注释中说明了，这几个文件，正是Upstart init处理System V-style服务的关键。
文件系统挂载后,startup 启动,然后启动 rc-sysinit.conf ,设置runlevel,然后转到 rc.conf 执行:
exec /etc/init.d/rc $RUNLEVEL  转到了对应的 /etc/rcx.d 开始对应内容的执行!! 即转到了 System V initialization 的内容!!

网上参考:(ubuntu初始化)
启动时会首先执行/etc/init目录中配置文件
配置文件中可以设置启动的时机与顺序，start on startup,start on runlevel [1234],stop on [!3453]
一般的Linux分8个级别:0-6和一个'S'级别。
	0代表关机(halt)，
	6代表重启(restart)；
	1-5分别是不同功能的级别，其中1级别是单用户模式(single)，2-5各有不同。但是在userlinux(包括ubuntu)中2-5级别是毫无差别的。
	最后'S'级别是一个比较特殊的级别，他应该是先于其他级别运行的级别。(这一点有待考证)。
	这里说明一下，0-6级别的运行是互斥的，而不是叠加运行，
	也就是说如果进入(move into)4级别，不是指0-3都要运行，而只是完成4级别里所规定的服务。
所有的运行服务的脚本存储在/etc/init.d/里面。而在/etc/中有rc'X'.d的文件夹，'X'代表0-6和S，也就对应了这8个启动级别，
	里面就都是指向/etc/init.d/里面运行服务的脚本的软连接(symbol link)，
会发现，软连接的数目少于运行脚本数，这就是说不是所有服务都要在一个级别中运行的。软连接的命名是有规则的：
	[K|S][0-90-9][name]，K代表kill，S代表start，后面是个二位数，最后是对应的运行服务的脚本文件名。
	这个name是在运行相应的脚本的时候传递的参数，
	K是传递stop(就是关闭服务),S是传递start(就是启动服务)，
	运行顺序：K小数->K大数->S小数->S大数。这里注意文件夹里的所有软连接都会被执行，
rc'x'.d里面的软连接是由/etc/init/rc.conf调用的 ("x"不包括S)
rcS.d里面的软连接是由/etc/init/rc.conf调用的
rcS.conf		//rcS在系统runlevel为S时启动
在ubuntu中，可以使用update-rc.d命令去维护rc，语法为：sudo update-rc.d servicename defaults 

然而发现 ubuntu12 符合以上ubuntu启动方式, 不可以启动,但是 ubuntu15不符合以上方式,不可启动!!

嵌入式桌面系统架构; gnome 和 kde 而真正的gui是建立在这些架构上的软件!!

简单的嵌入式桌面系统 qt-extended (旧时代手机桌面,已不再维护)
重点记录!!!
在configure时!!出错!!
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/qt-extended/qte1/build-pc$ echo yes | ../qt-extended-4.4.3/configure -ui-type home -release -clean -sound-system alsa -build-qt -no-sxe -no-ssl -no-v4l2 -no-vpn -no-phonon -no-libamr -mediaengines cruxus -remove-mediaengine gstreamer,helix -pictureflow -remove-module bluetooth,drm -no-dbus -no-dbusipc -add-displaysize 480x272 -extra-qt-embedded-config "-qt-freetype -no-webkit -no-dbus -qt-gfx-transformed -qt-gfx-linuxfb" -extra-qt-config "-no-webkit" 
/* log start */
perl: warning: Setting locale failed.
perl: warning: Please check that your locale settings:
	LANGUAGE = "”en_US”",
	LC_ALL = (unset),
	LC_CTYPE = "”en_US”",
	LANG = "”en_US”"
    are supported and installed on your system.
perl: warning: Falling back to the standard locale ("C").
perl: warning: Setting locale failed.
perl: warning: Please check that your locale settings:
	LANGUAGE = "”en_US”",
	LC_ALL = (unset),
	LC_CTYPE = "”en_US”",
	LANG = "”en_US”"
    are supported and installed on your system.
perl: warning: Falling back to the standard locale ("C").

This is the Qt Extended Open Source Edition.

You are licensed to use this software under the terms of the GPL.
Please see the file LICENSE.GPL for the licensing terms.

Type 'yes' to accept this license offer.
Type 'no' to decline this license offer.

Do you accept this license agreement? 
Testing the system Qt: OK (bootstrap only)
Found Qt 4.8 while expecting Qt 4.4.
Qt Extended will build Qt from source.
Qt Extended is using the following locations:
Qt          SOURCE tree = /home/infortech-ubuntu-1404/SAMA5D4/sources/qt-extended/qte1/qt-extended-4.4.3/qtopiacore/qt
Qt          BUILD  tree = /home/infortech-ubuntu-1404/SAMA5D4/sources/qt-extended/qte1/build-pc/qtopiacore/host
Qt Embedded SOURCE tree = /home/infortech-ubuntu-1404/SAMA5D4/sources/qt-extended/qte1/qt-extended-4.4.3/qtopiacore/qt
Qt Embedded BUILD  tree = /home/infortech-ubuntu-1404/SAMA5D4/sources/qt-extended/qte1/build-pc/qtopiacore/target
Qt Extended SOURCE tree = /home/infortech-ubuntu-1404/SAMA5D4/sources/qt-extended/qte1/qt-extended-4.4.3
Qt Extended BUILD  tree = /home/infortech-ubuntu-1404/SAMA5D4/sources/qt-extended/qte1/build-pc
Qt Extended SDK    tree = /home/infortech-ubuntu-1404/SAMA5D4/sources/qt-extended/qte1/build-pc/sdk

Checking the compiler (host): OK (GCC 4, Little Endian)
Checking the compiler (target): OK (GCC 4, Little Endian)
Bootstrap QBuild: .. FAIL
In file included from ../../../qt-extended-4.4.3/qbuild/src/main.cpp:37:0:
../../../qt-extended-4.4.3/qbuild/src/options.h: In constructor 'Options::Options()':
../../../qt-extended-4.4.3/qbuild/src/options.h:52:22: error: call of overloaded 'QString(int)' is ambiguous  //错误处
           traceFile(0) {}
                      ^
../../../qt-extended-4.4.3/qbuild/src/options.h:52:22: note: candidates are:
In file included from /usr/include/qt4/QtCore/QString:1:0,
                 from ../../../qt-extended-4.4.3/qbuild/src/qfastdir.h:23,
                 from ../../../qt-extended-4.4.3/qbuild/src/main.cpp:21:
/usr/include/qt4/QtCore/qstring.h:421:43: note: QString::QString(const QByteArray&)
     inline QT_ASCII_CAST_WARN_CONSTRUCTOR QString(const QByteArray &a)
                                           ^
/usr/include/qt4/QtCore/qstring.h:419:43: note: QString::QString(const char*)
     inline QT_ASCII_CAST_WARN_CONSTRUCTOR QString(const char *ch) : d(fromAscii_helper(ch))
                                           ^
/usr/include/qt4/QtCore/qstring.h:725:8: note: QString::QString(const QString&)
 inline QString::QString(const QString &other) : d(other.d)
        ^
/usr/include/qt4/QtCore/qstring.h:89:5: note: QString::QString(QChar)
     QString(QChar c);
     ^
/usr/include/qt4/QtCore/qstring.h:88:14: note: QString::QString(const QChar*)
     explicit QString(const QChar *unicode); // Qt5: merge with the above
              ^
../../../qt-extended-4.4.3/qbuild/src/main.cpp: In function 'void createProject()':
../../../qt-extended-4.4.3/qbuild/src/main.cpp:49:33: warning: ignoring return value of 'int chdir(const char*)', declared with attribute warn_unused_result [-Wunused-result]
         ::chdir(pwd.constData());
                                 ^
make[1]: *** [main.o] Error 1
/* log end */
初步认为是冲突了 网上都说要把 QT creator 删掉, 实际上不止,应该把不知道什么时候装在pc上的qt4删掉或暂时屏蔽掉路径
还是失败,原来还是需要寻找QT库的,但是显然qt-extended4.4.3与pc机上的qt库版本冲突了!!
(所以搁置 qt-etended 的移植!!)

移植 minigui
(待续)










20170216
架设 ssh 登陆 远程电脑:
安装
	sudo apt-get install openssh-client
	sudo apt-get install openssh-server
启动ssh服务：
	sudo /etc/init.d/ssh start
停止ssh服务：
	sudo /etc/init.d/ssh stop
重启ssh服务：
	sudo /etc/init.d/ssh restart
然后确认sshserver是否启动了：（或用“netstat -tlp”命令)
	ps -e | grep ssh


申请免费域名并挂到路由器DNS
暴露pc主机的dmz 到公网
设置端口转送
ssh配置:
ssh -NfR 2284:localhost:22 infortechubuntu1404-HP-EliteDesk-880-G2-TWR@16r6d01795.iask.in  // ??反向代理
ssh -gNfR *:2222:localhost:22 root@16r6d01795.iask.in	//  ??或这样设置?
(未成功)!!









20170217
重新尝试 buildroot,事实上,发现,buildroot更适合,构造根文件系统和arm-gcc,g++ 编译工具!!
不推荐使用提供的sh脚本来烧录镜像!!因为,有很多与之前研究中不一样的配置和操作!!所以推荐手动烧录文件系统镜像到机器
编译记录:
使用之前 git clone 下来的 buildroot 即 buildroot1
先 make distclean
然后 make atmel_sama5d4_xplained_mmc_defconfig	做初步配置
然后 make menuconfig 修改配置!!!
	Target option 里的 默认不变
	Build option 里的 蓦然不变
	System configuration 里的 默认不变
	kernel 取消不选
	bootloader 取消不选
	Target package 根文件系统里预装的内容
		添加QT5的图形库!!
		Graphic libraries and applications (graphic/text)  --->  ->  [*] Qt5  --->
		--- Qt5       
		-*-   qt5base            
		[ ]     Approve free license    
		()      Config file         
		[*]     Compile and install examples (with code) 	//一定要examples 检验图像库是否移植成功!!
		[ ]     concurrent module       
		[ ]     MySQL Plugin          
		[ ]     PostgreSQL Plugin              
			SQLite 3 support (No sqlite support)  ---> 
		[*]     gui module            
		[*]       widgets module             
			  *** OpenGL support needs an OpenGL-capable backend ***  
		-*-       linuxfb support            
		          *** directfb backend available if directfb is enabled ***    
		          *** X.org XCB backend available if X.org is enabled ***   
			  *** eglfs backend available if OpenGL and EGL are enabled ***    
		(linuxfb) Default graphical platform  
		[*]       fontconfig support    
		[*]       GIF support            
		[*]       JPEG support          
		[*]       PNG support           
		[*]     DBus module             
		[*]     Enable ICU support       
		[*]     Enable Tslib support  
		......
	Filesystem images 根文件系统的镜像格式选取!!
		在这里我们要添加ubi选项,让根文件系统添加这个格式的镜像
		[*] ubifs root filesystem
		(0x3e000) logical eraseblock size	//逻辑擦除块大小 248kiB
		(0x1000) minimum I/O unit size 		//page的大小 4kiB
		(2082) maximum logical eraseblock count  //逻辑擦除块数量
		ubifs runtime compression (lzo)  ---> 	 //压缩格式 lzo
		Compression method (no compression)  ---> 
		()    Additional mkfs.ubifs options  
		[*]   Embed into an UBI image    	//生成 .ubi镜像
		(0x40000) physical eraseblock size  	//物理块大小 256kiB
		(4096)  sub-page size             	//page的大小 4kiB
	Toolchain  编译工具链,其实就是整套 arn-linux-gcc 工具链,
		注意,一定要把里面的功能全部使能,不然得到的 的工具链功能是有缺陷的,而且中途不能通过重新编译添加未添加的功能,
		只能把整套删掉 make distclean 然后再重新生成一整套!!
		我们这次用到的工具链的版本配置信息!!!
		Toolchain type (Buildroot toolchain)  ---> //使用Buildroot toolchain 即,自动下载gcc工具链源码包编译
							   //而 External toolchain 就是说使用已有的,用户现成的 gcc 工具包,即不用重新编译
		 *** Toolchain Buildroot Options ***		
	(buildroot) custom toolchain vendor name
		C library (glibc)  --->			   //这套gcc工具 使用 glibc库
		*** Kernel Header Options *** 
		Kernel Headers (Linux 4.1.x kernel headers)  ---> //是说明这套gcc是专门面向kernel4.1?
								  //还是说这套gcc是拥有kernel4,1的特征?? 
		glibc version (2.23)  ---> 		  //这套gcc工具 使用的 glibc库 版本!!
		*** Binutils Options ***
		Binutils Version (binutils 2.26.1)  --->  //这套gcc工具 使用的 binutils 版本!!
	    ()  Additional binutils options 
		*** GCC Options ***
		GCC compiler Version (gcc 4.8.x)  --->  
	    ()  Additional gcc options   
	    //添加这套gcc工具 的其他功能,使之成为完整的的一套工具!!!
	    [*] Enable C++ support   			
	    [*] Enable Fortran support 
	    [*] Enable compiler link-time-optimization support       
	    [*] Enable compiler OpenMP support    
	    [*] Enable libmudflap support 
	    [*] Enable graphite support  
		*** Host GDB Options ***  
	    [*] Build cross gdb for the host  
	    [*]   TUI support 
	    [*]   Python support     
	    [*]   Simulator support 
		  GDB debugger Version (gdb 7.10.x)  --->   
		*** Toolchain Generic Options *** 
	    [ ] Copy gconv libraries  
	    [*] Enable MMU support  
	    ()  Target Optimizations  
	    ()  Target linker options  
	    [ ] Register toolchain within Eclipse Buildroot plug-in                                                            │ │  

配置完就 make -j8 进行编译
	再次注意:如果 本来的toolchain里不包含Enable C++ support 那么得到的 gcc工具包里就没有 arm-linux-gnueabihf-g++,
	所以当builroot 编译rootfs要加入qt5的内容,会因为中找不到g++来编译cpp文件而出现以下错误,	 
	configure: error: You need a C++ compiler for C++ support  ubuntu
	这时,中途 make menuconfig 重新选上 Enable C++ support ,然后重新 make -j8并不会让toolchain 自动添加 arm-linux-gnueabihf-g++ 这个工具
	唯一办法是,把toolchain生成的全删后,重新 make -j8
编译成功好后:
buildroot/output/build 里是下载下来的函数库或者工具包的源码以及编译后的文件
buildroot/output/host/usr 里的是 生成的一整套完整 arm-linux-gcc 工具链, 可以直接拷出来自己使用!!
buildroot/output/images 里的是生成的镜像文件!!! 由于我们只使用buildroot构造文件系统,所以只有 rootfs相关的各个镜像,并没有zImage等其他镜像
buildroot/output/target 未打包成镜像前的根文件目录的内容!!
烧录:
cd到images
sudo sam-ba -p serial:ttyACM1:115200 -b sama5d4-xplained -a nandflash -c erase:0x800000:0x1f800000 -c write:rootfs.ubi:0x800000
开机,成功加载系统!!!
测试ts_test,ts_calibrate, qt-example 成功!!
但是,qt-example的的触摸屏按键 依然出现 翻转错位现象
此外文件系统加载时,并没有自动初始化网络:
使用命令:
udhcpc 初始化网络!!
此外,想知道,qt程序是如何运用tslib的,所以希望查找 /etc/profile文件来查看qt配置!!
什么也没有发现!!
没有 TSLIB_**, QT_QPA_** 一类环境变量,grep搜索,没发现相关的配置文件,
却发现在内嵌在 libqt***.so.65.6.2XXX 之类的库文件里!! 
检查 tslib 与 qt图形库的关系,发现 qt图形库直接使用event0 压根没有使用tslib!!!
但是 grep 发现 qtbase 编译前的configure 是有添加 -tslib 选项的!!!











20170220
追查qt5.6.2 与 tslib1.1 的联系 
(注意只是从 buildroot 里制作的根文件系统做的实验,未知其他根文件系统会是怎么样!!!)
先把 buildroot生成的 rootfs 文件目录,拷贝到 rootfs3
使用组合命令 编译成 rootfs.ubi 镜像
sudo mkfs.ubifs -r /home/infortech-ubuntu-1404/SAMA5D4/sources/rootfs/rootfs2/demofs -o demofs.ubifs -e 0x3e000 -c 2082 -m 0x1000 -x lzo
sudo ubinize -o demofs.ubi -m 0x1000 -p 0x40000 ubinize.cfg
sudo sam-ba -p serial:ttyACM1:115200 -b sama5d4-xplained -a nandflash -c erase:0x800000:0x1f800000 -c write:demofs.ubi:0x800000
烧录后,却被告知说 不能打开 /dev/console permittion denyed  
经过一番折腾发现,buildroot 生成的 rootfs 目录全部文件都被赋予了只读权限,
因此在 生成ubi镜像前,先把文件的所有权限开放
sudo chmod 777 rootfs/*			//  开发所有文件的权限 */
然后烧录运行正常!!
关于QT触摸屏错位的改正!!
直接怀疑 QT库并没有使用 tslib !!
发现profile内容没有 常规移植QT和tslib时要添加的 路径变量,所以怀疑 tslib 和 QT 一直在使用默认环境变量!!
于是 profile 末尾加上一项
export QT_QPA_GENERIC_PLUGINS=tslib
//注意,不是 export QT_QPA_GENERIC_PLUGINS=tslib:/dev/input/event0
// :号 表示,要么使用tslib修正过的触摸屏设备,要么直接使用原生触摸屏设备
//为了避免 QT5 可能直接使用原生设备, 所以不要加入/dev/input/event0!!!!
执行 QT5 examples/widgets/desktop/screenshot 里的例程时,出现了 ts_open() faired with error (no such file or dictionary ) 
执行 QT5 examples/widgets/touch/fingerpaint 里的例程时,也出现了 ts_open() faired with error (no such file or dictionary ) 
这时因为要使用tslib修正过的触摸屏设备,就得使用tslib的 api ts_open
而 ts_open 要打开原生触摸屏设备,但是我们没有给出 这个设备的环境变量,所以要在 profile 加上
export TSLIB_TSDEVICE=/dev/input/event0
然后 screenshot 成功了!!!! 成功用上了 tslib矫正的触摸屏,但是出现一个新问题,按键并不是特别灵光!!
而 fingerpaint 虽然没有提示 ts_open() faired with error 但是似乎没有 用上矫正过的触摸屏,而还是用原生的,
QT 用原生出现的问题具体是 x轴正常, y轴是中点反对称地出现!!!

也就是虽然可以使用上 tslib 了 但是还有很多问题:
animation/easing 滑动条不能滑动!只能跳着过 没有tslib前可以拖着滑动!!
但是animation/states 可以拖动!!
按键不灵光
touch/fingerpaint(绘图) 好像没用上tslib
touch/dials(数字旋表,就像汽车转速表) 好像没用上tslib
qpa/windows 好像用上了,但是出现跳屏!!!

修改profile删掉
export QT_QPA_GENERIC_PLUGINS=tslib
export TSLIB_TSDEVICE=/dev/input/event0
只添加:
export QT_QPA_GENERIC_PLUGINS=tslib:/dev/input/event0
效果一样!!!










20170221
字符显示!!
(注意只是从 buildroot 里制作的根文件系统做的实验,未知其他根文件系统会是怎么样!!!)
之前的测试一直没有字符显示!!!
按网上方法!!
把pc机的 /usr/share/fonts/truetype/dejavu 文件夹拷到开发板的 /usr/share/fonts/dejavu
然后 开发板profile添加!!
export QT_QPA_FONTDIR=/usr/share/fonts/dejavu
(补充,未实现!!)
关于中文字符的显示,据搜索说是要,添加 /usr/share/fonts/truetype/arphic 然后,profile做同样修改!!
研究屏幕键盘!!!
安装 qtcreator4.2 ,及配置环境 
官网下载 qt-creator-opensource-linux-x86_64-4.2.0.run 安装包
直接指令安装 ./qt-creator-opensource-linux-x86_64-4.2.0.run
安装后,就要配置qtcreator的编译选项:工具tools -> build and run窗口
先配置 QT Version
	先了解qt的编译工作流程!!!例如我要编译一个面向 armmv7-a 的窗口程序,用到 qt5.6 的库
	首先,我使用 面向armv7-a 的 qt5.6 的 qmake 工具 编译这个窗口程序工程的.pro配置文件!!! 最后生成 指定Makefile
	然后, 使用makefile 编译出真正的执行文件
	QT Version配置,我们需要使用 哪个版本,面向那种机器的qt库, 我们就把他对应的qmake工具加进来!!
	我们添加了 面向armv7-a 的 qt5.6 的 qmake 工具
	然而报错说我们 缺乏指定的编译器!!
配置 编译器
	上述 面向armv7-a 的 qt5.6 的 qmake 工具 就指明了 他生成的 makefile 是使用我们之前指定的 arm-linux-gnueabihf-gcc 系列工具
	来编译成 执行文件 的, 所以我们要把 arm-linux-gnueabihf-gcc 系列工具 添加到这里来,
	分别独立添加 对应 gcc 和 g++
	然后回到 QT Version 发现刚刚添加的 面向armv7-a 的 qt5.6 的 qmake 工具 不再报错!!
配置 DEbuggers
	arm-linux-gnueabihf-gcc 系列工具 也有gdb 调试工具, 但是不会用,加不加无所谓
配置CMake
	不用管
构建套件(kit)
	不使用 QT creator 时,要生成一个窗口可执行文件,我们需要使用多条编译指令,使用多个编译器
	但是配置成一个套件后,使用 QT creator 生成一个窗口可执行文件,只是一个按键的事情,
	这里要用到的工具捆绑在一起
	添加一个套件:
	名称自选
	设备类型, 对于嵌入式触摸屏设备,推荐使用 桌面就可以,选择通用linux设备,需要自己定义一台设备,相当麻烦!!
	Sysroot 不管
	编译器C 选刚刚加入的 arm-linux-gnueabihf-gcc
	编译器C++ 选刚刚加入的 arm-linux-gnueabihf-g++
	调试器 选刚刚加入的 arm-linux-gnueabihf-gdb
	QT版本 选QT5.6.2 这是刚刚加的 qmake 识别出来的QT版本
配置好,弄个例程编译试试: example里的 screenshot
注意,要在项目那检查工程配置
	选择新构建的套件:
	它的qmake 里编译用到的 qmake命令
	它的make 里编译用到的 make 命令
编译时注意:
由于是使用arm架构的gcc编译工具,所以,并不能在pc机上做debug 所以,只需要按 build 按钮就好了,
最后烧录到开发板,测试通过!!!!

移植屏幕键盘到开发板!!
现实










20170222
搞好ssh 远程桌面!!!
重启ssh服务：
	sudo /etc/init.d/ssh restart
然后确认sshserver是否启动了：（或用“netstat -tlp”命令)
	ps -e | grep ssh

简单局域网相连:
ssh -X root@200.200.200.102	// 
sudo ssh -X 200.200.200.102	//这两条命令作用相同,都是登陆到 ip为200.200.200.102的pc机 的root用户!!
sudo ssh -X infortech-ubuntu-1404@200.200.200.102 //
sudo ssh -X infortech-ubuntu-1404@200.200.200.102 //这两条命令作用相同,都是登陆到 ip为200.200.200.102的pc机 的infortech-ubuntu-1404用户!!
出错:
Permission denied, please try again. 
解决:
要修改 ip为200.200.200.102的pc机 的root的ssh权限，即修改 /etc/ssh/sshd_config文件中
	PermitRootLogin no 改为 PermitRootLogin yes 
此外, -X 表示窗口界面,不是命令行终端,但没有成功使用窗口登陆!!

拷贝文件操作!!
kingders@kingders-ThinkPad-T420:~$ scp ./安川电机/report infortech-ubuntu-1404@200.200.200.102:./桌面
//把 本机的/home/kingders/安川电机/report 文件   拷贝到   ip为200.200.200.102的pc机的/home/infortech-ubuntu-1404/桌面 文件夹 去
kingders@kingders-ThinkPad-T420:~$ scp infortech-ubuntu-1404@200.200.200.102:./桌面/temp_20170117 ./Desktop
//把 ip为200.200.200.102的pc机的/home/infortech-ubuntu-1404/桌面/temp_20170117 文件   拷贝到   本机的/home/kingders/Desktop 文件夹 去 

挂载远程硬盘(未完待续)

最后还是脱离了ssh 使用上了基于vnc 的远程桌面
sudo apt-get install xrdp //安装 xrdp 多了一个 Desktop Sharing Preferences 的选项框
这样就装上了两款软件!!!
Desktop Sharing /桌面共享
Remmina Remote Desktop Client / Remmina远程桌面客户端!!
被远程控制的机子 在 桌面共享 里 选允许其他人查看/控制您的桌面,安全 不选"进行访问确认"
要远程控制的机子 打开 Remmina远程桌面客户端 新建->协议是VNC虚拟网络计算->填写:
	被远程控制的机子的ip
	其他的可以都不填(不知道为啥)
然后就可以connect过去了

还有一个更加傻瓜的方法就是使用 teamviewer
另外,安装google远程桌面 和 teamviewer 时 注入了一个bug 会启动 deja-dup-monitor 无限吃内存!!!卡死机器!!!
鉴于 deja-dup-monitor 并没有啥用 直接 重命名 让bug读取不到!!!
罪魁祸首还是 google-chrome, 删掉就好了!!!

最后关于 ubuntu 两种软件安装方式  apt-get 和 .deb包!!
主要用到apt-get dpkg两个命令：
1. 快速使用
安装软件 apt-get install softname1 softname2 softname3……
卸载软件 apt-get remove softname1 softname2 softname3……
卸载并清除配置 apt-get remove --purge softname1
更新软件信息数据库 apt-get update
进行系统升级 apt-get upgrade
搜索软件包 apt-cache search softname1 softname2 softname3……
修正（依赖关系）安装：apt-get -f install

安装deb软件包 dpkg -i xxx.deb
删除软件包 dpkg -r xxx		//不需要写deb包全名 xxx_版本_架构.deb
连同配置文件一起删除 dpkg -r --purge xxx.deb
查看软件包信息 dpkg -info xxx.deb
查看文件拷贝详情 dpkg -L xxx.deb
查看系统中已安装软件包信息 dpkg -l
重新配置软件包 dpkg-reconfigure xx
sudo dpkg -p package_name卸载软件包及其配置文件，但无法解决依赖关系！
sudo aptitude purge pkgname卸载软件包及其配置文件与依赖关系包！ 
清除所有已删除包的残馀配置文件
dpkg -l |grep ^rc|awk '{print $2}' |sudo xargs dpkg -P
如果报如下错误，证明你的系统中没有残留配置文件了，无须担心。








20170224
移植 摄像头!! 
首先,分别使用ov7670 和 ov3640 两款摄像头
使用两种协议工作: 
	ISI:传输图像数据
	I2C:控制摄像头
涉及文件 atmel-isi.c ov2640.c ov7670.c
采集原理:
	cmos硬件采集 -> isi协议传输数据 -> V4L2中间库 -> 应用程序
总的说,	ov2640.c是i2c从设备, 
	atmel-isi.c是isi的平台设备,
	那么对应ov2670的isi从设备是哪一个,难道 ov2640.c兼顾?
	make ARCH=arm menuconfig 里关于 isi i2c ov2640 v4l2 该选的都选上了 
纠错:上述热时错误是,直接把 xxx平台设备等同于 XXX协议总线!!!
	xxx平台设备是挂在 平台总线 上的一个设备而已,虽然大多数平台设备都可以操作硬件寄存器
	以一个例子为例
		i2c-core.c是 构成i2c协议总线
		i2c-at91.c是 挂载在 platform协议总线 上的i2c控制器驱动设备
		i2c协议总线 与 platform总线协议 本质上是同阶级的 都是抽象出来的总线
		i2c-at91.c(i2c控制器设备) 会给 i2c协议总线 一个接口,
		xxxx.c是 挂载在 i2c协议总线 上的 i2c从设备,
		操作 i2c从设备时,归根到底还是操作 主芯片i2c控制器,
		i2c从设备 通过 i2c协议总线 上公开的i2c控制器接口, 实现控制i2c控制器从而实现i2c从设备的功能!!!

dts的examples 写法也疑惑: 注意,以下是 ,txt的例子,并非.dts里的实例
设置isi的!!
Example: isi: isi@f0034000 { compatible = "atmel,at91sam9g45-isi";
		reg = <0xf0034000 0x4000>;
		interrupts = <37 IRQ_TYPE_LEVEL_HIGH 5>;
		clocks = <&isi_clk>;
		clock-names = "isi_clk";
		pinctrl-names = "default";
		pinctrl-0 = <&pinctrl_isi>;
		port { 
			#address-cells = <1>;
			#size-cells = <0>;
			isi_0: endpoint { 
				remote-endpoint = <&ov2640_0>;
				bus-width = <8>; 
			}; 
		}; 
	};
	i2c1: i2c@f0018000 { ov2640: camera@0x30 { compatible = "ovti,ov2640";
			reg = <0x30>;
			port { 
				ov2640_0: endpoint { 
					remote-endpoint = <&isi_0>;
					bus-width = <8>; 
					}; 
				}; 
			}; 
		}; 
设置ov2670的!!
Example:
	i2c1: i2c@f0018000 { 
		ov2640: camera@0x30 { 
			compatible = "ovti,ov2640";
			reg = <0x30>;
			pinctrl-names = "default";
			pinctrl-0 = <&pinctrl_pck1 &pinctrl_ov2640_pwdn &pinctrl_ov2640_resetb>;
			resetb-gpios = <&pioE 24 GPIO_ACTIVE_LOW>;
			pwdn-gpios = <&pioE 29 GPIO_ACTIVE_HIGH>;
			clocks = <&pck1>;
			clock-names = "xvclk";
			assigned-clocks = <&pck1>;
			assigned-clock-rates = <25000000>;
			port { 
				ov2640_0: endpoint { 
					remote-endpoint = <&isi_0>;
					bus-width = <8>; 	//v4l2_of_parse_parallel_bus //重点,从获得的endpoint中的提取设置信息,
				}; 				//video-interfaces.txt //设置信息参考文件!!!
			}; 
		}; 
	}; 

简阅atmel-isi.c 
isi_clk = isi->pclk	//分清两个时钟
iscclk = isi->iscck
probe:
atmel_isi_parse_dt() //分析endpoint的内容 其实就是把isi协议的所有设置上的内容!!
	v4l2_of_parse_parallel_bus //重点,从获得的endpoint中的提取设置信息,
	video-interfaces.txt //设置信息参考文件!!!
申请dma framebuffer 缓存
申请irq
soc_camera_host_register //
分析发现驱动中, isc层是直接控制硬件的, isc接入isi层,isi层又是与v4l2层接轨的
而 isi 对应着 soc_camera 这层内容!!! //可以参考gpio_keys的做法









20170227
RGB 格式直接显示的, 
YCbCu 是编码的格式,使用于压缩MP4格式的文件
ov7670 cmos芯片的针脚!
	pclk: 像素输出时钟! 是由ov芯片输出的时钟 
	D0-7: 图像并排数据针
	xclk: 提供ov芯片运行的时钟信号脚 典型是 24Mhz
	scl: i2c时钟针
	sda: i2c数据针
	vsync: 帧起始信号
	href: 行起始信号
	reset: 重置针 ,正常状态下高电平 低电平触发
	pwdn: power down 针
就是说,除了 isi 和i2c 的接口外 还要自己定义 pwdn reset xclk针!!
pwdn reset 两gpio功能针的配置,要另外使用dts 自己做一个pinctrl出来!!//可以参考 at91-sama5d4_xplaint.dts gpio_keys的做法
xclk 输出时钟针的配置!! 		//xclk即 datasheet的 isi_mck 即 Programmable Clock output 1(PCK1)
xclk 指 pc4 或pc24 或pd31	//没有参考设置输出时钟的!!的例子
想起到 www.at91.com 找 camera
居然还真找到!!!我去, github 的linux源码里 有一个 at91-sama5d4ek_isi.dts 直接就是ov2640模块的!!

ov2640的针口配置:
	并口数据针共10位 D0-D9,但是我们只使用8位,默认是 D2-D9 对应sama5d4 的 isi_D0 - isi_D7

sama5d4对应的针口:
	AT91_PIOC 19 AT91_PERIPH_A AT91_PINCTRL_NONE	/* ISI_D0 */
	AT91_PIOC 20 AT91_PERIPH_A AT91_PINCTRL_NONE	/* ISI_D1 */
	AT91_PIOC 21 AT91_PERIPH_A AT91_PINCTRL_NONE	/* ISI_D2 */
	AT91_PIOC 22 AT91_PERIPH_A AT91_PINCTRL_NONE	/* ISI_D3 */
	AT91_PIOC 23 AT91_PERIPH_A AT91_PINCTRL_NONE	/* ISI_D4 */
	AT91_PIOC 24 AT91_PERIPH_A AT91_PINCTRL_NONE	/* ISI_D5 */
	AT91_PIOC 25 AT91_PERIPH_A AT91_PINCTRL_NONE	/* ISI_D6 */
	AT91_PIOC 26 AT91_PERIPH_A AT91_PINCTRL_NONE	/* ISI_D7 */
	AT91_PIOB  1 AT91_PERIPH_C AT91_PINCTRL_NONE	/* ISI_PCK, conflict with G0_RXCK */
	AT91_PIOB  3 AT91_PERIPH_C AT91_PINCTRL_NONE	/* ISI_VSYNC */
	AT91_PIOB  4 AT91_PERIPH_C AT91_PINCTRL_NONE	/* ISI_HSYNC */
	AT91_PIOA 30 AT91_PERIPH_A AT91_PINCTRL_NONE	/* TWD0 */
	AT91_PIOA 31 AT91_PERIPH_A AT91_PINCTRL_NONE	/* TWCK0 */
	AT91_PIOC  4 AT91_PERIPH_C AT91_PINCTRL_NONE	/* PC4 periph C ISI_MCK */ 与sd卡复用了 所以要disable mmc0
	AT91_PIOB  5 AT91_PERIPH_GPIO AT91_PINCTRL_NONE /* PB5 power down */
	AT91_PIOB 11 AT91_PERIPH_GPIO AT91_PINCTRL_NONE	/* PB11 reset */ 







20170228
加载摄像头功能: (修改内核)
修改dts,给at91-sama5d4_xplained.dts插入,以下相关内容!!
/ {
	ahb {
		apb {
			pinctrl@fc06a000 {
				board {
					pinctrl_pck1_as_isi_mck: pck1_as_isi_mck-0 {
						atmel,pins =
							<AT91_PIOC  4 AT91_PERIPH_C AT91_PINCTRL_NONE>; /* PC4 periph C ISI_MCK */
					};

					pinctrl_sensor_power: sensor_power {
						atmel,pins =
							<AT91_PIOB  5 AT91_PERIPH_GPIO AT91_PINCTRL_NONE>; /* PB5 gpio */
					};

					pinctrl_sensor_reset: sensor_reset {
						atmel,pins =
							<AT91_PIOB 11 AT91_PERIPH_GPIO AT91_PINCTRL_NONE>; /* PB11 gpio */
					};
				};
			};
		};
	};
};

&usart2 {
	status = "disabled";
};

&spi0 {
	status = "disabled";
};

&mmc00 {
	status = "disabled";
};

&isi {
	status = "okay";

	port {
		isi_0: endpoint@0 {
			remote-endpoint = <&ov2640_0>;
			bus-width = <8>;
			vsync-active = <1>;
			hsync-active = <1>;
		};
	};
};

&i2c0 {
	status =""
	ov2640: camera@0x30 {
		compatible = "ovti,ov2640";
		reg = <0x30>;
		pinctrl-names = "default";
		pinctrl-0 = <&pinctrl_pck1_as_isi_mck &pinctrl_sensor_power &pinctrl_sensor_reset>;
		resetb-gpios = <&pioB 11 GPIO_ACTIVE_LOW>;
		pwdn-gpios = <&pioB 5 GPIO_ACTIVE_HIGH>;
		/* use pck1 for the master clock of ov2640 */
		clocks = <&pck1>;
		clock-names = "xvclk";
		assigned-clocks = <&pck1>;
		assigned-clock-rates = <25000000>;

		port {
			ov2640_0: endpoint {
				remote-endpoint = <&isi_0>;
				bus-width = <8>;
			};
		};
	};
};
menuconfig:添加
select the menu: "Device Drivers -> Multimedia support -> Sensors used on soc_camera driver -> ov2640 camera support"
select the menu: "Device Drivers -> Multimedia support -> Media Controller API"
select the menu: "Device Drivers -> Multimedia support -> V4L2 sub-device userspace API"
select the menu: "Device Drivers -> Multimedia support -> Autoselect ancillary drivers (tuners, sensors, i2c, 
另外,如果要选择老版本摄像头芯片,例如 ov7670 等
	deselect the menu: "Device Drivers -> Multimedia support -> Autoselect ancillary drivers (tuners, sensors, i2c, 
	find in the menu: "Device Drivers -> Multimedia support -> Encoders, decoders, sensors and other helper chips ->其他xxx芯片"
添加 pr_debug 到 atmel-isi.c 和 ov2640.c 调试!!! //参考之前的操作!!!
编译 缮写
make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- 
sudo sam-ba -p serial:ttyACM1:115200 -b sama5d4-xplained -a nandflash -c erase:0x200000:0x600000 -c erase:0x180000:0x80000 -c write:at91-sama5d4_xplained.dtb:0x180000 -c write:zImage:0x200000
开机,如果发现以下log内容,可以初步认为驱动已经成功运行了!!!
soc-camera-pdrv soc-camera-pdrv.0: Probing soc-camera-pdrv.0
ov2640 0-0030: ov2640 Product ID 26:42 Manufacturer ID 7f:a2
i2c i2c-0: OV2640 Probed

在尝试采集图片之前,先尝试显示jpg图片!!
先处理好网络功能!!
udhcpc 初始化网络环境
关于 tftp 传输文件的命令!!(在开发板上使用的 规范写法)
	tftp -g 200.200.200.102 -r ./aaa -l ./bbb	//取得ip200.200.200.102的tftp服务器路径下的aaa文件,拷贝到当前文件夹并改名为bbb
							//如果当前文件夹已存在 bbb 文件,则替换他!!!
	tftp -p 200.200.200.102 -r ./ccc -l ./ddd	//把当前文件夹的 ddd 文件,上传到ip200.200.200.102的tftp服务器路径上
							//直接替换掉 服务器上的 ccc 文件,
							//如果服务器本身没有 ccc 文件,那么命令就会出错不工作!!
那么我们把得到的图片回放上来就可以了!!!
然后,使用 atmel推荐的 fswebcam,最简单做法:使用 buildroot1 给文件系统添加这个内->置内容
make menuconfig 添加:
	Target packages -> Graphic libraries and applications (graphic/text) -> fswebcam
make -j8
测试命令:
fswebcam -S 20 -d /dev/video0 -p RGB565 -r 640x480 uio.jpg	//跳过开头20帧采样,在当前文件夹得到uio.jpg图片文件!!
tftp回电脑 成功显示!!!

下一步,移植 ov7670 到新架构!!!!!









20170301
移植 ov7670 到新架构
ov7670 和 ov2640 的reset 和 pwdn 针的控制方式一致
reset: 低电平触发,平时处于高电平
pwdn: 高电平触发 平时处于低电平
ov7670 和 ov2640 的 i2c协议控制参数一致
关于 ov7670 和 ov2640 的区别:
ov7670 30万像素,
ov2640 200万像素,
ov7670 控制的寄存器在同一个块里
ov2640 控制的寄存器分成两个块,sensor块 和 DSP块, 要范文相关控制寄存器,要先设置寄存器所处的块!!!
还有能支持的编码格式:
	都不一样,还有的是,ov7670多了 一个叫 matrix
	注意移植修改重点 ov2640_enum_mbus_code() -> ov7670_enum_mbus_code()
		忽略掉 matrix 的调整!!
		ov7670_supported_win_sizes 的内容及后续内容没有改!!!!!!!关于7670的采样格式规范问题!!!
			ov7670_get_fmt的 MEDIA_BUS_FMT 内容....

无意发现 出厂id与pdf 不一样!!
ov2640的 datasheet 是 26 41 7f a2  芯片读出的是 26 42 7f a2
ov7670的 datasheet 是 76 73 7f a2  芯片读出的是 87 87 87 87
还有真正的 i2c地址 与 datsheet 里的 i2c地址 也不一样!!
ov2640的 datasheet 是 0x60 芯片使用的是 0x30
ov7670的 datasheet 是 0x42 芯片使用的是 
使用ov7670时,发现出现了i2c不能访问的现象!!! 读出的pid和mid 都是87
ov7670的i2c并没有工作!!!
	一开始是怀疑地址 不对 因为出现了 nack
	后来地址改过来了,发现好像时钟也不对 ,出现了 control timed out
	两款芯片的i2c datasheet参数一样,所以跟i2c时钟没有问题
	最后发现 芯片可写,但不可读!!!读寄存器时,直接出错!!!









20170303
先搁置驱动移植细节,先做好移植架构!!
at91-sama5d4_xplained.dts i2c添加:
			isi: isi@f0008000 {
				status = "okay";
				port {
					isi_1: endpoint@1 {
						remote-endpoint = <&ov7670_0>;
						bus-width = <8>;
						vsync-active = <1>;
						hsync-active = <1>;
					};
				};
			};
			i2c0: i2c@f8014000 {
				status = "okay";
				/* have to set clock-frequency, otherwise use default-scl 100khz */
				clock-frequency = <100000>;	
				/* by william about ov7670 */
				ov7670: camera@0x21 {
					compatible = "ovti,ov7670";
					/* ov7670 i2c 8bits-addr 0x42w 0x43r 7bits-addr 0x21 */
					reg = <0x21>;	
					pinctrl-names = "default";
					pinctrl-0 = <&pinctrl_pck1_as_isi_mck &pinctrl_sensor_power &pinctrl_sensor_reset>;
					resetb-gpios = <&pioB 11 GPIO_ACTIVE_LOW>;
					pwdn-gpios = <&pioB 5 GPIO_ACTIVE_HIGH>;
					/* use pck1 for the master clock of ov2640 */
					clocks = <&pck1>;
					clock-names = "xvclk";
					assigned-clocks = <&pck1>;
					/* assigned-clock-rates = <25000000>; */
					assigned-clock-rates = <24000000>;

					port {
						ov7670_0: endpoint {
							remote-endpoint = <&isi_1>;
							bus-width = <8>;
						};
					};
				};
			};

新添加 ov7670_dts.c 到/home/infortech-ubuntu-1404/SAMA5D4/sources/kernel/kernel1/linux-at91-master/drivers/media/i2c/soc_camera
修改 ov7670_dts.c 基于ov2640.c修改的dts架构的驱动!,注意修改以下内容:
static const struct i2c_device_id ov7670_id[] = {
	{ "ov7670", 0 },	//看过源码,0这一项没有使用,所以填 0 !!
	{ }
};
MODULE_DEVICE_TABLE(i2c, ov7670_id);

static const struct of_device_id ov7670_of_match[] = {
	{.compatible = "ovti,ov7670", },
	{},
};
MODULE_DEVICE_TABLE(of, ov7670_of_match);

static struct i2c_driver ov7670_i2c_driver = {
	.driver = {
		.name = "ov7670",
		.of_match_table = of_match_ptr(ov7670_of_match),
	},
	.probe    = ov7670_probe,
	.remove   = ov7670_remove,
	.id_table = ov7670_id,
};

module_i2c_driver(ov7670_i2c_driver);

MODULE_DESCRIPTION("SoC Camera driver for Omni Vision 2640 sensor");
MODULE_AUTHOR("william huang");
MODULE_LICENSE("GPL v2");

修改 /home/infortech-ubuntu-1404/SAMA5D4/sources/kernel/kernel1/linux-at91-master/drivers/media/i2c/soc_camera/Makefile 添加:
#by william
obj-$(CONFIG_SOC_CAMERA_OV7670DTS)	+= ov7670_dts.o

修改 /home/infortech-ubuntu-1404/SAMA5D4/sources/kernel/kernel1/linux-at91-master/drivers/media/i2c/soc_camera/Kconfig 添加:
# by william
config SOC_CAMERA_OV7670DTS
	tristate "ov7670 camera support in DTS"
	depends on SOC_CAMERA && I2C
	help
	  This is a ov2640 camera driver

make ARCH=arm menuconfig 就可以选择 ov7670 camera support in DTS 这项了
make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- 就会去编译 ov7670_dts.c这个文件了!!!
把多余的错误纠正后得到成功编译驱动文件,接下来就是调试编译文件了!!!
由于只是把框架改过来而已,还保留着ov2640的功能,可以利用ov2640模块 测试驱动是否成功运行!!!
	只需要,把ov7670 dts i2c 的addr与ov2640 的就换过来测试
	结果 i2c访问ov2640失败,因为i2c地址不对,
	但是访问"ov7670"成功,因为ov7670驱动保留着ov2640的内容未更改,由于i2c地址也对上了,所以 ov7670驱动 成功运行,还抓取了图片
	证明 ov7670 的驱动框架没有问题,成功运行

接下来,要分析分析像摄像头这样复合功能的设备的实现!!
以 ov2640为例
整体说, 这个摄像头主要涉及到两个功能!!一个是i2c 一个是isi
而只需要工程师编写的 的文件只有 ov2640.c
但是涉及的内容有 soc_camera i2c 等子系统,还有 v4l2 isi 等内容!!!!
先看soc_camera 
涉及 soc_camera.c 和 soc_camera_platform.c 两个关键文件









??????
 VBLANK: 显示器扫描线完成最后一行后,需要重返左上角,这个过程叫做: vblank,也叫VBI(vertical blank interval) ,因为扫描线变得blank,以防止看到一个斜线显示在屏幕上.?????
开机没有出现小企鹅问题!!
开发板的中断号与linux中断号的兑换表!!		 

使用 bitbake 工具链???
	另外,如何 更改内核配置!!! 而bitbake 又可以通过!!!
	



























































////////////////////////////// regmap 模块概念
3.0linux内核版本中，codec driver是直接调用i2c的i2c_master_send函数与i2c_transfer函数来实现i2c的读写，
3.3版本，codec driver通过调用snd_soc_read和snd_soc_write函数来实现i2c的读写，
	这两个函数内部包裹了codec->read和codec->write，而codec->read和codec->write的赋值是在snd_soc_codec_set_cache_io中，
	最终也是调用了i2c_master_send函数与i2c_transfer函数
3.10版本开始出现了regmap的接口，这个regmap将i2c、spi、mmio、irq都抽象出统一的接口regmap_read、regmap_write、regmap_update_bits等接口
例如对于i2c接口
devm_regmap_init_i2c(i2c, &regmap_i2c);或者使用
devm_regmap_init(&i2c->dev, &regmap_i2c, &i2c->dev, config)
|
devm_regmap_init(struct device *dev, struct regmap_bus *bus, void *bus_content, struct regmap_config *config);
1）注册方法regmap_bus和对象i2c：
通过把struct regmap_bus regmap_i2c和i2c->dev注册到regmap模块中去，而regmap_bus中已经实现了read和write函数（调用的就是i2c_master_send与i2c_transfer）
2）使用注册的对象和方法
当调用regmap_read或者regmap_write的时候，这两个函数会取出struct regmap中的content即i2c，并调用之前注册的regmap_bus中的read和write函数来实现读和写。
regmap_update_bit内部调用了regmap_read和regmap_write
我觉得以上的原理挺重要的，我们可以自己实现类似的接口：提供注册的机制，能够将对象以及对象的方法注册进去；当需要调用的时候，取出对应的对象和方法。










////////////////////////////// linux 4.1 流程
但是在某个platform设备的设备信息被 device_add 到platferm总线上时，platform设备会执行probe，


setup+_arch->setup_arch->unflatten_device_tree (将DTB二进制文件转换成节点是device_node的树状结构)


板级初始化前，先挂载安装各种 bus设备（包括platform—bus设备）到linux上，
然后挂载各种设备驱动信息到 对应的总线设备上，挂载各个platform设备的驱动信息到 platform总线上

板级初始化：（重的说，从dtb处获得 各platform设备的设备信息内容，注册platform设备的设备信息到 platform总线上）
sama5_dt_device_init DT_MACHINE_START(sama5_dt, "Atmel SAMA5")：.init_machine
	at91_soc_init	//得到 soc，信息
	soc_device_to_device
	of_platform_populate(NULL, of_default_bus_match_table, NULL, soc_dev);		//应该只注册platform设备信息到 platform总线上
		of_find_node_by_path("/")
		of_platform_bus_create
			of_get_property(bus, "compatible", NULL)
			auxdata = of_dev_lookup(lookup, bus);
			of_device_is_compatible(bus, "arm,primecell")			//比较compatible
			of_amba_device_create(bus, bus_id, platform_data, parent);	//amba还是属于注册platform设备信息到 platform总线上）
				dev = amba_device_alloc(NULL, 0, 0);
					amba_device_initialize(dev, name);	
						device_initialize(&dev->dev);		//device_initialize	
				irq_of_parse_and_map
				ret = of_address_to_resource(node, 0, &dev->res);
					addrp = of_get_address(dev, index, &size, &flags);
					__of_address_to_resource(dev, addrp, size, flags, name, r);
						taddr = of_translate_address(dev, addrp);
						port = pci_address_to_pio(taddr);
				ret = amba_device_add(dev, &iomem_resource);
					ret = request_resource(parent, &dev->res);
					ret = amba_get_enable_pclk(dev);
					amba_put_disable_pclk(dev);
					ret = device_add(&dev->dev);		//device_add（还是属于注册platform设备信息到 platform总线上）
			dev = of_platform_device_create_pdata(bus, bus_id, platform_data, parent);
				dev = of_device_alloc(np, bus_id, parent);
					dev = platform_device_alloc("", -1);
					。。。
				of_dma_configure(&dev->dev, dev->dev.of_node);
				int of_device_add(struct platform_device *ofdev)
					device_add(&ofdev->dev)				//device_add
			for_each_child_of_node(bus, child) {
				rc = of_platform_bus_create(child, matches, lookup, &dev->dev, strict);
			of_node_set_flag(bus, OF_POPULATED_BUS);
		of_node_set_flag
		of_node_put
	at91sam9x5_pm_init	//这里是启动电源
		at91_dt_ramc();
		at91_pm_init();
		at91_pmc_fast_startup_init();
	
总的来说，板级初始化的 显性做法就是 把platform设备的设备信息挂到 platform总线上
但是在某个platform设备的设备信息被 device_add 到platferm总线上时，platform设备会执行probe，


 	
platform设备会执行probe，probe会把对应的具体设备的设备信息，挂入对应子系统的bus设备，
诱发bus：match，诱发具体设备驱动probe，初始化具体设备驱动 注册并挂载设备到linux上！！

例如 i2c-platform设备的probe
static int at91_twi_probe(struct platform_device *pdev)		//i2c_at91.c
	rc = i2c_add_numbered_adapter(&dev->adapter);
		__i2c_add_numbered_adapter
			i2c_register_adapter
				{ dev_set_name(&adap->dev, "i2c-%d", adap->nr);
				adap->dev.bus = &i2c_bus_type;
				adap->dev.type = &i2c_adapter_type;
				res = device_register(&adap->dev);  }	//把i2c adapter的设备信息 挂入 i2c bus
				bri->recover_bus--int (*recover_bus)(struct i2c_adapter *)	//从dtb中读取 具体其他外接从设备信息 挂入 i2c bus
					//只有一个指针，实际函数在哪还不知道！！
	
	
	
	
	
例如 spi-platform设备的probe	
static int atmel_spi_probe(struct platform_device *pdev)	//Spi_atmel.c
	int devm_spi_register_master(struct device *dev, struct spi_master *master)
		ret = spi_register_master(master);	
			status = of_spi_register_master(master);	//从dtb得到一些信息
			{ dev_set_name(&master->dev, "spi%u", master->bus_num);
			status = device_add(&master->dev); }		//把spi master设备信息 挂入 spi bus
			of_register_spi_devices(master);		//从dtb中读取 具体其他外接从设备信息 挂入 spi bus
	
	
	
	
注意到，对于芯片的所有功能模块，指定子系统的 platform设备只是一个桥接的左右，并没有实际操作算法！！！
而实际访问控制芯片寄存器的api 是又 主机设备提供的，
例如i2c adapter spi master 才是真正操作芯片寄存器的挂载在linux上的设备
而其他外接功能芯片的设备是通过有组织调用 主机设备的操作函数的 “虚拟”设备而已	

主机设备与万能设备的区别？？
看到主机设备的 device_register,但是没看到主机设备的 driver_register？
主机设备是platform设备本身，还是另外靠xx bus match后初始化的另一个设备？？



注意：of_xxxx_put()或者xxxx_put()是卸载未完全加载的 模块



////////////////////////////// dts学习

关于旧版内核板级信息,与新版dts的对比:
	http://blog.csdn.net/sinat_26600745/article/details/47345257 


基本知识
http://blog.csdn.net/21cnbao/article/details/8457546

1,
#address-cells
#size-cells
描述子节点级的可寻址的 reg变量数量
例如:
{
	#address-cells = <3>;	//表示 reg 有3个address内容
	#size-cells = <2>;	//表示 reg 有2个size内容
	a@0 {
		device_type = "cpu";
		compatible = "arm,cortex-a5";
		reg = <1 78 0x67 88 1023 >;	//1,78,0x67为3个address内容, 88,1023为2个size内容
		next-level-cache = <&L2>;
	};
};

2,
interrupt-parent
interrupts =
interrupt-controller
/*遍历所有的node，寻找定义了interrupt-controller属性的node，如果定义了interrupt-controller属性则说明该node就是一个中断控制器。*/
interrupt controller的处理
初始化是通过start_kernel->init_IRQ->machine_desc->init_irq()实现的


http://www.cnblogs.com/aaronLinux/p/5496559.html

例子:
http://www.cnblogs.com/aaronLinux/p/5551441.html
此篇源文件arch/arm/boot/dts/imx6sx.dtsi
uart5: serial@021f4000 {
    compatible = "fsl,imx6sx-uart",
                "fsl,imx6q-uart", "fsl,imx21-uart";
    reg = <0x021f4000 0x4000>;
    interrupts = <GIC_SPI 30 IRQ_TYPE_LEVEL_HIGH>;
    clocks = <&clks IMX6SX_CLK_UART_IPG>,
            <&clks IMX6SX_CLK_UART_SERIAL>;
    clock-names = "ipg", "per";
    dmas = <&sdma 33 4 0>, <&sdma 34 4 0>;
    dma-names = "rx", "tx";
    status = "disabled";
};
以上这段代码更多出现在*.dtsi中
如uart5作为该外设的label，node-name@unit-address作为设备的名称，node-name只是设备类型，
	uart1/uart2/uart3等可以都是serial名称，而@后面则跟着设备寄存器起始地址。
interrupts对应的中断号和中断出发方式，uart5的父节点为aips2，而aips2的父节点为soc，soc节点定义了interrupt-parent = <&intc>;
	给出了节点所依附的中断控制器，如果节点没有指定interrupt-parent，那么就从父节点继承，所以该uart5节点继承了soc的中断控制器，即intc. 
	而intc节点的#interrupt-cells = <3>;所以就有了该节点中interrupts = <GIC_SPI 30 IRQ_TYPE_LEVEL_HIGH>;三个字段，
	具体这三个字段的含义可以参考芯片文档的描述。其中GIC_SPI定义在include/dt-bindings/interrupt-controller/arm-gic.h值为0，　
clock外设时钟，在include/dt-bindings/clock/imx6sx-clock.h，指定设备工作时钟
status一般会设为disabled。
&uart5 {
    pinctrl-names = "default";
    pinctrl-0 = <&pinctrl_uart5>;
    fsl,uart-has-rtscts;
    status = "okay";
};
以上这段代码更多出现在*.dts中
注：如果看过内核/arch/arm/boot/dts目录的读者看到这可能有一个疑问。在每个.dsti和.dts中都会存在一个“/”根节点，
	那么如果在一个设备树文件中include一个.dtsi文件，那么岂不是存在多个“/”根节点了么。
	其实不然，编译器DTC在对.dts进行编译生成dtb时，会对node进行合并操作，最终生成的dtb只有一个root node。
	Dtc会进行合并操作这一点从属性上也可以得到验证。这个稍后做讲解。
在*.dts中如果想对该设备进行操作，需要进行override，至少status需要从disabled设置为okay, 
	当然也有可能需要对compatible属性进行重写(为了和自己的driver匹配)，另外需要使用&label首先引用该设备，
使用pinctrl-names和pinctrl-0进行引脚的配置，当然这里可能出现多组引脚的配置，例如:
&usdhc3 {
    pinctrl-names = "default", "state_100mhz", "state_200mhz";
    pinctrl-0 = <&pinctrl_usdhc3>;
    pinctrl-1 = <&pinctrl_usdhc3_100mhz>;
    pinctrl-2 = <&pinctrl_usdhc3_200mhz>;
    bus-width = <8>;
    cd-gpios = <&gpio2 10 GPIO_ACTIVE_HIGH>;
    wp-gpios = <&gpio2 15 GPIO_ACTIVE_HIGH>;
    keep-power-in-suspend;
    enable-sdio-wakeup;
    vmmc-supply = <&vcc_sd3>;
    status = "okay";
};

pinctrl_usdhc3: usdhc3grp {
    fsl,pins = <
        MX6SX_PAD_SD3_CMD__USDHC3_CMD        0x17069
        MX6SX_PAD_SD3_CLK__USDHC3_CLK        0x10071
        MX6SX_PAD_SD3_DATA0__USDHC3_DATA0    0x17069
        MX6SX_PAD_SD3_DATA1__USDHC3_DATA1    0x17069
        MX6SX_PAD_SD3_DATA2__USDHC3_DATA2    0x17069
        MX6SX_PAD_SD3_DATA3__USDHC3_DATA3    0x17069
        MX6SX_PAD_SD3_DATA4__USDHC3_DATA4    0x17069
        MX6SX_PAD_SD3_DATA5__USDHC3_DATA5    0x17069
        MX6SX_PAD_SD3_DATA6__USDHC3_DATA6    0x17069
        MX6SX_PAD_SD3_DATA7__USDHC3_DATA7    0x17069
        MX6SX_PAD_KEY_COL0__GPIO2_IO_10        0x17059 /* CD */
        MX6SX_PAD_KEY_ROW0__GPIO2_IO_15        0x17059 /* WP */
        >;
};
这种pinctrl的设置可参照/Documentation/devicetree/bindinsg/pinctrl下示例代码













////////////////////////////// sama5d4 mmap 结构

/*
 * Internal Memory.		//
 */
#define ATMEL_BASE_ROM		0x00000000	片上rom始地址
#define ATMEL_BASE_NFC		0x00100000	片上SRAM始地址
#define ATMEL_BASE_SRAM		0x00200000	第二块片上ROM始地址,
#define ATMEL_BASE_VDEC		0x00300000	/* Video Decoder Controller */
#define ATMEL_BASE_UDPHS_FIFO	0x00400000	/* USB Device HS controller */
#define ATMEL_BASE_OHCI		0x00500000	/* USB Host controller (OHCI) */
#define ATMEL_BASE_EHCI		0x00600000	/* USB Host controller (EHCI) */
#define ATMEL_BASE_AXI		0x00700000
#define ATMEL_BASE_DAP		0x00800000
#define ATMEL_BASE_SMD		0x00900000

/*
 * External memory
 */
#define ATMEL_BASE_CS0		0x10000000
#define ATMEL_BASE_DDRCS	0x20000000
#define ATMEL_BASE_CS1		0x60000000
#define ATMEL_BASE_CS2		0x70000000
#define ATMEL_BASE_CS3		0x80000000






////////////////////////////// TFT_lcd

SAMA5D4 : default lcd 接口  (对应RGB88的,注意,物理接口不能其他兼容RGBXXX,详细看pdf)
1:	EDBG_ID_01		ID_SYS not connect
2:	GND
3:	LCD_DAT0_PA0		LCDDAT0 	Blue	
5:	LCD_DAT0_PA1		LCDDAT1 
5:	LCD_DAT0_PA2		LCDDAT2 
6:	LCD_DAT0_PA3		LCDDAT3
7:	GND
8:	LCD_DAT0_PA4		LCDDAT4 	
9:	LCD_DAT0_PA5		LCDDAT5 
10:	LCD_DAT0_PA6		LCDDAT6 
11:	LCD_DAT0_PA7		LCDDAT7
12:	GND
13:	LCD_DAT0_PA8		LCDDAT8		GREEN
14:	LCD_DAT0_PA9		LCDDAT9 
15:	LCD_DAT0_PA10		LCDDAT10 
16:	LCD_DAT0_PA11		LCDDAT11
17:	GND
18:	LCD_DAT0_PA12		LCDDAT12	
19:	LCD_DAT0_PA13		LCDDAT13
20:	LCD_DAT0_PA14		LCDDAT14 
21:	LCD_DAT0_PA15		LCDDAT15
22:	GND
23:	LCD_DAT0_PA16		LCDDAT16	RED
24:	LCD_DAT0_PA17		LCDDAT17
25:	LCD_DAT0_PA18		LCDDAT18 
26:	LCD_DAT0_PA19		LCDDAT19
27:	GND
28:	LCD_DAT0_PA20		LCDDAT20
29:	LCD_DAT0_PA21		LCDDAT21
30:	LCD_DAT0_PA22		LCDDAT22 
31:	LCD_DAT0_PA23		LCDDAT23
32:	GND
33:	LCD_PCK_PA28		LCDPCK
34:	LCD_VSYNC_PA26		LCDVSYNC
35:	LCD_HSYNC_PA27		LCDHSYNc 
36:	LCD_DEN_PA29		LCDDEN
37:	AD3_YM_PC30		YM 即 Y- 是并联到GND的一端
38:	AD2_YP_PC29		YP 即 Y+ 是并联到VCC的一端
39:	AD1_XM_PC28		XM 即 X- 是并联到GND的一端
40:	AD0_XP_PC27		XP 即 X+ 是并联到VCC的一端
41:	LCD_DISP_PA25		LCDDISP
42:	LCD_TWD0_PA30		not connect
43:	LCD_TWCK0_PA31		not connect
44:	LCD_PE9			IRQ1 not connect
45:	LCD_PE10		IRQ2 not connect
46:	LCD_PWM_PA24		not connect
47:	NRST_3V3		not connect
48:	VCC_5V
50:	GND

裸屏!!
1:	VLED-		LED Ground	//另外接 TPS61040 模块
2:	VLED+		LED Power
3:	DGND		Digital Ground
4:	VCC		Power Supply (+3.3 V)
5:	R0		Red Data Bit0
6:	R1		Red Data Bit1
7:	R2		Red Data Bit2
8:	R3		Red Data Bit3
9:	R4		Red Data Bit4
10:	R5		Red Data Bit5
11:	R6		Red Data Bit6
12:	R7		Red Data Bit7
13:	G0		Green Data Bit0
14:	G1		Green Data Bit1
15:	G2		Green Data Bit2
16:	G3		Green Data Bit3
17:	G4		Green Data Bit4
18:	G5		Green Data Bit5
19:	G6		Green Data Bit6
20:	G7		Green Data Bit7
21:	B0		Blue Data Bit0
22:	B1		Blue Data Bit1
23:	B2		Blue Data Bit2
24:	B3		Blue Data Bit3
25:	B4		Blue Data Bit4
26:	B5		Blue Data Bit5
27:	B6		Blue Data Bit6
28:	B7		Blue Data Bit7
29:	DGND		Digital Ground
30:	DCLK		Dot Data Clock
31:	DISP		Display On/Off		Usually pull high. High: Display On / Low: Display Off
32:	Hsync		Horizontal Sync Input
33:	Vsync		Vertical Sync Input
34:	DE		Data Enable Control	DE=” H “: data can be access, DE=” L “: data cannot be access
35:	N.C		N.C
36:	DGND		Digital Ground
37:	X-		触摸控制
38:	Y-		触摸控制
39:	X+		触摸控制
40:	Y+		触摸控制

XPT2046触摸控制芯片,
ssd1960 单片机mcu 与 lcd裸屏 之间的转接芯片,(一般单片机本身没有lcd控制模块时才去使用有转接芯片的方案)

adc touchscreen page1537


////////////////////////////// linux 启动流程




arch/arm/kernel/head.s: _INIT

init/main.c:  asmlinkage __visible void __init start_kernel(void)






////////////////////////////// linux 启动流程
at91Tbootstep会把全局物理地址 0x40000 (nandflash空间)的0x80000字节内容拷到全局物理地址 0x26f00000 (对应ram空间)去,
就是uboot内容
uboot从 arch/arm/lib/veters.s -> _start -> b reset
-> arch\arm\cpu\armv7\start.S:reset -> 



////////////////////////////// linux 

kset kobject :
kobject 是抽象的通用数据结构,每一个linux内容 例如 device信息,drive信息 等等,都分得一个通用数据,主要用于内容的引用计数,
当linux内容没有使用时,引用计数为0,linux内容会删除,kobject会从系统释放,
kset是一个特殊的kobject 指向内容是一个许多kobject指针的链表
kset 与 kobject 的关系就像 文件夹 和 文件,但文件夹本身是一个有列表信息的文件
每个 kobject kset  在sys/里都有响应的文件夹,而 kobject 的 attrs属性内容以文件的形式存在这些文件夹里





#define ACCESS_ONCE(x) (*(volatile typeof(x) *)&(x))
owner = ACCESS_ONCE(lock->owner); //ACCESS_ONCE表示一定要从实际内存地址访问这个变量lock->owner,不要被优化,不要从cpu_cache缓存里读出而不访问内存












GPIO 通用相关:
pin control subsystem的文件列表

1、源文件列表

我们整理linux/drivers/pinctrl目录下pin control subsystem的源文件列表如下：
文件名 	描述
core.c core.h 	pin control subsystem的core driver
pinctrl-utils.c pinctrl-utils.h 	pin control subsystem的一些utility接口函数
pinmux.c pinmux.h 	pin control subsystem的core driver(pin muxing部分的代码，也称为pinmux driver)
pinconf.c pinconf.h 	pin control subsystem的core driver(pin config部分的代码，也称为pin config driver)
devicetree.c devicetree.h 	pin control subsystem的device tree代码
pinctrl-xxxx.c 	各种pin controller的low level driver
在pin controller driver文档中 ，我们以2416的pin controller为例，描述了一个具体的low level的driver，这个driver涉及的文件包括pinctrl-samsung.c，pinctrl-samsung.h和pinctrl-s3c24xx.c。

2、和其他内核模块接口头文件
很多内核的其他模块需要用到pin control subsystem的服务，这些头文件就定义了pin control subsystem的外部接口以及相关的数据结构。我们整理linux/include/linux/pinctrl目录下pin control subsystem的外部接口头文件列表如下：
文件名 	描述
consumer.h 	其他的driver要使用pin control subsystem的下列接口：
a、设置引脚复用功能
b、配置引脚的电气特性
这时候需要include这个头文件
devinfo.h 	这是for linux内核的驱动模型模块（driver model）使用的接口。struct device中包括了一个struct dev_pin_info    *pins的成员，这个成员描述了该设备的引脚的初始状态信息，在probe之前，driver model中的core driver在调用driver的probe函数之前会先设定pin state
machine.h 	和machine模块的接口。

3、Low level pin controller driver接口
我们整理linux/include/linux/pinctrl目录下pin control subsystem提供给底层specific pin controller driver的头文件列表如下：
文件名 	描述
pinconf-generic.h 	这个接口主要是提供给各种pin controller driver使用的，不是外部接口。
pinconf.h 	pin configuration 接口
pinctrl-state.h 	pin control state状态定义
pinmux.h 	pin mux function接口 











device tree 与gpio 设置:
    device-node-name { 
            定义该device自己的属性  

            pinctrl-names = "sleep", "active";－－－－－－（1）
            pinctrl-0 = <pin-config-0-a>;－－－－－－－－－－－－－－（2）
            pinctrl-1 = <pin-config-1-a pin-config-1-b>;        
        };

 （1）pinctrl-names定义了一个state列表。那么什么是state呢？具体说应该是pin state，对于一个client device，它使用了一组pin，这一组pin应该同时处于某种状态，毕竟这些pin是属于一个具体的设备功能。state的定义和电源管理关系比较紧密，例如当设备active的时候，我们需要pin controller将相关的一组pin设定为具体的设备功能，而当设备进入sleep状态的时候，需要pin controller将相关的一组pin设定为普通GPIO，并精确的控制GPIO状态以便节省系统的功耗。state有两种，标识，一种就是pinctrl-names定义的字符串列表，另外一种就是ID。ID从0开始，依次加一。根据例子中的定义，state ID等于0（名字是active）的state对应pinctrl-0属性，state ID等于1（名字是idle）的state对应pinctrl-1属性。具体设备state的定义和各个设备相关，具体参考在自己的device bind。 
（2）pinctrl-x的定义。pinctrl-x是一个句柄（phandle）列表，每个句柄指向一个pin configuration。有时候，一个state对应多个pin configure。例如在active的时候，I2C功能有两种配置，一种是从pin ID{7,8}引出，另外一个是从pin ID{69,103}引出。 

serial@50000000 { 
        ……
        pinctrl-names = "default";
        pinctrl-0 = <0x2 0x3>;
    }; 
该serial device只定义了一个state就是default，对应pinctrl-0属性定义。pinctrl-0是一个句柄（phandle）列表，每个句柄指向一个pin configuration。0x2对应上节中的uart0-data节点，0x03对应uart0-fctl 节点，也就是说，这个串口有两种配置，一种是从gph bank中的第一个和第二个GPIO pin引出，另外一个是从gph bank中的第8个和第9个GPIO pin引出。

（5）一个pin configuration的device tree node被解析成两个描述符，一个是samsung pin group的描述符，另外一个是samsung pin mux function描述符。这两个描述符的名字都是根据dts file中的pin configuration的device node name生成，只不过pin group的名字附加-grp的后缀，而function描述符的名字后面附加-mux的后缀。 
    struct of_device_id
    {
        char    name[32];－－－－－－要匹配的device node的名字
        char    type[32];－－－－－－－要匹配的device node的类型
        char    compatible[128];－－－匹配字符串（DT compatible string），用来匹配适合的device node
        const void *data;－－－－－－－－对于GIC，这里是初始化函数指针
    };

这个数据结构主要被用来进行Device node和driver模块进行匹配用的。从该数据结构的定义可以看出，在匹配过程中，device name、device type和DT compatible string都是考虑的因素。更细节的内容请参考__of_device_is_compatible函数。 












Linux kernel的中断子系统 gic模块
gic控制所有中断,外部中断先通过gic distributor 选择由哪一个cpu处理这次这个中断行为,然后通过cpu interface 传递到中断该cpu当前运作,让其执行这次中断任务!!!!!
中断虽然发生了，但软件不一定立刻响应，可能由于在内核态执行的某些操作不希望被外部事件打断而主动关闭了中断（或是关闭了CPU的中断，或者MASK了该IRQ number），这时候，中断信号没有立刻得到响应，软件仍然在内核态执行低优先级任务系统调用的代码。

2.6内核和2.4内核显著的不同是提供了一个CONFIG_PREEMPT的选项，打开该选项后，linux kernel就支持了内核代码的抢占（当然不能在临界区）
所谓抢占式就是中断任务处理完后,重新调度,而不是回到之前被打断的进程
 （1）为了同步，内核中总有些代码需要持有自旋锁资源，或者显式的调用preempt_disable来禁止抢占，这时候不允许抢占 
 （2）中断上下文（并非只是中断handler，还包括softirq、timer、tasklet）总是可以抢占进程上下文 
因此，即便是打开了PREEMPT的选项，实际上linux系统的任务响应时间仍然是不确定的。一方面内核代码的临界区非常多，我们需要找到，系统中持有锁，或者禁止抢占的最大的时间片。另外一方面，在上图的T4中，能顺利的调度高优先级任务并非易事，这时候可能有触发的软中断，也可能有新来的中断，也可能某些driver的tasklet要执行，只有在没有任何bottom half的任务要执行的时候，调度器才会启动调度。 

ARM处理器有多种processor mode，例如user mode（用户空间的AP所处于的模式）、supervisor mode（即SVC mode，大部分的内核态代码都处于这种mode）、IRQ mode（发生中断后，处理器会切入到该mode）等。对于linux kernel，其中断处理处理过程中，ARM 处理器大部分都是处于SVC mode。但是，实际上产生中断的时候，ARM处理器实际上是进入IRQ mode，因此在进入真正的IRQ异常处理之前会有一小段IRQ mode的操作，之后会进入SVC mode进行真正的IRQ异常处理。由于IRQ mode只是一个过度，因此IRQ mode的栈很小，只有12个字节，
struct stack {
    u32 irq[3];
    u32 abt[3];
    u32 und[3];
} ____cacheline_aligned; 
 static struct stack stacks[NR_CPUS]; 
除了irq mode，linux kernel在处理abt mode（当发生data abort exception或者prefetch abort exception的时候进入的模式）和und mode（处理器遇到一个未定义的指令的时候进入的异常模式）的时候也是采用了相同的策略。也就是经过一个简短的abt或者und mode之后，stack切换到svc mode的栈上，这个栈就是发生异常那个时间点current thread的内核栈。anyway，在irq mode和svc mode之间总是需要一个stack保存数据，这就是中断模式的stack，系统初始化的时候，cpu_init函数中会进行中断模式stack的设定
 嵌入式汇编的语法格式是：asm(code : output operand list : input operand list : clobber list);大家对着上面的code就可以分开各段内容了。在input operand list中，有两种限制符（constraint），"r"或者"I"，"I"表示立即数（Immediate operands），"r"表示用通用寄存器传递参数。clobber list中有一个r14，表示在汇编代码中修改了r14的值，这些信息是编译器需要的内容。

对于SMP，bootstrap CPU会在系统初始化的时候执行cpu_init函数，进行本CPU的irq、abt和und三种模式的内核栈的设定，具体调用序列是：start_kernel--->setup_arch--->setup_processor--->cpu_init。对于系统中其他的CPU，bootstrap CPU会在系统初始化的最后，对每一个online的CPU进行初始化，具体的调用序列是：start_kernel--->rest_init--->kernel_init--->kernel_init_freeable--->kernel_init_freeable--->smp_init--->cpu_up--->_cpu_up--->__cpu_up。__cpu_up函数是和CPU architecture相关的。对于ARM，其调用序列是__cpu_up--->boot_secondary--->smp_ops.smp_boot_secondary(SOC相关代码)--->secondary_startup--->__secondary_switched--->secondary_start_kernel--->cpu_init。 
在使用了MMU之后，具体异常向量表放在那个物理地址已经不重要了，重要的是把它映射到0xffff0000的虚拟地址就OK了，具体代码如下：

    static void __init devicemaps_init(const struct machine_desc *mdesc)
    {
        ……
        vectors = early_alloc(PAGE_SIZE * 2); －－－－－分配两个page的物理页帧
        early_trap_init(vectors); －－－－－－－copy向量表以及相关help function到该区域
        ……
        map.pfn = __phys_to_pfn(virt_to_phys(vectors));
        map.virtual = 0xffff0000;
        map.length = PAGE_SIZE;
    #ifdef CONFIG_KUSER_HELPERS
        map.type = MT_HIGH_VECTORS;
    #else
        map.type = MT_LOW_VECTORS;
    #endif
        create_mapping(&map); －－－－－－－－－－映射0xffff0000的那个page frame
        if (!vectors_high()) {－－－如果SCTLR.V的值设定为low vectors，那么还要映射0地址开始的memory
            map.virtual = 0;
            map.length = PAGE_SIZE * 2;
            map.type = MT_LOW_VECTORS;
            create_mapping(&map);
        }
        map.pfn += 1;
        map.virtual = 0xffff0000 + PAGE_SIZE;
        map.length = PAGE_SIZE;
        map.type = MT_LOW_VECTORS;
        create_mapping(&map); －－－－－－－－－－映射high vecotr开始的第二个page frame
    ……
    }

当外设（SOC内部或者外部都可以）检测到了中断事件，就会通过interrupt requestion line上的电平或者边沿（上升沿或者下降沿或者both）通知到该外设连接到的那个中断控制器，而中断控制器就会在多个处理器中选择一个，并把该中断通过IRQ（或者FIQ，本文不讨论FIQ的情况）分发给该processor。ARM处理器感知到了中断事件后，会进行下面一系列的动作：
1、修改CPSR（Current Program Status Register）寄存器中的M[4:0]。M[4:0]表示了ARM处理器当前处于的模式（ processor modes）。ARM定义的mode包括： 
处理器模式 	缩写 	对应的M[4:0]编码 	Privilege level
User 		usr 	10000 			PL0
FIQ 		fiq 	10001 			PL1
IRQ 		irq 	10010 			PL1
Supervisor 	svc 	10011 			PL1
Monitor 	mon 	10110 			PL1
Abort 		abt 	10111 			PL1
Hyp 		hyp 	11010 			PL2
Undefined 	und 	11011 			PL1
System 		sys 	11111 			PL1 
 一旦设定了CPSR.M，ARM处理器就会将processor mode切换到IRQ mode。 

2、保存发生中断那一点的CPSR值（step 1之前的状态）和PC值
ARM处理器支持9种processor mode，每种mode看到的ARM core register（R0～R15，共计16个）都是不同的。每种mode都是从一个包括所有的Banked ARM core register中选取。全部Banked ARM core register包括

Usr 	System 	Hyp 	Supervisor 	abort 	undefined 	Monitor 	IRQ 	FIQ
R0_usr 	  	  	  	  	  	  	  	 
R1_usr 	  	  	  	  	  	  	  	 
R2_usr 	  	  	  	  	  	  	  	 
R3_usr 	  	  	  	  	  	  	  	 
R4_usr 	  	  	  	  	  	  	  	 
R5_usr 	  	  	  	  	  	  	  	 
R6_usr 	  	  	  	  	  	  	  	 
R7_usr 	  	  	  	  	  	  	  	 
R8_usr 	  	  	  	  	  	  	  				R8_fiq
R9_usr 	  	  	  	  	  	  	  				R9_fiq
R10_usr 	  	  	  	  	  	  	  			R10_fiq
R11_usr 	  	  	  	  	  	  	  			R11_fiq
R12_usr 	  	  	  	  	  	  	  			R12_fiq
SP_usr 	  	SP_hyp 	SP_svc 		SP_abt 	SP_und 		SP_mon 		SP_irq 	SP_fiq
LR_usr 	  	  	LR_svc 		LR_abt 	LR_und 		LR_mon 		LR_irq 	LR_fiq
PC 	  	  	  	  	  	  	  	 
CPSR 	  	  	  	  	  	  	  	 
  	  	SPSR_hyp SPSR_svc 	SPSR_abt SPSR_und 	SPSR_mon 	SPSR_irq SPSR_fiq
  	  	ELR_hyp 	  	  	  	  	  	  
在IRQ mode下，CPU看到的R0～R12寄存器、PC以及CPSR是和usr mode（userspace）或者svc mode（kernel space）是一样的。不同的是IRQ mode下，有自己的R13(SP，stack pointer）、R14（LR，link register）和SPSR（Saved Program Status Register）。 
CPSR是共用的，虽然中断可能发生在usr mode（用户空间），也可能是svc mode（内核空间），不过这些信息都是体现在CPSR寄存器中。硬件会将发生中断那一刻的CPSR保存在SPSR寄存器中（由于不同的mode下有不同的SPSR寄存器，因此更准确的说应该是SPSR-irq，也就是IRQ mode中的SPSR寄存器）。 
PC也是共用的，由于后续PC会被修改为irq exception vector，因此有必要保存PC值。当然，与其说保存PC值，不如说是保存返回执行的地址。对于IRQ而言，我们期望返回地址是发生中断那一点执行指令的下一条指令。具体的返回地址保存在lr寄存器中（注意：这个lr寄存器是IRQ mode的lr寄存器，可以表示为lr_irq）：
 （1）对于thumb state，lr_irq ＝ PC
（2）对于ARM state，lr_irq ＝ PC － 4 

contex-A9 的中断管理器gic模块
 GIC-V2支持的中断类型有下面几种：
（a）外设中断（Peripheral interrupt）。有实际物理interrupt request signal的那些中断，上面已经介绍过了。
（b）软件触发的中断（SGI，Software-generated interrupt）。软件可以通过写GICD_SGIR寄存器来触发一个中断事件，这样的中断，可以用于processor之间的通信。
（c）虚拟中断（Virtual interrupt）和Maintenance interrupt。这两种中断和本文无关，不再赘述。 
自外设的interrupt source输入信号。分成两种类型，分别是PPI（Private Peripheral Interrupt）和SPI（Shared Peripheral Interrupt）。其实从名字就可以看出来两种类型中断信号的特点，PPI中断信号是CPU私有的，每个CPU都有其特定的PPI信号线。而SPI是所有CPU之间共享的。通过寄存器GICD_TYPER可以配置SPI的个数（最多480个）。GIC-400支持多少个SPI中断，其输入信号线就有多少个SPI interrupt request signal。同样的，通过寄存器GICD_TYPER也可以配置CPU interface的个数（最多8个），GIC-400支持多少个CPU interface，其输入信号线就提供多少组PPI中断信号线。一组PPI中断信号线包括6个实际的signal：
（a）nLEGACYIRQ信号线。对应interrupt ID 31，在bypass mode下（这里的bypass是指bypass GIC functionality，直接连接到某个processor上），nLEGACYIRQ可以直接连到对应CPU的nIRQCPU信号线上。在这样的设置下，该CPU不参与其他属于该CPU的PPI以及SPI中断的响应，而是特别为这一根中断线服务。
（b）nCNTPNSIRQ信号线。来自Non-secure physical timer的中断事件，对应interrupt ID 30。
（c）nCNTPSIRQ信号线。来自secure physical timer的中断事件，对应interrupt ID 29。
（d）nLEGACYFIQ信号线。对应interrupt ID 28。概念同nLEGACYIRQ信号线，不再描述。
（e）nCNTVIRQ信号线。对应interrupt ID 27。Virtual Timer Event，和虚拟化相关，这里不与描述。
（f）nCNTHPIRQ信号线。对应interrupt ID 26。Hypervisor Timer Event，和虚拟化相关，这里不与描述。
对于Cortex A15的GIC实现，其PPI中断信号线除了上面的6个，还有一个叫做Virtual Maintenance Interrupt，对应interrupt ID 25。
对于Cortex A9的GIC实现，其PPI中断信号线包括5根：
（a）nLEGACYIRQ信号线和nLEGACYFIQ信号线。对应interrupt ID 31和interrupt ID 28。这部分和上面一致
（b）由于Cortext A9的每个处理器都有自己的Private timer和watch dog timer，这两个HW block分别使用了ID 29和ID 30
（c）Cortext A9内嵌一个global timer为系统内的所有processor共享，对应interrupt ID 27
关于private timer和global timer的描述，请参考时间子系统的相关文档。
关于一系列和虚拟化相关的中断，请参考虚拟化的系列文档。
（3）输出信号
所谓输出信号，其实就是GIC和各个CPU直接的接口，这些接口包括：
（a）触发CPU中断的信号。nIRQCPU和nFIQCPU信号线，熟悉ARM CPU的工程师对这两个信号线应该不陌生，主要用来触发ARM cpu进入IRQ mode和FIQ mode。
（b）Wake up信号。nFIQOUT和nIRQOUT信号线，去ARM CPU的电源管理模块，用来唤醒CPU的
（c）AXI slave interface signals。AXI（Advanced eXtensible Interface）是一种总线协议，属于AMBA规范的一部分。通过这些信号线，ARM CPU可以和GIC硬件block进行通信（例如寄存器访问）。
（4）中断号的分配
GIC-V2支持的中断类型有下面几种：
（a）外设中断（Peripheral interrupt）。有实际物理interrupt request signal的那些中断，上面已经介绍过了。
（b）软件触发的中断（SGI，Software-generated interrupt）。软件可以通过写GICD_SGIR寄存器来触发一个中断事件，这样的中断，可以用于processor之间的通信。
（c）虚拟中断（Virtual interrupt）和Maintenance interrupt。这两种中断和本文无关，不再赘述。
为了标识这些interrupt source，我们必须要对它们进行编码，具体的ID分配情况如下：
（a）ID0~ID31是用于分发到一个特定的process的interrupt。标识这些interrupt不能仅仅依靠ID，因为各个interrupt source都用同样的ID0~ID31来标识，因此识别这些interrupt需要interrupt ID ＋ CPU interface number。ID0~ID15用于SGI，ID16~ID31用于PPI。PPI类型的中断会送到其私有的process上，和其他的process无关。SGI是通过写GICD_SGIR寄存器而触发的中断。Distributor通过processor source ID、中断ID和target processor ID来唯一识别一个SGI。
（b）ID32~ID1019用于SPI。 这是GIC规范的最大size，实际上GIC-400最大支持480个SPI，Cortex-A15和A9上的GIC最多支持224个SPI。 

不同的GIC-V2的实现总会有一些不同，这些信息可以通过Device tree的机制来传递。Device node中定义了各种属性，其中就包括了memory资源，IRQ描述等信息，这些信息需要在初始化的时候传递给具体的驱动，因此需要一个Device node和driver模块的匹配过程。在Device Tree模块中会包括系统中所有的device node，如果我们的系统使用了GIC-400，那么系统的device node数据库中会有一个node是GIC-400的，一个示例性的GIC-400的device node（我们以瑞芯微的RK3288处理器为例）定义如下：
    gic: interrupt-controller@ffc01000 {
        compatible = "arm,gic-400";
        interrupt-controller;
        #interrupt-cells = <3>;
        #address-cells = <0>;

        reg = <0xffc01000 0x1000="">,－－－－Distributor address range
              <0xffc02000 0x1000="">,－－－－－CPU interface address range
              <0xffc04000 0x2000="">,－－－－－Virtual interface control block
              <0xffc06000 0x2000="">;－－－－－Virtual CPU interfaces
        interrupts = ;
    };
     void __init irqchip_init(void)
    {
        of_irq_init(__irqchip_begin);
    }
__irqchip_begin就是内核irq chip table的首地址，这个table也就保存了kernel支持的所有的中断控制器的ID信息（用于和device node的匹配）。of_irq_init函数执行之前，系统已经完成了device tree的初始化，因此系统中的所有的设备节点都已经形成了一个树状结构，每个节点代表一个设备的device node。of_irq_init是在所有的device node中寻找中断控制器节点，形成树状结构（系统可以有多个interrupt controller，之所以形成中断控制器的树状结构，是为了让系统中所有的中断控制器驱动按照一定的顺序进行初始化）。之后，从root interrupt controller节点开始，对于每一个interrupt controller的device node，扫描irq chip table，进行匹配，一旦匹配到，就调用该interrupt controller的初始化函数，并把该中断控制器的device node以及parent中断控制器的device node作为参数传递给irq chip driver。。具体的匹配过程的代码属于Device Tree模块的内容，
 我们首先看看这个函数的参数，node参数代表需要初始化的那个interrupt controller的device node，parent参数指向其parent。在映射GIC-400的memory map I/O space的时候，我们只是映射了Distributor和CPU interface的寄存器地址空间，和虚拟化处理相关的寄存器没有映射，因此这个版本的GIC driver应该是不支持虚拟化的（不知道后续版本是否支持，在一个嵌入式平台上支持虚拟化有实际意义吗？最先支持虚拟化的应该是ARM64+GICV3/4这样的平台）。

要了解cpu-offset属性，首先要了解什么是banked register。所谓banked register就是在一个地址上提供多个寄存器副本。比如说系统中有四个CPU，这些CPU访问某个寄存器的时候地址是一样的，但是对于banked register，实际上，不同的CPU访问的是不同的寄存器，虽然它们的地址是一样的。如果GIC没有banked register，那么需要提供根据CPU index给出一系列地址偏移，而地址偏移=cpu-offset * cpu-nr
 每个interrupt controller都会形成一个irq domain，负责解析其下游的interrut source。如果interrupt controller有级联的情况，那么一个非root interrupt controller的中断控制器也是其parent irq domain的一个普通的interrupt source。struct irq_domain定义如下：
    struct irq_domain {
    ……
        const struct irq_domain_ops *ops;
        void *host_data;
    ……
    };
 对于GIC支持的IRQ的数目，这里还要赘述几句。实际上并非GIC支持多少个HW interrupt ID，其就支持多少个IRQ。对于SGI，其处理比较特别，并不归入IRQ number中。因此，对于GIC而言，其SGI（从0到15的那些HW interrupt ID）不需要irq domain进行映射处理，也就是说SGI没有对应的IRQ number。如果系统越来越复杂，一个GIC不能支持所有的interrupt source（目前GIC支持1020个中断源，这个数目已经非常的大了），那么系统还需要引入secondary GIC，这个GIC主要负责扩展外设相关的interrupt source，也就是说，secondary GIC的SGI和PPI都变得冗余了（这些功能，primary GIC已经提供了）。这些信息可以协助理解代码中的hwirq_base的设定。
（d）通过Distributor中的寄存器可以控制送达CPU interface，中断来到了GIC的CPU interface是否可以真正送达CPU呢？也不一定，还有一道关卡，也就是CPU interface中的Interrupt Priority Mask Register。这个寄存器设定了一个中断优先级的值，只有中断优先级高过该值的中断请求才会被送到CPU上去。我们在前面初始化的时候，给每个interrupt ID设定的缺省优先级是0xa0，这里设定的priority filter的优先级值是0xf0。数值越小，优先级越过。因此，这样的设定就是让所有的interrupt source都可以送达CPU，在CPU interface这里不做控制了。 
 对于GIC而言，其中断状态有四种：
中断状态 	描述
Inactive 	中断未触发状态，该中断即没有Pending也没有Active
Pending 	由于外设硬件产生了中断事件（或者软件触发）该中断事件已经通过硬件信号通知到GIC，等待GIC分配的那个CPU进行处理
Active 	CPU已经应答（acknowledge）了该interrupt请求，并且正在处理中
Active and Pending 	当一个中断源处于Active状态的时候，同一中断源又触发了中断，进入pending状态
processor ack了一个中断后，该中断会被设定为active。当处理完成后，仍然要通知GIC，中断已经处理完毕了。这时候，如果没有pending的中断，GIC就会将该interrupt设定为inactive状态。操作GIC中的End of Interrupt Register可以完成end of interrupt事件通知。 
4、BSP（bootstrap processor）之外，其他CPU的callback函数
对于multi processor系统，不可能初始化代码在所有的processor上都执行一遍，实际上，系统的硬件会选取一个processor作为引导处理器，我们称之BSP。这个processor会首先执行，其他的CPU都是处于reset状态，等到BSP初始化完成之后，release所有的non-BSP，这时候，系统中的各种外设硬件条件和软件条件（例如per CPU变量）都准备好了，各个non-BSP执行自己CPU specific的初始化就OK了。
上面描述的都是BSP的初始化过程，具体包括：
    ……
        gic_dist_init(gic);－－－－－－初始化GIC的Distributor
        gic_cpu_init(gic);－－－－－－初始化BSP的CPU interface
        gic_pm_init(gic);－－－－－－初始化GIC的Power management
    ……
对于GIC的Distributor和Power management，这两部分是全局性的，BSP执行初始化一次就OK了。对于CPU interface，每个processor负责初始化自己的连接的那个CPU interface HW block。我们用下面这个图片来描述这个过程： 
 booting
  假设CPUx被选定为BSP，那么第三章描述的初始化过程在该CPU上欢畅的执行。这时候，被初始化的GIC硬件包括：root GIC的Distributor、root GIC CPU Interface x（连接BSP的那个CPU interface）以及其他的级联的非root GIC（上图中绿色block，当然，我偷懒，没有画non-root GIC）。
BSP初始化完成之后，各个其他的CPU运行起来，会发送CPU_STARTING消息给关注该消息的模块。毫无疑问，GIC driver模块当然要关注这样的消息，在初始化过程中会注册callback函数如下：
    register_cpu_notifier(&gic_cpu_notifier);
GIC相关的回调函数定义如下：

    static struct notifier_block gic_cpu_notifier = {
        .notifier_call = gic_secondary_init,
        .priority = 100,
    };

    static int gic_secondary_init(struct notifier_block *nfb, unsigned long action,  void *hcpu)
    {
        if (action == CPU_STARTING || action == CPU_STARTING_FROZEN)
            gic_cpu_init(&gic_data[0]);－－－－－－－－－初始化那些非BSP的CPU interface
        return NOTIFY_OK;
    }

因此，当non-BSP booting up的时候，发送CPU_STARTING消息，调用GIC的callback函数，对上图中的紫色的CPU Interface HW block进行初始化，这样，就完成了全部GIC硬件的初始化过程。 
 
当网卡控制器的FIFO收到的来自以太网的数据的时候（例如半满的时候，可以软件设定），可以将该事件通过irq signal送达Interrupt Controller。Interrupt Controller可以把中断分发给系统中的Processor A or B。
NIC的中断处理过程大概包括：mask and ack interrupt controller-------->ack NIC-------->copy FIFO to ram------>handle Data in the ram----------->unmask interrupt controller
我们先假设Processor A处理了这个网卡中断事件，于是NIC的中断handler在Processor A上欢快的执行，这时候，Processor A的本地中断是disable的。NIC的中断handler在执行的过程中，网络数据仍然源源不断的到来，但是，如果NIC的中断handler不操作NIC的寄存器来ack这个中断的话，NIC是不会触发下一次中断的。还好，我们的NIC interrupt handler总是在最开始就会ack，因此，这不会导致性能问题。ack之后，NIC已经具体再次trigger中断的能力。当Processor A上的handler 在处理接收来自网络的数据的时候，NIC的FIFO很可能又收到新的数据，并trigger了中断，这时候，Interrupt controller还没有umask，因此，即便还有Processor B（也就是说有处理器资源），中断控制器也无法把这个中断送达处理器系统。因此，只能眼睁睁的看着NIC FIFO填满数据，数据溢出，或者向对端发出拥塞信号，无论如何，整体的系统性能是受到严重的影响。
注意：对于新的interrupt controller，可能没有mask和umask操作，但是原理是一样的，只不过NIC的handler执行完毕要发生EOI而已。
要解决上面的问题，最重要的是尽快的执行完中断handler，打开中断，unmask IRQ（或者发送EOI），方法就是把耗时的handle Data in the ram这个步骤踢出handler，让其在bottom half中执行。  

 三、理解softirq需要的基础知识（各种context）
1、preempt_count
为了更好的理解下面的内容，我们需要先看看一些基础知识：一个task的thread info数据结构定义如下（只保留和本场景相关的内容）：

    struct thread_info { 
        ……
        int            preempt_count;    /* 0 => preemptable, <0 => bug */
        ……
    };

preempt_count这个成员被用来判断当前进程是否可以被抢占。如果preempt_count不等于0（可能是代码调用preempt_disable显式的禁止了抢占，也可能是处于中断上下文等），说明当前不能进行抢占，如果preempt_count等于0，说明已经具备了抢占的条件（当然具体是否要抢占当前进程还是要看看thread info中的flag成员是否设定了_TIF_NEED_RESCHED这个标记，可能是当前的进程的时间片用完了，也可能是由于中断唤醒了优先级更高的进程）。 具体preempt_count的数据格式可以参考下图：
preempt_count:
reservebits	bit21		bit20		bit16~19	bit9~15	bit8	bit0~7
		preempt_active	NMI_flag	hardirq_count	softing_count	preemption_count
preemption count用来记录当前被显式的禁止抢占的次数，也就是说，每调用一次preempt_disable，preemption count就会加一，调用preempt_enable，该区域的数值会减去一。preempt_disable和preempt_enable必须成对出现，可以嵌套，最大嵌套的深度是255。
hardirq count描述当前中断handler嵌套的深度。对于ARM平台的linux kernel，其中断部分的代码如下：
    void handle_IRQ(unsigned int irq, struct pt_regs *regs)
    {
        struct pt_regs *old_regs = set_irq_regs(regs);

        irq_enter(); 
        generic_handle_irq(irq);

        irq_exit();
        set_irq_regs(old_regs);
    }
通用的IRQ handler被irq_enter和irq_exit这两个函数包围。irq_enter说明进入到IRQ context，而irq_exit则说明退出IRQ context。在irq_enter函数中会调用preempt_count_add(HARDIRQ_OFFSET)，为hardirq count的bit field增加1。在irq_exit函数中，会调用preempt_count_sub(HARDIRQ_OFFSET)，为hardirq count的bit field减去1。hardirq count占用了4个bit，说明硬件中断handler最大可以嵌套15层。在旧的内核中，hardirq count占用了12个bit，支持4096个嵌套。当然，在旧的kernel中还区分fast interrupt handler和slow interrupt handler，中断handler最大可以嵌套的次数理论上等于系统IRQ的个数。在实际中，这个数目不可能那么大（内核栈就受不了），因此，即使系统支持了非常大的中断个数，也不可能各个中断依次嵌套，达到理论的上限。基于这样的考虑，后来内核减少了hardirq count占用bit数目，改成了10个bit（在general arch的代码中修改为10，实际上，各个arch可以redefine自己的hardirq count的bit数）。但是，当内核大佬们决定废弃slow interrupt handler的时候，实际上，中断的嵌套已经不会发生了。因此，理论上，hardirq count要么是0，要么是1。不过呢，不能总拿理论说事，实际上，万一有写奇葩或者老古董driver在handler中打开中断，那么这时候中断嵌套还是会发生的，但是，应该不会太多（一个系统中怎么可能有那么多奇葩呢？呵呵），因此，目前hardirq count占用了4个bit，应付15个奇葩driver是妥妥的。
对softirq count进行操作有两个场景：
（1）也是在进入soft irq handler之前给 softirq count加一，退出soft irq handler之后给 softirq count减去一。由于soft irq handler在一个CPU上是不会并发的，总是串行执行，因此，这个场景下只需要一个bit就够了，也就是上图中的bit 8。通过该bit可以知道当前task是否在sofirq context。
（2）由于内核同步的需求，进程上下文需要禁止softirq。这时候，kernel提供了local_bf_enable和local_bf_disable这样的接口函数。这部分的概念是和preempt disable/enable类似的，占用了bit9～15，最大可以支持127次嵌套。 
 2、一个task的各种上下文
看完了preempt_count之后，我们来介绍各种context：
    #define in_irq()        (hardirq_count())
    #define in_softirq()        (softirq_count())
    #define in_interrupt()        (irq_count())
    #define in_serving_softirq()    (softirq_count() & SOFTIRQ_OFFSET)
这里首先要介绍的是一个叫做IRQ context的术语。这里的IRQ context其实就是hard irq context，也就是说明当前正在执行中断handler（top half），只要preempt_count中的hardirq count大于0（＝1是没有中断嵌套，如果大于1，说明有中断嵌套），那么就是IRQ context。
softirq context并没有那么的直接，一般人会认为当sofirq handler正在执行的时候就是softirq context。这样说当然没有错，sofirq handler正在执行的时候，会增加softirq count，当然是softirq context。不过，在其他context的情况下，例如进程上下文中，有有可能因为同步的要求而调用local_bh_disable，这时候，通过local_bh_disable/enable保护起来的代码也是执行在softirq context中。当然，这时候其实并没有正在执行softirq handler。如果你确实想知道当前是否正在执行softirq handler，in_serving_softirq可以完成这个使命，这是通过操作preempt_count的bit 8来完成的。
所谓中断上下文，就是IRQ context ＋ softirq context＋NMI context。 
关于开发中断的kernel-API 架构 workqueue softirq tasklet waitlist!!



















http://www.wowotech.net/device_model/bus.html
bus设备:
 subsys、devices_kset、drivers_kset是三个kset，由"Linux设备模型(2)_Kobject”中对kset的描述可知，kset是一个特殊的kobject，用来集合相似的kobject，它在sysfs中也会以目录的形式体现。其中subsys，代表了本bus（如/sys/bus/spi），它下面可以包含其它的kset或者其它的kobject；devices_kset和drivers_kset则是bus下面的两个kset（如/sys/bus/spi/devices和/sys/bus/spi/drivers），分别包括本bus下所有的device和device_driver。

interface是一个list head，用于保存该bus下所有的interface。有关interface的概念后面会详细介绍。 
 bus和class指针，分别保存上层的bus或者class指针。 

 bus_add_device的处理逻辑：

    调用内部的device_add_attrs接口，将由bus->dev_attrs指针定义的默认attribute添加到内核中，它们会体现在/sys/devices/xxx/xxx_device/目录中
    调用sysfs_create_link接口，将该device在sysfs中的目录，链接到该bus的devices目录下，例如：

    xxx# ls /sys/bus/spi/devices/spi1.0 -l                                                        
    lrwxrwxrwx root     root              2014-04-11 10:46 spi1.0 -> ../../../devices/platform/s3c64xx-spi.1/spi_master/spi1/spi1.0
    其中/sys/devices/…/spi1.0，为该device在sysfs中真正的位置，而为了方便管理，内核在该设备所在的bus的xxx_bus/devices目录中，创建了一个符号链接
    调用sysfs_create_link接口，在该设备的sysfs目录中（如/sys/devices/platform/alarm/）中，创建一个指向该设备所在bus目录的链接，取名为subsystem，例如：

    xxx # ls /sys/devices/platform/alarm/subsystem -l                                                
    lrwxrwxrwx root     root              2014-04-11 10:28 subsystem -> ../../../bus/platform
    最后，毫无疑问，要把该设备指针保存在bus->priv->klist_devices中

 bus_add_driver的处理逻辑：

    为该driver的struct driver_private指针（priv）分配空间，并初始化其中的priv->klist_devices、priv->driver、priv->kobj.kset等变量，同时将该指针保存在device_driver的p处
    将driver的kset（priv->kobj.kset）设置为bus的drivers kset（bus->p->drivers_kset），这就意味着所有driver的kobject都位于bus->p->drivers_kset之下（寄/sys/bus/xxx/drivers目录下）
    以driver的名字为参数，调用kobject_init_and_add接口，在sysfs中注册driver的kobject，体现在/sys/bus/xxx/drivers/目录下，如/sys/bus/spi/drivers/spidev
    将该driver保存在bus的klist_drivers链表中，并根据drivers_autoprobe的值，选择是否调用driver_attach进行probe
    调用driver_create_file接口，在sysfs的该driver的目录下，创建uevent attribute
    调用driver_add_attrs接口，在sysfs的该driver的目录下，创建由bus->drv_attrs指针定义的默认attribute
    同时根据suppress_bind_attrs标志，决定是否在sysfs的该driver的目录下，创建bind和unbind attribute（具体可参考"Linux设备模型(5)_device和device driver”中的介绍） 






trace处理	有一个debug linux用户程序的手段
Linux的内核提供了ptrace这样的系统调用，通过它，一个进程（我们称之 tracer，例如strace、gdb）可以观测和控制另外一个进程（被trace的进程，我们称之tracee）的执行。一旦Tracer和 tracee建立了跟踪关系，那么所有发送给tracee的信号(除SIGKILL)都会汇报给Tracer，以便Tracer可以控制或者观测 tracee的执行。例如断点的操作。Tracer程序一般会提供界面，以便用户可以设定一个断点（当tracee运行到断点时，会停下来）。当用户设定 了断点后，tracer就会保存该位置的指令，然后向该位置写入SWI __ARM_NR_breakpoint（这种断点是soft break point，可以设定无限多个，对于hard break point是和CPU体系结构相关，一般支持2个）。当执行到断点位置的时候，发生软中断，内核会给tracee进程发出SIGTRAP信号，当然这个信号也会被tracer捕获。对于tracee，当收到信号的时候，无论是什么信号，甚至是ignor的信号，tracee进程都会停止运行。Tracer进程可以对tracee进行各种操作，例如观察tracer的寄存器，观察变量等等。 










struct class是class的抽象，它的定义如下：
   1: /* include/linux/device.h, line 332 */
   2: struct class {
   3:         const char              *name;
   4:         struct module           *owner;
   5:  
   6:         struct class_attribute          *class_attrs;
   7:         struct device_attribute         *dev_attrs;
   8:         struct bin_attribute            *dev_bin_attrs;
   9:         struct kobject                  *dev_kobj;
  10:  
  11:         int (*dev_uevent)(struct device *dev, struct kobj_uevent_env *env);
  12:         char *(*devnode)(struct device *dev, umode_t *mode);
  13:  
  14:         void (*class_release)(struct class *class);
  15:         void (*dev_release)(struct device *dev);
  16:  
  17:         int (*suspend)(struct device *dev, pm_message_t state);
  18:         int (*resume)(struct device *dev);
  19:  
  20:         const struct kobj_ns_type_operations *ns_type;
  21:         const void *(*namespace)(struct device *dev);
  22:  
  23:         const struct dev_pm_ops *pm;
  24:  
  25:         struct subsys_private *p;
  26: };
    其实struct class和struct bus很类似，解释如下：
    name，class的名称，会在“/sys/class/”目录下体现。
    class_atrrs，该class的默认attribute，会在class注册到内核时，自动在“/sys/class/xxx_class”下创建对应的attribute文件。
    dev_attrs，该class下每个设备的attribute，会在设备注册到内核时，自动在该设备的sysfs目录下创建对应的attribute文件。
    dev_bin_attrs，类似dev_attrs，只不过是二进制类型attribute。
    dev_kobj，表示该class下的设备在/sys/dev/下的目录，现在一般有char和block两个，如果dev_kobj为NULL，则默认选择char。
    dev_uevent，当该class下有设备发生变化时，会调用class的uevent回调函数。
    class_release，用于release自身的回调函数。
    dev_release，用于release class内设备的回调函数。在device_release接口中，会依次检查Device、Device Type以及Device所在的class，是否注册release接口，如果有则调用相应的release接口release设备指针。
    p，和“Linux设备模型(6)_Bus”中struct bus结构一样，不再说明。

    device的注册最终是由device_add接口（drivers/base/core.c）实现了，该接口中和class有关的动作包括：

        调用device_add_class_symlinks接口，创建3.1小节描述的各种符号链接，即：在对应class的目录下，创建指向device的符号链接；在device的目录下，创建名称为subsystem、指向对应class目录的符号链接
        调用device_add_attrs，添加由class指定的attributes（class->dev_attrs）
        如果存在对应该class的add_dev回调函数，调用该回调函数
依旧没有弄清楚class在内核到底是怎么使用的









电源管理有关的Source code分别位于：

    kernel/power/ *
    drivers/power/
    drivers/base/power/*
    drivers/cpuidle/*
    drivers/cpufreq/*
    drivers/devfreq/*
    include/linux/power_supply.h
    include/linux/cpuidle.h
    include/linux/cpufreq.h
    include/linux/cpu_pm.h
    include/linux/device.h
    include/linux/pm.h
    include/linux/pm domain.h
    include/linux/pm runtime.h
    include/linux/pm wakeup.h
    include/linux/suspend.h
    Documentation/power/*.txt




































































































































